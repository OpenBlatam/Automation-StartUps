"""
Módulo para sincronizar productos de Stripe con ítems de QuickBooks.
Cuando se crea o actualiza un producto en Stripe, verifica en QuickBooks si existe un ítem
con el mismo nombre/precio. Si no existe, lo crea; si existe, actualiza el precio.

Variables de entorno requeridas:
- QUICKBOOKS_ACCESS_TOKEN: Token de acceso OAuth2 de QuickBooks
- QUICKBOOKS_REALM_ID: ID de la compañía en QuickBooks
- QUICKBOOKS_BASE: URL base de la API (default: sandbox, usar producción en producción)

Variables de entorno opcionales:
- QUICKBOOKS_CLIENT_ID: ID del cliente OAuth (solo para refresh tokens)
- QUICKBOOKS_CLIENT_SECRET: Secret del cliente OAuth (solo para refresh tokens)
- QUICKBOOKS_REFRESH_TOKEN: Refresh token OAuth (solo para refresh tokens)
- QUICKBOOKS_INCOME_ACCOUNT: Nombre de la cuenta de ingresos por defecto para nuevos ítems

Ejemplo de uso:
    resultado = sincronizar_producto_stripe_quickbooks(
        stripe_product_id="prod_1234567890",
        nombre_producto="Producto Premium",
        precio=99.99
    )
    print(resultado)  # 'creado 123' o 'actualizado 123' o mensaje de error
    
    # O con resultado estructurado:
    sync_result = sync_stripe_product_to_quickbooks(
        stripe_product_id="prod_1234567890",
        nombre_producto="Producto Premium",
        precio=99.99
    )
    if sync_result.success:
        print(f"Ítem {sync_result.action} con ID {sync_result.qb_item_id}")
"""
import os
import re
import time
import logging
import hashlib
from dataclasses import dataclass, field
from decimal import Decimal, ROUND_HALF_UP
from typing import Optional, Dict, Any, Literal, Union, List
from enum import Enum
from contextlib import contextmanager
from functools import lru_cache

import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

# Intentar importar librerías opcionales
try:
    from pydantic import BaseModel, Field, ValidationError
    PYDANTIC_AVAILABLE = True
except ImportError:
    PYDANTIC_AVAILABLE = False

try:
    from cachetools import TTLCache
    CACHETOOLS_AVAILABLE = True
except ImportError:
    CACHETOOLS_AVAILABLE = False

try:
    from airflow.stats import Stats
    STATS_AVAILABLE = True
except ImportError:
    STATS_AVAILABLE = False

try:
    from tenacity import (
        retry,
        stop_after_attempt,
        wait_exponential,
        retry_if_exception_type,
        retry_if_result,
        RetryError,
        before_sleep_log,
        after_log,
    )
    TENACITY_AVAILABLE = True
except ImportError:
    TENACITY_AVAILABLE = False

try:
    import httpx
    HTTPX_AVAILABLE = True
except ImportError:
    HTTPX_AVAILABLE = False

try:
    from concurrent.futures import ThreadPoolExecutor, as_completed
    CONCURRENT_FUTURES_AVAILABLE = True
except ImportError:
    CONCURRENT_FUTURES_AVAILABLE = False

try:
    from circuitbreaker import circuit
    CIRCUITBREAKER_AVAILABLE = True
except ImportError:
    CIRCUITBREAKER_AVAILABLE = False

logger = logging.getLogger(__name__)

try:
    import psutil
    PSUTIL_AVAILABLE = True
except ImportError:
    PSUTIL_AVAILABLE = False


# Constantes de configuración
if 'MAX_BATCH_SIZE' not in globals():
    MAX_BATCH_SIZE = int(os.environ.get("QB_MAX_BATCH_SIZE", "1000"))
if 'RETRY_JITTER_MAX' not in globals():
    RETRY_JITTER_MAX = float(os.environ.get("QB_RETRY_JITTER_MAX", "1.0"))
if 'DEFAULT_BATCH_WORKERS' not in globals():
    DEFAULT_BATCH_WORKERS = int(os.environ.get("QB_DEFAULT_BATCH_WORKERS", "5"))
if 'DEFAULT_BATCH_DELAY' not in globals():
    DEFAULT_BATCH_DELAY = float(os.environ.get("QB_DEFAULT_BATCH_DELAY", "0.1"))
MEMORY_MONITORING_ENABLED = os.environ.get("QB_MEMORY_MONITORING_ENABLED", "true").lower() == "true"
MEMORY_CLEANUP_THRESHOLD_MB = float(os.environ.get("QB_MEMORY_CLEANUP_THRESHOLD_MB", "500.0"))

# Función auxiliar para logging estructurado
def log_with_context(logger_instance, level: int, message: str, **kwargs):
    """Helper para logging estructurado con contexto adicional."""
    extra = {k: v for k, v in kwargs.items() if v is not None}
    logger_instance.log(level, message, extra=extra)



# Excepciones personalizadas
class QuickBooksError(Exception):
    """Excepción base para errores de QuickBooks."""
    pass


class QuickBooksAuthError(QuickBooksError):
    """Error de autenticación con QuickBooks."""
    pass


class QuickBooksAPIError(QuickBooksError):
    """Error en la respuesta de la API de QuickBooks."""
    def __init__(self, message: str, status_code: Optional[int] = None, error_data: Optional[Dict] = None):
        super().__init__(message)
        self.status_code = status_code
        self.error_data = error_data


class QuickBooksValidationError(QuickBooksError):
    """Error de validación de parámetros."""
    pass


@dataclass
class QuickBooksConfig:
    """Configuración para QuickBooks."""
    access_token: Optional[str] = None
    client_id: Optional[str] = None
    client_secret: Optional[str] = None
    refresh_token: Optional[str] = None
    realm_id: Optional[str] = None
    company_id: Optional[str] = None
    base_url: Optional[str] = None
    environment: str = "production"
    income_account: str = "Sales"
    api_version: str = "v3"
    minor_version: str = "65"
    timeout: int = 30
    max_retries: int = 3
    retry_backoff_factor: float = 1.0
    rate_limit_max_wait: int = 300  # 5 minutos máximo
    use_httpx: bool = False  # Usar httpx en lugar de requests si está disponible


class ItemType(Enum):
    """Tipos de ítems en QuickBooks."""
    SERVICE = "Service"
    INVENTORY = "Inventory"
    NON_INVENTORY = "NonInventory"


@dataclass
class SyncResult:
    """Resultado estructurado de la sincronización."""
    success: bool
    action: Literal["creado", "actualizado"] | None
    qb_item_id: str | None
    error_message: str | None = None
    stripe_product_id: str | None = None
    nombre_producto: str | None = None
    precio: float | None = None
    duration_ms: Optional[float] = None
    retries: int = 0
    
    def __str__(self) -> str:
        """Retorna formato string compatible con la función original."""
        if self.success and self.action and self.qb_item_id:
            return f"{self.action} {self.qb_item_id}"
        return self.error_message or "ERROR: Resultado desconocido"
    
    def to_dict(self) -> Dict[str, Any]:
        """Convierte el resultado a diccionario."""
        return {
            "success": self.success,
            "action": self.action,
            "qb_item_id": self.qb_item_id,
            "error_message": self.error_message,
            "stripe_product_id": self.stripe_product_id,
            "nombre_producto": self.nombre_producto,
            "precio": self.precio,
            "duration_ms": self.duration_ms,
            "retries": self.retries
        }


@dataclass
class BatchSyncResult:
    """Resultado de sincronización en batch."""
    total: int
    successful: int
    failed: int
    results: List[SyncResult]
    duration_ms: float
    
    @property
    def success_rate(self) -> float:
        """Tasa de éxito en porcentaje."""
        if self.total == 0:
            return 0.0
        return (self.successful / self.total) * 100.0
    
    def to_dict(self) -> Dict[str, Any]:
        """Convierte el resultado a diccionario."""
        return {
            "total": self.total,
            "successful": self.successful,
            "failed": self.failed,
            "success_rate": self.success_rate,
            "duration_ms": self.duration_ms,
            "results": [r.to_dict() for r in self.results]
        }


# Modelos Pydantic si están disponibles
if PYDANTIC_AVAILABLE:
    class StripeProductInput(BaseModel):
        """Modelo de validación para entrada de producto Stripe."""
        stripe_product_id: str = Field(..., min_length=1, max_length=255, description="ID del producto en Stripe")
        nombre_producto: str = Field(..., min_length=1, max_length=100, description="Nombre del producto")
        precio: Decimal = Field(..., ge=0, decimal_places=2, description="Precio del producto")
        
        class Config:
            """Configuración del modelo."""
            json_encoders = {Decimal: lambda v: float(v)}
else:
    # Fallback sin Pydantic
    class StripeProductInput:
        """Fallback sin Pydantic."""
        def __init__(self, stripe_product_id: str, nombre_producto: str, precio: float):
            self.stripe_product_id = stripe_product_id
            self.nombre_producto = nombre_producto
            self.precio = Decimal(str(precio))


class QuickBooksClient:
    """
    Cliente para interactuar con la API de QuickBooks.
    
    Maneja autenticación, refresh tokens, y operaciones CRUD sobre ítems.
    Incluye cache para búsquedas, métricas de uso, retries inteligentes, y circuit breaker.
    """
    
    OAUTH_URL = "https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer"
    
    # Cache para búsquedas de ítems (TTL de 5 minutos)
    _item_cache: Optional[TTLCache] = None
    
    def __init__(self, config: Optional[QuickBooksConfig] = None):
        """
        Inicializa el cliente de QuickBooks.
        
        Args:
            config: Configuración de QuickBooks. Si es None, se cargan desde variables de entorno.
        """
        if config is None:
            config = self._load_config_from_env()
        self.config = config
        
        # Usar httpx si está disponible y configurado
        if self.config.use_httpx and HTTPX_AVAILABLE:
            self._session = self._create_httpx_session()
            self._use_httpx = True
        else:
            self._session = self._create_session()
            self._use_httpx = False
        
        # Inicializar cache si está disponible
        if CACHETOOLS_AVAILABLE and QuickBooksClient._item_cache is None:
            QuickBooksClient._item_cache = TTLCache(maxsize=100, ttl=300)  # 5 minutos
    
    @contextmanager
    def _track_metric(self, metric_name: str, tags: Optional[Dict[str, str]] = None):
        """Context manager para trackear métricas."""
        if STATS_AVAILABLE:
            try:
                stats = Stats()
                stats.incr(f"quickbooks.{metric_name}", tags=tags or {})
            except Exception as e:
                logger.debug(f"Could not track metric: {e}")
        yield
    
    def _normalize_price(self, price: float | Decimal) -> str:
        """Normaliza el precio a string con 2 decimales."""
        if isinstance(price, Decimal):
            return str(price.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP))
        return str(Decimal(str(price)).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP))
    
    def _validate_item_name(self, name: str) -> str:
        """Valida y sanitiza el nombre del ítem."""
        if not name or not name.strip():
            raise QuickBooksValidationError("El nombre del ítem no puede estar vacío")
        
        name = name.strip()
        # QuickBooks tiene límites de longitud
        if len(name) > 100:
            logger.warning(f"Nombre de ítem truncado de {len(name)} a 100 caracteres")
            name = name[:100]
        
        return name
    
    def health_check(self) -> Dict[str, Any]:
        """
        Realiza un health check de la conexión con QuickBooks.
        
        Returns:
            Dict con el estado de la conexión y componentes.
            
        Raises:
            QuickBooksError: Si el health check falla.
        """
        health_status = {
            "status": "ok",
            "timestamp": time.time(),
            "checks": {}
        }
        
        try:
            # Verificar autenticación
            try:
                access_token = self._get_access_token()
                health_status["checks"]["authentication"] = {
                    "status": "ok",
                    "has_token": bool(access_token)
                }
            except Exception as e:
                health_status["checks"]["authentication"] = {
                    "status": "error",
                    "error": str(e)
                }
                health_status["status"] = "error"
            
            # Verificar company ID
            try:
                company_id = self._get_company_id()
                health_status["checks"]["company_id"] = {
                    "status": "ok",
                    "company_id": company_id
                }
            except Exception as e:
                health_status["checks"]["company_id"] = {
                    "status": "error",
                    "error": str(e)
                }
                health_status["status"] = "error"
            
            # Verificar conectividad haciendo una query simple
            try:
                company_id = self._get_company_id()
                base_url = self.config.base_url or "https://quickbooks.api.intuit.com"
                url = f"{base_url}/v3/company/{company_id}/query"
                
                headers = self._get_headers()
                headers["Content-Type"] = "application/text"
                
                params = {
                    "minorversion": self.config.minor_version,
                    "query": "SELECT COUNT(*) FROM Item MAXRESULTS 1"
                }
                
                if self._use_httpx and HTTPX_AVAILABLE:
                    response = self._session.get(url, headers=headers, params=params)
                else:
                    response = self._session.get(
                        url, 
                        headers=headers, 
                        params=params,
                        timeout=10  # Timeout más corto para health check
                    )
                
                if response.status_code == 200:
                    health_status["checks"]["api_connectivity"] = {
                        "status": "ok",
                        "response_time_ms": None  # Podríamos medir esto
                    }
                else:
                    health_status["checks"]["api_connectivity"] = {
                        "status": "warning",
                        "status_code": response.status_code
                    }
                    if health_status["status"] == "ok":
                        health_status["status"] = "degraded"
                        
            except Exception as e:
                health_status["checks"]["api_connectivity"] = {
                    "status": "error",
                    "error": str(e)
                }
                health_status["status"] = "error"
            
            # Verificar cache
            if CACHETOOLS_AVAILABLE and self._item_cache:
                health_status["checks"]["cache"] = {
                    "status": "ok",
                    "size": len(self._item_cache),
                    "maxsize": self._item_cache.maxsize
                }
            else:
                health_status["checks"]["cache"] = {
                    "status": "disabled"
                }
            
        except Exception as e:
            health_status["status"] = "error"
            health_status["error"] = str(e)
            logger.error(f"Health check failed: {str(e)}")
        
        return health_status
    
    def __enter__(self):
        """Context manager entry."""
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit - cierra la sesión."""
        if hasattr(self, '_session') and self._session:
            try:
                if self._use_httpx and HTTPX_AVAILABLE:
                    self._session.close()
                # requests.Session no necesita close explícito, pero lo hacemos por limpieza
                elif hasattr(self._session, 'close'):
                    self._session.close()
            except Exception as e:
                logger.debug(f"Error closing session: {e}")
        return False
    
    @staticmethod
    def _load_config_from_env() -> QuickBooksConfig:
        """Carga la configuración desde variables de entorno."""
        environment = os.environ.get("QUICKBOOKS_ENVIRONMENT", "production")
        base_url = os.environ.get(
            "QUICKBOOKS_BASE",
            "https://quickbooks.api.intuit.com" if environment == "production"
            else "https://sandbox-quickbooks.api.intuit.com"
        )
        
        return QuickBooksConfig(
            access_token=os.environ.get("QUICKBOOKS_ACCESS_TOKEN"),
            client_id=os.environ.get("QUICKBOOKS_CLIENT_ID"),
            client_secret=os.environ.get("QUICKBOOKS_CLIENT_SECRET"),
            refresh_token=os.environ.get("QUICKBOOKS_REFRESH_TOKEN"),
            realm_id=os.environ.get("QUICKBOOKS_REALM_ID"),
            company_id=os.environ.get("QUICKBOOKS_COMPANY_ID"),
            base_url=base_url,
            environment=environment,
            income_account=os.environ.get("QUICKBOOKS_INCOME_ACCOUNT", "Sales")
        )
    
    def _create_session(self) -> requests.Session:
        """Crea una sesión HTTP con retry strategy."""
        session = requests.Session()
        
        # Configurar retry strategy mejorada
        retry_strategy = Retry(
            total=self.config.max_retries,
            backoff_factor=self.config.retry_backoff_factor,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["GET", "POST", "PUT", "PATCH"],
            raise_on_status=False  # No lanzar excepciones automáticamente
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        session.mount("http://", adapter)
        session.mount("https://", adapter)
        
        return session
    
    def _create_httpx_session(self):
        """Crea una sesión httpx con configuración mejorada."""
        if not HTTPX_AVAILABLE:
            raise RuntimeError("httpx no está disponible")
        
        limits = httpx.Limits(max_keepalive_connections=5, max_connections=10)
        timeout = httpx.Timeout(self.config.timeout, connect=10.0)
        
        return httpx.Client(
            limits=limits,
            timeout=timeout,
            follow_redirects=True,
            http2=True  # HTTP/2 si está disponible
        )
    
    def _get_access_token_with_retry(self) -> str:
        """
        Obtiene un access token válido con retry usando tenacity si está disponible.
        
        Returns:
            Access token válido.
            
        Raises:
            QuickBooksAuthError: Si no se puede obtener el token.
        """
        # Si ya tenemos un access token, lo usamos
        if self.config.access_token:
            return self.config.access_token
        
        # Si no, intentamos refrescarlo
        if not all([self.config.client_id, self.config.client_secret, self.config.refresh_token]):
            raise QuickBooksAuthError(
                "Se requiere QUICKBOOKS_ACCESS_TOKEN o (QUICKBOOKS_CLIENT_ID, "
                "QUICKBOOKS_CLIENT_SECRET, QUICKBOOKS_REFRESH_TOKEN)"
            )
        
        def _refresh_token():
            """Función interna para refrescar el token."""
            if self._use_httpx and HTTPX_AVAILABLE:
                response = self._session.post(
                    self.OAUTH_URL,
                    headers={
                        "Accept": "application/json",
                        "Content-Type": "application/x-www-form-urlencoded"
                    },
                    data={
                        "grant_type": "refresh_token",
                        "refresh_token": self.config.refresh_token
                    },
                    auth=(self.config.client_id, self.config.client_secret)
                )
                response.raise_for_status()
                token_data = response.json()
            else:
                response = self._session.post(
                    self.OAUTH_URL,
                    headers={
                        "Accept": "application/json",
                        "Content-Type": "application/x-www-form-urlencoded"
                    },
                    data={
                        "grant_type": "refresh_token",
                        "refresh_token": self.config.refresh_token
                    },
                    auth=(self.config.client_id, self.config.client_secret),
                    timeout=self.config.timeout
                )
                response.raise_for_status()
                token_data = response.json()
            
            access_token = token_data.get("access_token")
            if not access_token:
                raise QuickBooksAuthError("No se recibió access_token en la respuesta")
            
            # Actualizar el token en la configuración
            self.config.access_token = access_token
            return access_token
        
        # Usar tenacity si está disponible
        if TENACITY_AVAILABLE:
            @retry(
                stop=stop_after_attempt(self.config.max_retries + 1),
                wait=wait_exponential(multiplier=self.config.retry_backoff_factor, min=1, max=10),
                retry=retry_if_exception_type((requests.exceptions.RequestException, QuickBooksAuthError)),
                before_sleep=before_sleep_log(logger, logging.WARNING),
                after=after_log(logger, logging.INFO),
                reraise=True
            )
            def _retry_refresh():
                try:
                    return _refresh_token()
                except Exception as e:
                    if isinstance(e, QuickBooksAuthError):
                        raise
                    raise QuickBooksAuthError(f"Error al obtener access token: {str(e)}")
            
            return _retry_refresh()
        else:
            try:
                return _refresh_token()
            except requests.exceptions.RequestException as e:
                raise QuickBooksAuthError(f"Error al obtener access token: {str(e)}")
    
    def _get_access_token(self) -> str:
        """Wrapper para compatibilidad con código existente."""
        return self._get_access_token_with_retry()
    
    def _get_company_id(self) -> str:
        """Obtiene el company ID (realm_id o company_id)."""
        company_id = self.config.realm_id or self.config.company_id
        if not company_id:
            raise QuickBooksValidationError(
                "QUICKBOOKS_REALM_ID o QUICKBOOKS_COMPANY_ID es requerido"
            )
        return company_id
    
    def _get_headers(self) -> Dict[str, str]:
        """Obtiene los headers para las peticiones a QuickBooks."""
        access_token = self._get_access_token()
        return {
            "Authorization": f"Bearer {access_token}",
            "Accept": "application/json",
            "Content-Type": "application/json"
        }
    
    def _handle_rate_limit(self, response, attempt: int = 0) -> None:
        """Maneja rate limiting (429) con retry after y delay adaptativo con jitter."""
        if response.status_code == 429:
            # Obtener Retry-After del header o calcular con backoff exponencial
            base_delay = float(response.headers.get('Retry-After', 
                self.config.retry_backoff_factor * (2 ** attempt)))
            
            # Aplicar jitter aleatorio si está habilitado
            try:
                if 'RETRY_JITTER_MAX' in globals() and RETRY_JITTER_MAX > 0:
                    import random
                    jitter = random.uniform(0, min(base_delay * 0.1, RETRY_JITTER_MAX))
                    retry_after = base_delay + jitter
                else:
                    retry_after = base_delay
            except Exception:
                retry_after = base_delay
            
            retry_after = min(retry_after, self.config.rate_limit_max_wait)
            
            logger.warning(
                f"Rate limited por QuickBooks, esperando {retry_after:.2f}s",
                extra={"retry_after": retry_after, "attempt": attempt, "base_delay": base_delay}
            )
            
            # Trackear métrica de rate limit
            if STATS_AVAILABLE:
                try:
                    Stats().incr("quickbooks.rate_limit.hit", 1)
                    Stats().timing("quickbooks.rate_limit.wait_seconds", int(retry_after))
                except Exception:
                    pass
            
            time.sleep(retry_after)
    
    def _execute_http_request(
        self,
        method: str,
        url: str,
        headers: Dict[str, str],
        params: Dict[str, Any],
        json_data: Optional[Dict] = None
    ) -> Any:
        """
        Ejecuta una petición HTTP usando httpx o requests.
        Función pura helper para evitar duplicación.
        
        Args:
            method: Método HTTP
            url: URL completa
            headers: Headers HTTP
            params: Parámetros de query
            json_data: Datos JSON para el body
            
        Returns:
            Response object de httpx o requests
        """
        if self._use_httpx and HTTPX_AVAILABLE:
            return self._session.request(
                method=method,
                url=url,
                headers=headers,
                params=params,
                json=json_data
            )
        
        return self._session.request(
            method=method,
            url=url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=self.config.timeout
        )
    
    def _parse_response_json(self, response: Any) -> Dict[str, Any]:
        """
        Parsea JSON de la respuesta. Función pura helper.
        
        Args:
            response: Response object de httpx o requests
            
        Returns:
            Diccionario con datos parseados o vacío si falla
        """
        try:
            if hasattr(response, 'json'):
                return response.json()
            return {}
        except (ValueError, AttributeError):
            return {}
    
    def _make_request(
        self,
        method: str,
        endpoint: str,
        params: Optional[Dict] = None,
        json_data: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """
        Realiza una petición HTTP a la API de QuickBooks con retry y rate limiting.
        Implementa guard clauses y funciones auxiliares para reducir duplicación.
        
        Args:
            method: Método HTTP (GET, POST, etc.)
            endpoint: Endpoint relativo (ej: "/v3/company/123/item")
            params: Parámetros de query
            json_data: Datos JSON para el body
            
        Returns:
            Respuesta JSON parseada.
            
        Raises:
            QuickBooksAPIError: Si la petición falla.
        """
        # Guard clauses: validación temprana
        if not method or not endpoint:
            raise QuickBooksValidationError("method y endpoint son requeridos")
        
        company_id = self._get_company_id()
        base_url = self.config.base_url or "https://quickbooks.api.intuit.com"
        url = f"{base_url}{endpoint}".replace("{company_id}", company_id)
        
        headers = self._get_headers()
        
        # Agregar minor version a los params
        if params is None:
            params = {}
        params.setdefault("minorversion", self.config.minor_version)
        
        def _execute_request():
            """Función interna para ejecutar la petición."""
            # Ejecutar petición inicial
            response = self._execute_http_request(method, url, headers, params, json_data)
            
            # Manejar rate limiting con guard clause
            if response.status_code == 429:
                self._handle_rate_limit(response)
                # Retry después de esperar
                response = self._execute_http_request(method, url, headers, params, json_data)
            
            # Parsear respuesta
            response_data = self._parse_response_json(response)
            
            # Guard clause: verificar errores HTTP
            if response.status_code >= 400:
                error_msg = self._extract_error_message(response, response_data)
                raise QuickBooksAPIError(
                    error_msg,
                    status_code=response.status_code,
                    error_data=response_data
                )
            
            return response_data
        
        # Usar tenacity si está disponible para retries más robustos
        if TENACITY_AVAILABLE:
            @retry(
                stop=stop_after_attempt(self.config.max_retries + 1),
                wait=wait_exponential(
                    multiplier=self.config.retry_backoff_factor, 
                    min=1, 
                    max=30
                ),
                retry=retry_if_exception_type((
                    requests.exceptions.Timeout,
                    requests.exceptions.ConnectionError,
                    QuickBooksAPIError
                )) | retry_if_result(lambda x: False),  # No retry en éxito
                before_sleep=before_sleep_log(logger, logging.WARNING),
                after=after_log(logger, logging.INFO),
                reraise=True
            )
            def _retry_request():
                return _execute_request()
            
            try:
                return _retry_request()
            except RetryError as e:
                raise QuickBooksAPIError(f"Error después de {self.config.max_retries} intentos: {str(e.last_attempt.exception())}")
        else:
            try:
                return _execute_request()
            except requests.exceptions.Timeout:
                raise QuickBooksAPIError(
                    "La petición a QuickBooks excedió el tiempo límite",
                    status_code=408
                )
            except requests.exceptions.ConnectionError:
                raise QuickBooksAPIError(
                    "No se pudo conectar con QuickBooks API",
                    status_code=503
                )
            except QuickBooksAPIError:
                raise
            except requests.exceptions.RequestException as e:
                raise QuickBooksAPIError(f"Error en la petición: {str(e)}")
    
    @staticmethod
    def _extract_error_from_fault(response_data: Dict) -> Optional[str]:
        """
        Extrae mensaje de error desde la estructura Fault de QuickBooks.
        Función pura helper.
        
        Args:
            response_data: Datos de la respuesta
            
        Returns:
            Mensaje de error o None si no se encuentra
        """
        fault = response_data.get("Fault", {})
        errors = fault.get("Error", [])
        
        if not errors:
            return None
        
        error = errors[0] if isinstance(errors, list) else errors
        detail = error.get("Detail", "")
        message = error.get("Message", "")
        
        if detail:
            return f"{message}. {detail}".strip()
        
        return message or None
    
    @staticmethod
    def _extract_error_from_response(response: Union[requests.Response, Any]) -> str:
        """
        Extrae mensaje de error desde el objeto response.
        Función pura helper.
        
        Args:
            response: Response object
            
        Returns:
            Mensaje de error o "Error desconocido"
        """
        if hasattr(response, 'text') and response.text:
            return response.text
        
        if hasattr(response, 'content'):
            try:
                content = response.content.decode('utf-8')
                if content:
                    return content
            except Exception:
                pass
        
        return "Error desconocido"
    
    @staticmethod
    def _extract_error_message(response: Union[requests.Response, Any], response_data: Dict) -> str:
        """
        Extrae el mensaje de error de la respuesta de QuickBooks.
        Implementa funciones auxiliares puras para mejor modularidad.
        
        Args:
            response: Response object
            response_data: Datos parseados de la respuesta
            
        Returns:
            Mensaje de error
        """
        # Intentar extraer desde estructura Fault primero
        fault_error = QuickBooksClient._extract_error_from_fault(response_data)
        if fault_error:
            return fault_error
        
        # Fallback: extraer desde response
        return QuickBooksClient._extract_error_from_response(response)
    
    def find_item_by_name(self, name: str, use_cache: bool = True) -> Optional[Dict[str, Any]]:
        """
        Busca un ítem en QuickBooks por nombre.
        
        Args:
            name: Nombre del ítem.
            use_cache: Si usar cache para la búsqueda (default: True).
            
        Returns:
            Datos del ítem si se encuentra, None si no existe.
            
        Raises:
            QuickBooksAPIError: Si hay error en la búsqueda.
            """
        if not name:
            return None
        
        # Validar nombre
        name = self._validate_item_name(name)
        
        # Intentar obtener del cache
        cache_key = f"item_name:{name.lower().strip()}"
        if use_cache and CACHETOOLS_AVAILABLE and self._item_cache:
            cached_item = self._item_cache.get(cache_key)
            if cached_item is not None:
                logger.debug(f"Ítem encontrado en cache: {name}")
                return cached_item
        
        try:
        with self._track_metric("find_item", tags={"operation": "search"}):
                # Escapar nombre de manera segura para SQL

                # Escapar nombre de manera segura para SQL
                query = f"SELECT * FROM Item WHERE Name = '{name_escaped}' MAXRESULTS 1"
            
                company_id = self._get_company_id()
                base_url = self.config.base_url or "https://quickbooks.api.intuit.com"
                url = f"{base_url}/v3/company/{company_id}/query"

                headers = self._get_headers()
                headers["Content-Type"] = "application/text"

                params = {
                "minorversion": self.config.minor_version,
                "query": query
                }
                
                # Usar función helper para ejecutar request

                response = self._execute_http_request("GET", url, headers, params)

            
                # Guard clause: éxito inmediato

                if response.status_code == 200:

                data = self._parse_response_json(response)
                query_response = data.get("QueryResponse", {})
                items = query_response.get("Item", [])
                
                if items:
                    item = items[0] if isinstance(items, list) else items
                # Guardar en cache

                    if use_cache and CACHETOOLS_AVAILABLE and self._item_cache:
                        self._item_cache[cache_key] = item
                    return item
                return None
            
                # Guard clause: sin resultados (400)

                if response.status_code == 400:

                return None
            
                # Error en la respuesta

                response_data = self._parse_response_json(response)

                error_msg = self._extract_error_message(response, response_data)
                raise QuickBooksAPIError(error_msg, status_code=response.status_code)
            
        except QuickBooksAPIError:
            raise
        except Exception as e:
            if isinstance(e, QuickBooksAPIError):
                raise
            # Convertir otros errores a QuickBooksAPIError
            error_msg = f"Error al buscar ítem: {str(e)}"
            if isinstance(e, (requests.exceptions.RequestException,)):
                error_msg = f"Error de conexión al buscar ítem: {str(e)}"
            raise QuickBooksAPIError(error_msg)
    
    def create_item(
        self,
        name: str,
        price: float | Decimal,
        item_type: ItemType = ItemType.SERVICE,
        income_account: Optional[str] = None,
        private_note: Optional[str] = None
    ) -> str:
        """
        Crea un nuevo ítem en QuickBooks.
        
        Args:
            name: Nombre del ítem.
            price: Precio del ítem.
            item_type: Tipo de ítem (Service, Inventory, NonInventory).
            income_account: Nombre de la cuenta de ingresos.
            private_note: Nota privada para el ítem.
            
        Returns:
            ID del ítem creado.
            
        Raises:
            QuickBooksAPIError: Si falla la creación.
        """
        name = self._validate_item_name(name)
        price_normalized = self._normalize_price(price)
        
        company_id = self._get_company_id()
        income_account_name = income_account or self.config.income_account
        
        payload = {
            "Name": name,
            "Type": item_type.value,
            "UnitPrice": price_normalized,
            "IncomeAccountRef": {
                "name": income_account_name
            }
        }
        
        if private_note:
            payload["PrivateNote"] = private_note
        
        with self._track_metric("create_item", tags={"item_type": item_type.value}):
            endpoint = f"/v3/company/{company_id}/item"
            response_data = self._make_request("POST", endpoint, json_data=payload)
            
            item_data = response_data.get("Item", {})
            item_id = item_data.get("Id")
            
            if not item_id:
                raise QuickBooksAPIError("No se pudo obtener el ID del ítem creado")
            
            # Invalidar cache
            if CACHETOOLS_AVAILABLE and self._item_cache:
                cache_key = f"item_name:{name.lower().strip()}"
                self._item_cache.pop(cache_key, None)
            
            return str(item_id)
    
    def update_item(
        self,
        item_id: str,
        sync_token: str,
        name: Optional[str] = None,
        price: Optional[float | Decimal] = None,
        item_type: Optional[ItemType] = None,
        income_account: Optional[str] = None,
        private_note: Optional[str] = None,
        preserve_properties: Optional[Dict[str, Any]] = None
    ) -> str:
        """
        Actualiza un ítem existente en QuickBooks.
        
        Args:
            item_id: ID del ítem a actualizar.
            sync_token: Sync token del ítem (requerido para actualizar).
            name: Nuevo nombre (opcional).
            price: Nuevo precio (opcional).
            item_type: Nuevo tipo (opcional).
            income_account: Nueva cuenta de ingresos (opcional).
            private_note: Nueva nota privada (opcional).
            preserve_properties: Propiedades a preservar del ítem original.
            
        Returns:
            ID del ítem actualizado.
            
        Raises:
            QuickBooksAPIError: Si falla la actualización.
        """
        company_id = self._get_company_id()
        
        payload = {
            "Id": item_id,
            "SyncToken": sync_token
        }
        
        if name:
            payload["Name"] = self._validate_item_name(name)
        if item_type:
            payload["Type"] = item_type.value
        if price is not None:
            payload["UnitPrice"] = self._normalize_price(price)
        if income_account:
            payload["IncomeAccountRef"] = {"name": income_account}
        if private_note:
            payload["PrivateNote"] = private_note
        
        # Preservar propiedades adicionales
        if preserve_properties:
            for key, value in preserve_properties.items():
                if key not in payload:
                    payload[key] = value
        
        with self._track_metric("update_item", tags={"operation": "update"}):
            endpoint = f"/v3/company/{company_id}/item"
            response_data = self._make_request("POST", endpoint, json_data=payload)
            
            item_data = response_data.get("Item", {})
            updated_id = item_data.get("Id", item_id)
            
            # Invalidar cache si el nombre cambió
            if name and CACHETOOLS_AVAILABLE and self._item_cache:
                cache_key = f"item_name:{name.lower().strip()}"
                self._item_cache.pop(cache_key, None)
            
            return str(updated_id)


def sync_stripe_product_to_quickbooks(
    stripe_product_id: str,
    nombre_producto: str,
    precio: float | Decimal,
    quickbooks_client: Optional[QuickBooksClient] = None,
    quickbooks_config: Optional[QuickBooksConfig] = None,
    income_account: Optional[str] = None
) -> SyncResult:
    """
    Sincroniza un producto de Stripe con un ítem en QuickBooks (versión mejorada con resultado estructurado).
    Verifica si existe un ítem con ese nombre en QuickBooks.
    Si no existe, crea uno; si existe, actualiza el precio.
    
    Args:
        stripe_product_id: ID del producto en Stripe
        nombre_producto: Nombre del producto
        precio: Precio del producto (float o Decimal)
        quickbooks_client: Cliente de QuickBooks (opcional, se crea uno si no se proporciona)
        quickbooks_config: Configuración de QuickBooks (opcional, se carga de env si no se proporciona)
        income_account: Nombre de la cuenta de ingresos (opcional, usa config si no se proporciona)
    
    Returns:
        SyncResult: Resultado estructurado de la sincronización
    """
    start_time = time.time()
    
    # Validar entrada con Pydantic si está disponible
    try:
        if PYDANTIC_AVAILABLE:
            try:
                input_data = StripeProductInput(
                    stripe_product_id=stripe_product_id,
                    nombre_producto=nombre_producto,
                    precio=Decimal(str(precio))
                )
                precio = input_data.precio
            except ValidationError as e:
                return SyncResult(
                    success=False,
                    action=None,
                    qb_item_id=None,
                    error_message=f"ERROR_VALIDATION: {str(e)}",
                    stripe_product_id=stripe_product_id,
                    nombre_producto=nombre_producto,
                    precio=float(precio) if isinstance(precio, (int, float, Decimal)) else None
                )
        else:
            precio = Decimal(str(precio))
            if precio < 0:
                return SyncResult(
                    success=False,
                    action=None,
                    qb_item_id=None,
                    error_message="ERROR: precio debe ser mayor o igual a cero",
                    stripe_product_id=stripe_product_id,
                    nombre_producto=nombre_producto,
                    precio=float(precio)
                )
    except Exception as e:
        return SyncResult(
            success=False,
            action=None,
            qb_item_id=None,
            error_message=f"ERROR_VALIDATION: {str(e)}",
            stripe_product_id=stripe_product_id,
            nombre_producto=nombre_producto,
            precio=float(precio) if isinstance(precio, (int, float, Decimal)) else None
        )
    
    # Validar parámetros requeridos
    if not stripe_product_id:
        return SyncResult(
            success=False,
            action=None,
            qb_item_id=None,
            error_message="ERROR: stripe_product_id es requerido",
            stripe_product_id=stripe_product_id,
            nombre_producto=nombre_producto
        )
    
    if not nombre_producto or not nombre_producto.strip():
        return SyncResult(
            success=False,
            action=None,
            qb_item_id=None,
            error_message="ERROR: nombre_producto es requerido",
            stripe_product_id=stripe_product_id,
            nombre_producto=nombre_producto
        )
    
    # Inicializar cliente de QuickBooks
    try:
        if quickbooks_client is None:
            if quickbooks_config is None:
                quickbooks_config = QuickBooksClient._load_config_from_env()
            quickbooks_client = QuickBooksClient(quickbooks_config)
        
        # Actualizar income_account si se proporciona
        if income_account:
            quickbooks_client.config.income_account = income_account
        
        # Buscar ítem existente
        logger.info(f"Buscando ítem en QuickBooks: {nombre_producto}")
        item_existente = quickbooks_client.find_item_by_name(nombre_producto)
        
        private_note = f"Stripe Product ID: {stripe_product_id}"
        
        if item_existente:
            # Actualizar ítem existente
            qb_item_id = item_existente.get("Id")
            sync_token = item_existente.get("SyncToken")
            item_type_str = item_existente.get("Type", "Service")
            
            # Convertir string a ItemType enum
            try:
                item_type = ItemType(item_type_str)
            except ValueError:
                item_type = ItemType.SERVICE
            
            # Propiedades a preservar
            preserve_props = {}
            if item_existente.get("TrackQtyOnHand") is not None:
                preserve_props["TrackQtyOnHand"] = item_existente.get("TrackQtyOnHand")
            if item_existente.get("QtyOnHand") is not None:
                preserve_props["QtyOnHand"] = item_existente.get("QtyOnHand")
            
            logger.info(f"Actualizando ítem existente {qb_item_id} con precio {precio}")
            updated_id = quickbooks_client.update_item(
                item_id=qb_item_id,
                sync_token=sync_token,
                name=nombre_producto,
                price=precio,
                item_type=item_type,
                income_account=income_account,
                private_note=private_note,
                preserve_properties=preserve_props if preserve_props else None
            )
            
            logger.info(f"Ítem actualizado exitosamente: {updated_id}")
            duration_ms = (time.time() - start_time) * 1000
            return SyncResult(
                success=True,
                action="actualizado",
                qb_item_id=updated_id,
                stripe_product_id=stripe_product_id,
                nombre_producto=nombre_producto,
                precio=float(precio),
                duration_ms=duration_ms
            )
        else:
            # Crear nuevo ítem
            logger.info(f"Creando nuevo ítem en QuickBooks: {nombre_producto} con precio {precio}")
            qb_item_id = quickbooks_client.create_item(
                name=nombre_producto,
                price=precio,
                item_type=ItemType.SERVICE,
                income_account=income_account,
                private_note=private_note
            )
            
            logger.info(f"Ítem creado exitosamente: {qb_item_id}")
            duration_ms = (time.time() - start_time) * 1000
            return SyncResult(
                success=True,
                action="creado",
                qb_item_id=qb_item_id,
                stripe_product_id=stripe_product_id,
                nombre_producto=nombre_producto,
                precio=float(precio),
                duration_ms=duration_ms
            )
            
    except QuickBooksValidationError as e:
        logger.error(f"Error de validación: {str(e)}")
        return SyncResult(
            success=False,
            action=None,
            qb_item_id=None,
            error_message=f"ERROR_VALIDATION: {str(e)}",
            stripe_product_id=stripe_product_id,
            nombre_producto=nombre_producto,
            precio=float(precio)
        )
    except QuickBooksAuthError as e:
        if STATS_AVAILABLE:
            try:
                Stats().incr("quickbooks.sync.error", tags={"category": "auth_error"})
            except Exception:
                pass
        logger.error(
            f"Error de autenticación: {str(e)}",
            extra={"error_category": "auth_error", "stripe_product_id": stripe_product_id}
        )
        return SyncResult(
            success=False,
            action=None,
            qb_item_id=None,
            error_message=f"ERROR_AUTH: {str(e)}",
            stripe_product_id=stripe_product_id,
            nombre_producto=nombre_producto,
            precio=float(precio)
        )
    except QuickBooksAPIError as e:
        # Categorizar error para métricas
        error_category = "unknown_error"
        if e.status_code == 429:
            error_category = "rate_limit"
        elif e.status_code in (401, 403):
            error_category = "auth_error"
        elif e.status_code == 400:
            error_category = "validation_error"
        elif e.status_code and e.status_code >= 500:
            error_category = "server_error"
        
        # Trackear métrica categorizada
        if STATS_AVAILABLE:
            try:
                Stats().incr("quickbooks.sync.error", tags={"category": error_category, "status_code": str(e.status_code)})
            except Exception:
                pass
        
        logger.error(
            f"Error de API QuickBooks: {str(e)} (status: {e.status_code})",
            extra={"error_category": error_category, "status_code": e.status_code, "stripe_product_id": stripe_product_id}
        )
        return SyncResult(
            success=False,
            action=None,
            qb_item_id=None,
            error_message=f"ERROR_{e.status_code}: {str(e)}",
            stripe_product_id=stripe_product_id,
            nombre_producto=nombre_producto,
            precio=float(precio)
        )
    except QuickBooksError as e:
        duration_ms = (time.time() - start_time) * 1000
        logger.error(
            f"Error de QuickBooks: {str(e)}",
            extra={"error_type": "quickbooks", "stripe_product_id": stripe_product_id}
        )
        return _create_error_result(
            f"ERROR_QUICKBOOKS: {str(e)}",
            stripe_product_id,
            nombre_producto,
            float(precio) if isinstance(precio, (int, float, Decimal)) else None,
            duration_ms
        )
    except Exception as e:
        duration_ms = (time.time() - start_time) * 1000
        logger.exception(
            f"Error inesperado al sincronizar producto: {str(e)}",
            extra={
                "error_type": "unexpected",
                "exception_type": type(e).__name__,
                "stripe_product_id": stripe_product_id
            }
        )
        return _create_error_result(
            f"ERROR_INESPERADO: {str(e)}",
            stripe_product_id,
            nombre_producto,
            float(precio) if isinstance(precio, (int, float, Decimal)) else None,
            duration_ms
        )


def sincronizar_producto_stripe_quickbooks(
    stripe_product_id: str,
    nombre_producto: str,
    precio: float,
    quickbooks_client: Optional[QuickBooksClient] = None,
    quickbooks_config: Optional[QuickBooksConfig] = None,
    income_account: Optional[str] = None
) -> str:
    """
    Sincroniza un producto de Stripe con un ítem en QuickBooks (compatibilidad con versión anterior).
    Esta función usa internamente sync_stripe_product_to_quickbooks y retorna un string.
    
    Args:
        stripe_product_id: ID del producto en Stripe
        nombre_producto: Nombre del producto
        precio: Precio del producto
        quickbooks_client: Cliente de QuickBooks (opcional, se crea uno si no se proporciona)
        quickbooks_config: Configuración de QuickBooks (opcional, se carga de env si no se proporciona)
        income_account: Nombre de la cuenta de ingresos (opcional, usa config si no se proporciona)
    
    Returns:
        str: 'creado {qb_item_id}' o 'actualizado {qb_item_id}', o mensaje de error
    """
    result = sync_stripe_product_to_quickbooks(
        stripe_product_id=stripe_product_id,
        nombre_producto=nombre_producto,
        precio=precio,
        quickbooks_client=quickbooks_client,
        quickbooks_config=quickbooks_config,
        income_account=income_account
    )
    return str(result)


# Función auxiliar para uso en DAGs de Airflow
def sincronizar_producto_stripe_quickbooks_task(**context):
    """
    Wrapper para usar la función en DAGs de Airflow.
    Espera 'stripe_product_id', 'nombre_producto' y 'precio' en los parámetros del contexto.
    """
    params = context.get('params', {})
    stripe_product_id = params.get('stripe_product_id')
    nombre_producto = params.get('nombre_producto')
    precio = params.get('precio')
    
    if not stripe_product_id:
        raise ValueError("stripe_product_id es requerido en los parámetros")
    if not nombre_producto:
        raise ValueError("nombre_producto es requerido en los parámetros")
    if precio is None:
        raise ValueError("precio es requerido en los parámetros")
    
    logger.info(
        f"Iniciando sincronización de producto Stripe",
        extra={
            "stripe_product_id": stripe_product_id,
            "nombre_producto": nombre_producto,
            "precio": precio
        }
    )
    
    resultado = sincronizar_producto_stripe_quickbooks(
        stripe_product_id=stripe_product_id,
        nombre_producto=nombre_producto,
        precio=precio
    )
    
    if resultado.startswith("creado") or resultado.startswith("actualizado"):
        # Extraer ID de QuickBooks del resultado
        parts = resultado.split()
        qb_item_id = parts[1] if len(parts) > 1 else "N/A"
        
        logger.info(
            f"Producto sincronizado exitosamente: {resultado}",
            extra={
                "stripe_product_id": stripe_product_id,
                "qb_item_id": qb_item_id,
                "nombre_producto": nombre_producto,
                "precio": precio,
                "accion": "creado" if resultado.startswith("creado") else "actualizado"
            }
        )
        print(f"✓ Producto sincronizado exitosamente: {resultado}")
        print(f"  - ID Stripe: {stripe_product_id}")
        print(f"  - Nombre: {nombre_producto}")
        print(f"  - Precio: {precio}")
        print(f"  - ID QuickBooks: {qb_item_id}")
    else:
        logger.error(
            f"Error al sincronizar producto: {resultado}",
            extra={
                "stripe_product_id": stripe_product_id,
                "nombre_producto": nombre_producto,
                "precio": precio,
                "error": resultado
            }
        )
        print(f"✗ Error al sincronizar producto: {resultado}")
    
    return resultado


def sync_stripe_products_batch(
    products: List[Dict[str, Any]],
    quickbooks_client: Optional[QuickBooksClient] = None,
    quickbooks_config: Optional[QuickBooksConfig] = None,
    income_account: Optional[str] = None,
    max_workers: int = 5,
    continue_on_error: bool = True,
    batch_delay: float = 0.1
) -> BatchSyncResult:
    """
    Sincroniza múltiples productos de Stripe con QuickBooks en batch.
    
    Args:
        products: Lista de productos. Cada producto debe tener:
            - stripe_product_id: str
            - nombre_producto: str
            - precio: float
        quickbooks_client: Cliente de QuickBooks (opcional)
        quickbooks_config: Configuración de QuickBooks (opcional)
        income_account: Nombre de la cuenta de ingresos (opcional)
        max_workers: Número máximo de workers para procesamiento paralelo
        continue_on_error: Si continuar con otros productos si uno falla
        batch_delay: Delay entre batches en segundos
    
    Returns:
        BatchSyncResult: Resultado agregado de la sincronización batch
    """
    start_time = time.time()
    results: List[SyncResult] = []
    
    # Monitoreo de memoria al inicio
    memory_initial_mb = 0.0
    try:
        if PSUTIL_AVAILABLE:
            import psutil
            process = psutil.Process()
            memory_initial_mb = process.memory_info().rss / (1024 * 1024)
            if STATS_AVAILABLE:
                try:
                    Stats().gauge("quickbooks.batch_sync.initial_memory_mb", memory_initial_mb)
                except Exception:
                    pass
    except Exception:
        pass
    
    # Inicializar cliente si no se proporciona
    if quickbooks_client is None:
        if quickbooks_config is None:
            quickbooks_config = QuickBooksClient._load_config_from_env()
        quickbooks_client = QuickBooksClient(quickbooks_config)
    
    if income_account:
        quickbooks_client.config.income_account = income_account
    
    logger.info(f"Iniciando sincronización batch de {len(products)} productos")
    
    # Procesar productos
    if CONCURRENT_FUTURES_AVAILABLE and max_workers > 1:
        # Procesamiento paralelo con ThreadPoolExecutor
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_product = {
                executor.submit(
                    sync_stripe_product_to_quickbooks,
                    producto.get("stripe_product_id"),
                    producto.get("nombre_producto"),
                    producto.get("precio"),
                    quickbooks_client,
                    None,  # No crear nuevo cliente en cada worker
                    income_account
                ): producto
                for producto in products
            }
            
            for future in as_completed(future_to_product):
                producto = future_to_product[future]
                try:
                    result = future.result()
                    results.append(result)
                    
                    if not result.success and not continue_on_error:
                        logger.error(f"Error en producto {producto.get('stripe_product_id')}, deteniendo batch")
                        break
                        
                    # Pequeño delay para respetar rate limits
                    if batch_delay > 0:
                        time.sleep(batch_delay)
                        
                except Exception as e:
                    logger.exception(f"Error procesando producto {producto.get('stripe_product_id')}: {str(e)}")
                    results.append(SyncResult(
                        success=False,
                        action=None,
                        qb_item_id=None,
                        error_message=f"ERROR_EXCEPTION: {str(e)}",
                        stripe_product_id=producto.get("stripe_product_id"),
                        nombre_producto=producto.get("nombre_producto"),
                        precio=producto.get("precio")
                    ))
                    
                    if not continue_on_error:
                        break
    else:
        # Procesamiento secuencial
        for i, producto in enumerate(products):
            try:
                result = sync_stripe_product_to_quickbooks(
                    stripe_product_id=producto.get("stripe_product_id"),
                    nombre_producto=producto.get("nombre_producto"),
                    precio=producto.get("precio"),
                    quickbooks_client=quickbooks_client,
                    quickbooks_config=None,
                    income_account=income_account
                )
                results.append(result)
                
                if not result.success and not continue_on_error:
                    logger.error(f"Error en producto {producto.get('stripe_product_id')}, deteniendo batch")
                    break
                    
                # Delay entre productos
                if i < len(products) - 1 and batch_delay > 0:
                    time.sleep(batch_delay)
                    
            except Exception as e:
                logger.exception(f"Error procesando producto {producto.get('stripe_product_id')}: {str(e)}")
                results.append(SyncResult(
                    success=False,
                    action=None,
                    qb_item_id=None,
                    error_message=f"ERROR_EXCEPTION: {str(e)}",
                    stripe_product_id=producto.get("stripe_product_id"),
                    nombre_producto=producto.get("nombre_producto"),
                    precio=producto.get("precio")
                ))
                
                if not continue_on_error:
                    break
    
    duration_ms = (time.time() - start_time) * 1000
    successful = sum(1 for r in results if r.success)
    failed = len(results) - successful
    
    batch_result = BatchSyncResult(
        total=len(products),
        successful=successful,
        failed=failed,
        results=results,
        duration_ms=duration_ms
    )
    
    logger.info(
        f"Sincronización batch completada: {successful}/{len(products)} exitosos "
        f"({batch_result.success_rate:.2f}%) en {duration_ms:.2f}ms"
    )
    
    return batch_result
def sincronizar_producto_stripe_quickbooks(
    stripe_product_id: str,
    nombre_producto: str,
    precio: float,
    quickbooks_client: Optional[QuickBooksClient] = None,
    quickbooks_config: Optional[QuickBooksConfig] = None,
    income_account: Optional[str] = None
) -> str:
    """
    Sincroniza un producto de Stripe con un ítem en QuickBooks (compatibilidad con versión anterior).
    Esta función usa internamente sync_stripe_product_to_quickbooks y retorna un string.
    
    Args:
        stripe_product_id: ID del producto en Stripe
        nombre_producto: Nombre del producto
        precio: Precio del producto
        quickbooks_client: Cliente de QuickBooks (opcional, se crea uno si no se proporciona)
        quickbooks_config: Configuración de QuickBooks (opcional, se carga de env si no se proporciona)
        income_account: Nombre de la cuenta de ingresos (opcional, usa config si no se proporciona)
    
    Returns:
        str: 'creado {qb_item_id}' o 'actualizado {qb_item_id}', o mensaje de error
    """
    result = sync_stripe_product_to_quickbooks(
        stripe_product_id=stripe_product_id,
        nombre_producto=nombre_producto,
        precio=precio,
        quickbooks_client=quickbooks_client,
        quickbooks_config=quickbooks_config,
        income_account=income_account
    )
    return str(result)


def _load_task_params_from_context(context: Dict[str, Any]) -> Dict[str, Any]:
    """
    Carga y valida parámetros desde contexto de Airflow. Implementa RORO pattern.
    
    Args:
        context: Contexto de Airflow
        
    Returns:
        Diccionario con parámetros validados
        
    Raises:
        ValueError: Si faltan parámetros requeridos
    """
    params = context.get('params', {})
    
    stripe_product_id = params.get('stripe_product_id')
    nombre_producto = params.get('nombre_producto')
    precio = params.get('precio')
    
    # Guard clauses: validación temprana
    if not stripe_product_id:
        raise ValueError("stripe_product_id es requerido en los parámetros")
    if not nombre_producto:
        raise ValueError("nombre_producto es requerido en los parámetros")
    if precio is None:
        raise ValueError("precio es requerido en los parámetros")
    
    return {
        "stripe_product_id": stripe_product_id,
        "nombre_producto": nombre_producto,
        "precio": precio
    }

def sincronizar_producto_stripe_quickbooks_task(**context):
    """
    Wrapper para usar la función en DAGs de Airflow.
    Espera 'stripe_product_id', 'nombre_producto' y 'precio' en los parámetros del contexto.
    Implementa principios RPA: guard clauses, validación temprana, RORO pattern.
    """
    # Cargar y validar parámetros con función auxiliar
    task_params = _load_task_params_from_context(context)
    
    stripe_product_id = task_params["stripe_product_id"]
    nombre_producto = task_params["nombre_producto"]
    precio = task_params["precio"]
    
    logger.info(
        f"Iniciando sincronización de producto Stripe",
        extra={
            "stripe_product_id": stripe_product_id,
            "nombre_producto": nombre_producto,
            "precio": precio
        }
    )
    
    resultado = sincronizar_producto_stripe_quickbooks(
        stripe_product_id=stripe_product_id,
        nombre_producto=nombre_producto,
        precio=precio
    )
    
    if resultado.startswith("creado") or resultado.startswith("actualizado"):
        # Extraer ID de QuickBooks del resultado
        parts = resultado.split()
        qb_item_id = parts[1] if len(parts) > 1 else "N/A"
        
        logger.info(
            f"Producto sincronizado exitosamente: {resultado}",
            extra={
                "stripe_product_id": stripe_product_id,
                "qb_item_id": qb_item_id,
                "nombre_producto": nombre_producto,
                "precio": precio,
                "accion": "creado" if resultado.startswith("creado") else "actualizado"
            }
        )
        print(f"✓ Producto sincronizado exitosamente: {resultado}")
        print(f"  - ID Stripe: {stripe_product_id}")
        print(f"  - Nombre: {nombre_producto}")
        print(f"  - Precio: {precio}")
        print(f"  - ID QuickBooks: {qb_item_id}")
    else:
        logger.error(
            f"Error al sincronizar producto: {resultado}",
            extra={
                "stripe_product_id": stripe_product_id,
                "nombre_producto": nombre_producto,
                "precio": precio,
                "error": resultado
            }
        )
        print(f"✗ Error al sincronizar producto: {resultado}")
    
    return resultado


def _validate_product_dict(product: Dict[str, Any], index: int) -> None:
    """
    Valida que un diccionario de producto tenga los campos requeridos.
    
    Args:
        product: Diccionario del producto a validar
        index: Índice del producto (para mensajes de error)
        
    Raises:
        QuickBooksValidationError: Si el producto no es válido
    """
    if not isinstance(product, dict):
        raise QuickBooksValidationError(
            f"Producto #{index + 1} debe ser un diccionario, recibido: {type(product).__name__}"
        )
    
    stripe_product_id = product.get("stripe_product_id") or product.get("product_id")
    nombre_producto = product.get("nombre_producto") or product.get("name")
    precio = product.get("precio") or product.get("price")
    
    if not stripe_product_id:
        raise QuickBooksValidationError(
            f"Producto #{index + 1} debe tener 'stripe_product_id'"
        )
    
    if not nombre_producto:
        raise QuickBooksValidationError(
            f"Producto #{index + 1} debe tener 'nombre_producto' o 'name'"
        )
    
    if precio is None:
        raise QuickBooksValidationError(
            f"Producto #{index + 1} debe tener 'precio' o 'price'"
        )
    
    # Guard clause: validar precio numérico y válido
    try:
        precio_float = float(precio)
        if precio_float < MIN_PRICE:
            raise QuickBooksValidationError(
                f"Producto #{index + 1} tiene precio inválido (debe ser >= {MIN_PRICE}): {precio_float}"
            )
    except (ValueError, TypeError) as e:
        raise QuickBooksValidationError(
            f"Producto #{index + 1} tiene precio inválido: {precio}"
        ) from e


def _obtener_producto_stripe(
    stripe_product_id: str,
    stripe_api_key: Optional[str] = None
) -> Optional[Dict[str, Any]]:
    """
    Obtiene información de un producto de Stripe usando la librería oficial.
    
    Args:
        stripe_product_id: ID del producto en Stripe
        stripe_api_key: API key de Stripe (opcional, se usa de env si no se proporciona)
        
    Returns:
        Diccionario con información del producto o None si no se encuentra
        
    Raises:
        QuickBooksError: Si hay error al obtener el producto
    """
    if STRIPE_AVAILABLE:
        try:
            api_key = stripe_api_key or os.environ.get("STRIPE_API_KEY")
            if not api_key:
                logger.warning("STRIPE_API_KEY no configurado, no se puede obtener información de Stripe")
                return None
            
            stripe.api_key = api_key
            product = stripe.Product.retrieve(stripe_product_id)
            
            # Convertir a formato estándar
            return {
                "id": product.id,
                "name": product.name,
                "description": getattr(product, 'description', None),
                "active": product.active,
                "metadata": product.metadata,
                "created": product.created
            }
        except stripe.error.InvalidRequestError as e:
            logger.warning(
                f"Producto Stripe no encontrado: {stripe_product_id}",
                extra={"error": str(e)}
            )
            return None
        except stripe.error.StripeError as e:
            logger.error(
                f"Error de Stripe al obtener producto: {stripe_product_id}",
                extra={"error": str(e), "error_type": type(e).__name__}
            )
            raise QuickBooksError(f"Error de Stripe: {str(e)}") from e
        except Exception as e:
            logger.error(
                f"Error inesperado al obtener producto Stripe: {stripe_product_id}",
                extra={"error": str(e)}
            )
            raise QuickBooksError(f"Error inesperado: {str(e)}") from e
    else:
        logger.debug("Librería de Stripe no disponible, no se puede obtener información del producto")
        return None


def _notify_critical_error(
    error_msg: str,
    details: Optional[Dict[str, Any]] = None,
    level: str = "error"
) -> None:
    """
    Notifica errores críticos (por ejemplo, a Slack).
    
    Args:
        error_msg: Mensaje de error
        details: Detalles adicionales del error
        level: Nivel de severidad (error, warning, critical)
    """
    if NOTIFICATIONS_AVAILABLE:
        try:
            message = f"⚠️ Stripe-QuickBooks Sync Error: {error_msg}"
            if details:
                details_str = ", ".join(f"{k}={v}" for k, v in details.items())
                message += f"\nDetalles: {details_str}"
            notify_slack(message)
        except Exception as e:
            logger.debug(f"No se pudo enviar notificación: {e}")
    
    # También loguear con contexto estructurado
    log_with_context(
        logger,
        logging.ERROR if level == "error" else logging.WARNING,
        error_msg,
        **{"level": level, **(details or {})}
    )


def _normalize_product_dict(product: Dict[str, Any]) -> Dict[str, Any]:
    """
    Normaliza un diccionario de producto a formato estándar.
    Función pura helper.
    
    Args:
        product: Diccionario del producto (puede tener diferentes nombres de campos)
        
    Returns:
        Diccionario normalizado con: stripe_product_id, nombre_producto, precio
    """
    if not isinstance(product, dict):
        return {
            "stripe_product_id": "",
            "nombre_producto": "",
            "precio": 0.0
        }
    
    return {
        "stripe_product_id": product.get("stripe_product_id") or product.get("product_id", ""),
        "nombre_producto": product.get("nombre_producto") or product.get("name", ""),
        "precio": product.get("precio") or product.get("price", 0.0)
    }


def _compute_product_checksum(producto: Dict[str, Any]) -> str:
    """
    Calcula un checksum único para un producto (para idempotencia).
    
    Args:
        producto: Diccionario del producto normalizado
        
    Returns:
        Checksum SHA256 como string hexadecimal
    """
    # Normalizar producto si no está normalizado
    if not all(k in producto for k in ["stripe_product_id", "nombre_producto", "precio"]):
        producto = _normalize_product_dict(producto)
    
    # Crear string único basado en campos clave
    key_fields = (
        str(producto.get("stripe_product_id", "")),
        str(producto.get("nombre_producto", "")),
        str(producto.get("precio", 0.0))
    )
    unique_str = "|".join(key_fields)
    
    # Calcular SHA256 hash
    return hashlib.sha256(unique_str.encode('utf-8')).hexdigest()


def _adaptive_chunk_size(
    total_items: int,
    max_chunks: int = 50,
    base_chunk_size: int = 10
) -> int:
    """
    Calcula un tamaño de chunk adaptativo para batch processing.
    
    Args:
        total_items: Número total de items a procesar
        max_chunks: Número máximo de chunks permitidos
        base_chunk_size: Tamaño base de chunk
        
    Returns:
        Tamaño de chunk calculado
    """
    if total_items <= 0:
        return base_chunk_size
    
    # Calcular chunk size ideal
    ideal_chunk_size = max(base_chunk_size, total_items // max_chunks)
    
    # Asegurar que no sea demasiado grande (evitar memory issues)
    max_safe_chunk = MAX_BATCH_SIZE // 2  # Mitad del máximo para seguridad
    ideal_chunk_size = min(ideal_chunk_size, max_safe_chunk)
    
    return ideal_chunk_size


def _add_retry_jitter(base_delay: float, max_jitter: float = RETRY_JITTER_MAX) -> float:
    """
    Agrega jitter aleatorio a un delay de retry para evitar thundering herd.
    
    Args:
        base_delay: Delay base en segundos
        max_jitter: Jitter máximo a agregar en segundos
        
    Returns:
        Delay con jitter aplicado
    """
    jitter = random.uniform(0, max_jitter)
    return base_delay + jitter


def _create_error_sync_result(producto: Dict[str, Any], error_msg: str) -> SyncResult:
    """
    Crea SyncResult de error desde diccionario de producto. Función pura helper.
    Usa _create_error_result internamente para mantener consistencia.
    
    Args:
        producto: Diccionario del producto (normalizado o no)
        error_msg: Mensaje de error
        
    Returns:
        SyncResult con error
    """
    # Normalizar producto si no está normalizado
    if not all(k in producto for k in ["stripe_product_id", "nombre_producto", "precio"]):
        producto = _normalize_product_dict(producto)
    
    return _create_error_result(
        error_msg,
        producto.get("stripe_product_id"),
        producto.get("nombre_producto"),
        producto.get("precio")
    )


def sync_stripe_products_batch(
    products: List[Dict[str, Any]],
    quickbooks_client: Optional[QuickBooksClient] = None,
    quickbooks_config: Optional[QuickBooksConfig] = None,
    income_account: Optional[str] = None,
    max_workers: int = DEFAULT_BATCH_WORKERS,
    continue_on_error: bool = True,
    batch_delay: float = DEFAULT_BATCH_DELAY
) -> BatchSyncResult:
    """
    Sincroniza múltiples productos de Stripe con QuickBooks en batch.
    
    Args:
        products: Lista de productos. Cada producto debe tener:
            - stripe_product_id: str (o product_id)
            - nombre_producto: str (o name)
            - precio: float (o price)
        quickbooks_client: Cliente de QuickBooks (opcional)
        quickbooks_config: Configuración de QuickBooks (opcional)
        income_account: Nombre de la cuenta de ingresos (opcional)
        max_workers: Número máximo de workers para procesamiento paralelo
        continue_on_error: Si continuar con otros productos si uno falla
        batch_delay: Delay entre batches en segundos
    
    Returns:
        BatchSyncResult: Resultado agregado de la sincronización batch
        
    Raises:
        QuickBooksValidationError: Si la lista de productos es inválida
    """
    # Guard clauses: validación temprana
    if not products:
        raise QuickBooksValidationError("La lista de productos no puede estar vacía")
    
    if not isinstance(products, list):
        raise QuickBooksValidationError(
            f"products debe ser una lista, recibido: {type(products).__name__}"
        )
    
    if max_workers < 1:
        raise QuickBooksValidationError(f"max_workers debe ser >= 1, recibido: {max_workers}")
    
    # Validar y normalizar productos
    normalized_products = []
    for i, product in enumerate(products):
        try:
            _validate_product_dict(product, i)
            normalized_products.append(_normalize_product_dict(product))
        except QuickBooksValidationError as e:
            if not continue_on_error:
                raise
            logger.warning(f"Producto #{i + 1} inválido, será omitido: {str(e)}")
    
    if not normalized_products:
        raise QuickBooksValidationError("No hay productos válidos para procesar")
    
    start_time = time.time()
    results: List[SyncResult] = []
    
    # Monitoreo de memoria al inicio
    memory_initial_mb = 0.0
    try:
        if PSUTIL_AVAILABLE:
            import psutil
            process = psutil.Process()
            memory_initial_mb = process.memory_info().rss / (1024 * 1024)
            if STATS_AVAILABLE:
                try:
                    Stats().gauge("quickbooks.batch_sync.initial_memory_mb", memory_initial_mb)
                except Exception:
                    pass
    except Exception:
        pass
    
    # Inicializar cliente si no se proporciona
    if quickbooks_client is None:
        if quickbooks_config is None:
            quickbooks_config = QuickBooksClient._load_config_from_env()
        quickbooks_client = QuickBooksClient(quickbooks_config)
    
    if income_account:
        quickbooks_client.config.income_account = income_account
    
    # Validar tamaño de batch (evitar memory issues)
    if len(normalized_products) > MAX_BATCH_SIZE:
        logger.warning(
            f"Batch size ({len(normalized_products)}) excede máximo ({MAX_BATCH_SIZE}), "
            f"procesando en chunks adaptativos"
        )
    
    log_with_context(
        logger,
        logging.INFO,
        f"Iniciando sincronización batch de productos",
        total_products=len(products),
        normalized_products=len(normalized_products),
        max_workers=max_workers,
        continue_on_error=continue_on_error,
        batch_size=len(normalized_products),
        memory_initial_mb=memory_initial_mb
    )
    
    # Tracking de progreso
    progress_checkpoint = max(1, len(normalized_products) // 10)  # Log cada 10%
    last_logged_progress = 0
    
    # Procesar productos
    # Guard clause: usar procesamiento paralelo solo si está disponible y hay múltiples productos
    if CONCURRENT_FUTURES_AVAILABLE and max_workers > 1 and len(normalized_products) > 1:
        # Procesamiento paralelo con ThreadPoolExecutor
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_product = {
                executor.submit(
                    sync_stripe_product_to_quickbooks,
                    producto["stripe_product_id"],
                    producto["nombre_producto"],
                    producto["precio"],
                    quickbooks_client,
                    None,  # No crear nuevo cliente en cada worker
                    income_account
                ): producto
                for producto in normalized_products
            }
            
            for future in as_completed(future_to_product):
                producto = future_to_product[future]
                try:
                    result = future.result()
                    results.append(result)
                    
                    # Tracking de progreso
                    processed_count = len(results)
                    if processed_count >= last_logged_progress + progress_checkpoint:
                        progress_pct = (processed_count / len(normalized_products)) * 100.0
                        last_logged_progress = processed_count
                        logger.info(
                            f"Progreso batch: {processed_count}/{len(normalized_products)} ({progress_pct:.1f}%)",
                            extra={"processed": processed_count, "total": len(normalized_products), "progress_pct": progress_pct}
                        )
                    
                    # Limpieza proactiva de memoria cada 50 productos
                    if processed_count % 50 == 0 and PSUTIL_AVAILABLE:
                        try:
                            import psutil
                            process = psutil.Process()
                            memory_mb = process.memory_info().rss / (1024 * 1024)
                            if memory_mb > MEMORY_CLEANUP_THRESHOLD_MB:
                                if CACHETOOLS_AVAILABLE and hasattr(QuickBooksClient, '_item_cache') and QuickBooksClient._item_cache:
                                    QuickBooksClient._item_cache.clear()
                                    logger.debug(f"Cache limpiado por memoria alta ({memory_mb:.2f} MB)")
                        except Exception:
                            pass
                    
                    # Guard clause: detener si hay error y no continuar
                    if not result.success and not continue_on_error:
                        logger.error(
                            f"Error en producto {producto['stripe_product_id']}, deteniendo batch",
                            extra={"producto": producto, "resultado": result.to_dict()}
                        )
                        break
                        
                    # Pequeño delay para respetar rate limits
                    if batch_delay > 0:
                        time.sleep(batch_delay)
                        
                except Exception as e:
                    logger.exception(
                        f"Error procesando producto {producto['stripe_product_id']}: {str(e)}",
                        extra={"producto": producto}
                    )
                    error_result = _create_error_sync_result(
                        producto,
                        f"ERROR_EXCEPTION: {str(e)}"
                    )
                    results.append(error_result)
                    
                    if not continue_on_error:
                        break
    else:
        # Procesamiento secuencial
        for i, producto in enumerate(normalized_products):
            try:
                result = sync_stripe_product_to_quickbooks(
                    stripe_product_id=producto["stripe_product_id"],
                    nombre_producto=producto["nombre_producto"],
                    precio=producto["precio"],
                    quickbooks_client=quickbooks_client,
                    quickbooks_config=None,
                    income_account=income_account
                )
                results.append(result)
                
                # Tracking de progreso
                processed_count = len(results)
                if processed_count >= last_logged_progress + progress_checkpoint:
                    progress_pct = (processed_count / len(normalized_products)) * 100.0
                    last_logged_progress = processed_count
                    logger.info(
                        f"Progreso batch: {processed_count}/{len(normalized_products)} ({progress_pct:.1f}%)",
                        extra={"processed": processed_count, "total": len(normalized_products), "progress_pct": progress_pct}
                    )
                
                # Limpieza proactiva de memoria cada 50 productos
                if processed_count % 50 == 0 and PSUTIL_AVAILABLE:
                    try:
                        import psutil
                        process = psutil.Process()
                        memory_mb = process.memory_info().rss / (1024 * 1024)
                        if memory_mb > MEMORY_CLEANUP_THRESHOLD_MB:
                            if CACHETOOLS_AVAILABLE and hasattr(QuickBooksClient, '_item_cache') and QuickBooksClient._item_cache:
                                QuickBooksClient._item_cache.clear()
                                logger.debug(f"Cache limpiado por memoria alta ({memory_mb:.2f} MB)")
                    except Exception:
                        pass
                
                # Guard clause: detener si hay error y no continuar
                if not result.success and not continue_on_error:
                    logger.error(
                        f"Error en producto {producto['stripe_product_id']}, deteniendo batch",
                        extra={"producto": producto, "resultado": result.to_dict()}
                    )
                    break
                    
                # Delay entre productos
                if i < len(normalized_products) - 1 and batch_delay > 0:
                    time.sleep(batch_delay)
                    
            except Exception as e:
                logger.exception(
                    f"Error procesando producto {producto['stripe_product_id']}: {str(e)}",
                    extra={"producto": producto}
                )
                error_result = _create_error_sync_result(
                    producto,
                    f"ERROR_EXCEPTION: {str(e)}"
                )
                results.append(error_result)
                
                # Guard clause: detener si no continuar en error
                if not continue_on_error:
                    break
    
    duration_ms = (time.time() - start_time) * 1000
    successful = sum(1 for r in results if r.success)
    failed = len(results) - successful
    
    batch_result = BatchSyncResult(
        total=len(normalized_products),
        successful=successful,
        failed=failed,
        results=results,
        duration_ms=duration_ms
    )
    
    # Análisis estadístico mejorado
    durations = [r.duration_ms for r in results if r.duration_ms is not None]
    avg_duration = sum(durations) / len(durations) if durations else 0.0
    error_categories = {}
    for r in results:
        if not r.success and r.error_message:
            error_lower = r.error_message.lower()
            if "auth" in error_lower or "token" in error_lower:
                category = "auth_error"
            elif "validation" in error_lower or "invalid" in error_lower:
                category = "validation_error"
            elif "rate limit" in error_lower or "429" in error_lower:
                category = "rate_limit"
            elif "timeout" in error_lower:
                category = "timeout"
            elif "connection" in error_lower:
                category = "connection_error"
            elif "server" in error_lower or "500" in error_lower or "502" in error_lower or "503" in error_lower:
                category = "server_error"
            else:
                category = "unknown_error"
            error_categories[category] = error_categories.get(category, 0) + 1
    
    success_rate = batch_result.success_rate
    efficiency_score = (success_rate / 100.0) * (1.0 - min(avg_duration / 5000.0, 1.0)) * 100.0 if avg_duration > 0 else success_rate
    efficiency_score = max(0.0, min(100.0, efficiency_score))
    health_score = success_rate
    if error_categories.get("auth_error", 0) > 0 or error_categories.get("validation_error", 0) > 0:
        health_score = max(0.0, health_score - 20.0)
    
    memory_final_mb = 0.0
    try:
        if PSUTIL_AVAILABLE:
            import psutil
            process = psutil.Process()
            memory_final_mb = process.memory_info().rss / (1024 * 1024)
    except Exception:
        pass
    
    logger.info(
        f"Sincronización batch completada: {successful}/{batch_result.total} exitosos "
        f"({success_rate:.2f}%) en {duration_ms:.2f}ms | "
        f"Eficiencia: {efficiency_score:.1f}% | Salud: {health_score:.1f}%",
        extra={
            "total": batch_result.total,
            "successful": successful,
            "failed": failed,
            "success_rate": batch_result.success_rate,
            "duration_ms": duration_ms
        }
    )
    
    # Trackear métrica de batch con guard clauses
    if STATS_AVAILABLE:
        try:
            stats = Stats()
            stats.incr("quickbooks.batch_sync.total", batch_result.total)
            stats.incr("quickbooks.batch_sync.successful", successful)
            stats.incr("quickbooks.batch_sync.failed", failed)
            stats.timing("quickbooks.batch_sync.duration_ms", int(duration_ms))
            stats.gauge("quickbooks.batch_sync.success_rate", success_rate)
            stats.gauge("quickbooks.batch_sync.efficiency_score", efficiency_score)
            stats.gauge("quickbooks.batch_sync.health_score", health_score)
            if memory_final_mb > 0:
                stats.gauge("quickbooks.batch_sync.memory_mb", memory_final_mb)
            if durations:
                stats.gauge("quickbooks.batch_sync.avg_duration_ms", avg_duration)
            # Métricas por categoría de error
            for category, count in error_categories.items():
                stats.incr(f"quickbooks.batch_sync.errors.{category}", count)
        except Exception as e:
            logger.debug(f"No se pudo trackear métricas de batch: {str(e)}")
    
    return batch_result
def obtener_estadisticas_sincronizacion(
    quickbooks_client: Optional[QuickBooksClient] = None
) -> Dict[str, Any]:
    """
    Obtiene estadísticas de sincronización desde QuickBooks.
    
    Args:
        quickbooks_client: Cliente de QuickBooks (opcional)
    
    Returns:
        Dict con estadísticas de sincronización
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    stats = {
        "timestamp": time.time(),
        "total_items": 0,
        "items_activos": 0,
        "items_inactivos": 0,
        "items_por_tipo": {},
        "cache_stats": {},
        "quickbooks_info": {}
    }
    
    try:
        # Obtener conteo de ítems desde QuickBooks
        company_id = quickbooks_client._get_company_id()
        base_url = quickbooks_client.config.base_url or "https://quickbooks.api.intuit.com"
        
        # Query para contar todos los ítems
        query = "SELECT COUNT(*) FROM Item"
        url = f"{base_url}/v3/company/{company_id}/query"
        headers = quickbooks_client._get_headers()
        headers["Content-Type"] = "application/text"
        
        params = {
            "minorversion": quickbooks_client.config.minor_version,
            "query": query
        }
        
        try:
            response = quickbooks_client._session.get(url, headers=headers, params=params, timeout=10)
            if response.status_code == 200:
                data = response.json()
                query_response = data.get("QueryResponse", {})
                count = query_response.get("maxResults", 0)
                stats["total_items"] = count
                
                # Intentar obtener más detalles
                try:
                    detail_query = "SELECT Id, Name, Active, Type FROM Item MAXRESULTS 100"
                    params["query"] = detail_query
                    detail_response = quickbooks_client._session.get(url, headers=headers, params=params, timeout=10)
                    if detail_response.status_code == 200:
                        detail_data = detail_response.json()
                        items = detail_data.get("QueryResponse", {}).get("Item", [])
                        if not isinstance(items, list):
                            items = [items]
                        
                        stats["items_activos"] = sum(1 for item in items if item.get("Active", True))
                        stats["items_inactivos"] = len(items) - stats["items_activos"]
                        
                        # Contar por tipo
                        for item in items:
                            item_type = item.get("Type", "Unknown")
                            stats["items_por_tipo"][item_type] = stats["items_por_tipo"].get(item_type, 0) + 1
                except Exception as e:
                    logger.debug(f"Error obteniendo detalles de ítems: {str(e)}")
        except Exception as e:
            logger.warning(f"Error obteniendo estadísticas de ítems: {str(e)}")
        
        # Estadísticas de cache
        if CACHETOOLS_AVAILABLE and hasattr(quickbooks_client, '_item_cache') and quickbooks_client._item_cache:
            cache = quickbooks_client._item_cache
            stats["cache_stats"] = {
                "size": len(cache),
                "max_size": cache.maxsize if hasattr(cache, 'maxsize') else None,
                "currsize": getattr(cache, 'currsize', len(cache)),
                "hits": getattr(cache, 'hits', 0) if hasattr(cache, 'hits') else None,
                "misses": getattr(cache, 'misses', 0) if hasattr(cache, 'misses') else None
            }
        
        # Información de QuickBooks
        try:
            company_info_url = f"{base_url}/v3/company/{company_id}/companyinfo/{company_id}"
            info_response = quickbooks_client._session.get(company_info_url, headers=headers, timeout=10)
            if info_response.status_code == 200:
                company_data = info_response.json().get("CompanyInfo", {})
                stats["quickbooks_info"] = {
                    "company_name": company_data.get("CompanyName"),
                    "fiscal_year_start": company_data.get("FiscalYearStartMonth"),
                    "country": company_data.get("Country")
                }
        except Exception as e:
            logger.debug(f"Error obteniendo info de compañía: {str(e)}")
            
    except Exception as e:
        logger.error(f"Error obteniendo estadísticas: {str(e)}")
        stats["error"] = str(e)
    
    return stats


def limpiar_cache_items(quickbooks_client: Optional[QuickBooksClient] = None) -> Dict[str, Any]:
    """
    Limpia el cache de ítems de QuickBooks.
    
    Args:
        quickbooks_client: Cliente de QuickBooks (opcional)
    
    Returns:
        Dict con resultado de la limpieza
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    result = {
        "cache_limpiado": False,
        "items_eliminados": 0,
        "timestamp": time.time()
    }
    
    try:
        if CACHETOOLS_AVAILABLE and hasattr(quickbooks_client, '_item_cache') and quickbooks_client._item_cache:
            cache = quickbooks_client._item_cache
            items_eliminados = len(cache)
            cache.clear()
            result["cache_limpiado"] = True
            result["items_eliminados"] = items_eliminados
            logger.info(
                f"Cache limpiado: {items_eliminados} ítems eliminados",
                extra={"items_eliminados": items_eliminados}
            )
        else:
            result["mensaje"] = "Cache no disponible o no inicializado"
    except Exception as e:
        logger.error(f"Error limpiando cache: {str(e)}")
        result["error"] = str(e)
    
    return result


def diagnosticar_sincronizacion(
    stripe_product_id: str,
    quickbooks_client: Optional[QuickBooksClient] = None
) -> Dict[str, Any]:
    """
    Diagnostica problemas potenciales con la sincronización de un producto específico.
    
    Args:
        stripe_product_id: ID del producto en Stripe
        quickbooks_client: Cliente de QuickBooks (opcional)
    
    Returns:
        Dict con diagnóstico detallado
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    diagnostico = {
        "stripe_product_id": stripe_product_id,
        "timestamp": time.time(),
        "stripe": {},
        "quickbooks": {},
        "problemas": [],
        "recomendaciones": []
    }
    
    # Verificar producto en Stripe
    try:
        producto_stripe = _obtener_producto_stripe(stripe_product_id)
        if producto_stripe:
            diagnostico["stripe"] = {
                "encontrado": True,
                "nombre": producto_stripe.get("name"),
                "activo": producto_stripe.get("active", True),
                "descripcion": producto_stripe.get("description")
            }
        else:
            diagnostico["stripe"]["encontrado"] = False
            diagnostico["problemas"].append("Producto no encontrado en Stripe")
    except Exception as e:
        diagnostico["stripe"]["error"] = str(e)
        diagnostico["problemas"].append(f"Error al consultar Stripe: {str(e)}")
    
    # Verificar ítem en QuickBooks
    try:
        # Intentar buscar por nombre si tenemos información de Stripe
        nombre_busqueda = diagnostico["stripe"].get("nombre")
        if nombre_busqueda:
            item_encontrado = quickbooks_client.find_item_by_name(nombre_busqueda)
            if item_encontrado:
                diagnostico["quickbooks"] = {
                    "encontrado": True,
                    "item": {
                        "id": item_encontrado.get("Id"),
                        "name": item_encontrado.get("Name"),
                        "active": item_encontrado.get("Active", True),
                        "type": item_encontrado.get("Type")
                    }
                }
            else:
                diagnostico["quickbooks"]["encontrado"] = False
                diagnostico["recomendaciones"].append("Ítem no encontrado en QuickBooks - sincronización recomendada")
        else:
            diagnostico["quickbooks"]["busqueda_realizada"] = False
            diagnostico["problemas"].append("No se pudo obtener nombre del producto para buscar en QuickBooks")
    except Exception as e:
        diagnostico["quickbooks"]["error"] = str(e)
        diagnostico["problemas"].append(f"Error al consultar QuickBooks: {str(e)}")
    
    # Verificar configuración
    try:
        health = quickbooks_client.health_check()
        if health["status"] != "ok":
            diagnostico["problemas"].append(f"Health check de QuickBooks: {health['status']}")
    except Exception as e:
        diagnostico["problemas"].append(f"Error en health check: {str(e)}")
    
    # Generar recomendaciones basadas en el diagnóstico
    if not diagnostico["problemas"]:
        diagnostico["recomendaciones"].append("Todo parece estar en orden")
    
    return diagnostico


def obtener_resumen_sincronizaciones_recientes(
    limit: int = 50,
    quickbooks_client: Optional[QuickBooksClient] = None
) -> Dict[str, Any]:
    """
    Obtiene un resumen de sincronizaciones recientes basado en el cache y estadísticas.
    
    Args:
        limit: Número máximo de entradas a retornar
        quickbooks_client: Cliente de QuickBooks (opcional)
    
    Returns:
        Dict con resumen de sincronizaciones
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    resumen = {
        "timestamp": time.time(),
        "cache_info": {},
        "estadisticas": obtener_estadisticas_sincronizacion(quickbooks_client),
        "health_status": {}
    }
    
    # Información del cache
    if CACHETOOLS_AVAILABLE and hasattr(quickbooks_client, '_item_cache') and quickbooks_client._item_cache:
        cache = quickbooks_client._item_cache
        resumen["cache_info"] = {
            "size": len(cache),
            "max_size": cache.maxsize if hasattr(cache, 'maxsize') else None,
            "utilization_percent": round((len(cache) / cache.maxsize * 100) if hasattr(cache, 'maxsize') and cache.maxsize > 0 else 0, 2)
        }
    
    # Health status
    try:
        health = quickbooks_client.health_check()
        resumen["health_status"] = {
            "status": health.get("status"),
            "checks_passed": sum(1 for check in health.get("checks", {}).values() if check.get("status") == "ok")
        }
    except Exception as e:
        resumen["health_status"]["error"] = str(e)
    
    return resumen


def validar_configuracion_quickbooks(
    quickbooks_client: Optional[QuickBooksClient] = None
) -> Dict[str, Any]:
    """
    Valida la configuración de QuickBooks y retorna un reporte detallado.
    
    Args:
        quickbooks_client: Cliente de QuickBooks (opcional)
    
    Returns:
        Dict con reporte de validación
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    validacion = {
        "timestamp": time.time(),
        "valida": True,
        "errores": [],
        "advertencias": [],
        "checks": {}
    }
    
    # Validar variables de entorno requeridas
    required_vars = ["QUICKBOOKS_ACCESS_TOKEN", "QUICKBOOKS_REALM_ID"]
    for var in required_vars:
        if not os.environ.get(var):
            validacion["valida"] = False
            validacion["errores"].append(f"Variable de entorno faltante: {var}")
    
    # Validar acceso a QuickBooks
    try:
        health = quickbooks_client.health_check()
        validacion["checks"]["health"] = health
        
        if health.get("status") != "ok":
            validacion["advertencias"].append(f"Health check no está OK: {health.get('status')}")
    except Exception as e:
        validacion["valida"] = False
        validacion["errores"].append(f"Error en health check: {str(e)}")
    
    # Validar cuenta de ingresos
    try:
        income_account = quickbooks_client.config.income_account
        if not income_account:
            validacion["advertencias"].append("QUICKBOOKS_INCOME_ACCOUNT no configurado")
    except Exception as e:
        validacion["advertencias"].append(f"Error verificando cuenta de ingresos: {str(e)}")
    
    # Validar configuración de entorno
    environment = os.environ.get("QUICKBOOKS_ENVIRONMENT", "production")
    if environment not in ["production", "sandbox"]:
        validacion["advertencias"].append(f"QUICKBOOKS_ENVIRONMENT tiene valor inválido: {environment}")
    
    validacion["checks"]["environment"] = environment
    validacion["checks"]["base_url"] = quickbooks_client.config.base_url
    
    return validacion


def buscar_items_duplicados(
    nombre_item: str,
    quickbooks_client: Optional[QuickBooksClient] = None
) -> List[Dict[str, Any]]:
    """
    Busca ítems duplicados en QuickBooks por nombre (búsqueda parcial).
    
    Args:
        nombre_item: Nombre del ítem a buscar
        quickbooks_client: Cliente de QuickBooks (opcional)
    
    Returns:
        Lista de ítems encontrados que coinciden con el nombre
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    try:
        # Buscar ítems que contengan el nombre
        nombre_escaped = nombre_item.replace("'", "''")
        query = f"SELECT * FROM Item WHERE Name LIKE '%{nombre_escaped}%' MAXRESULTS 20"
        
        company_id = quickbooks_client._get_company_id()
        base_url = quickbooks_client.config.base_url or "https://quickbooks.api.intuit.com"
        url = f"{base_url}/v3/company/{company_id}/query"
        
        headers = quickbooks_client._get_headers()
        headers["Content-Type"] = "application/text"
        
        params = {
            "minorversion": quickbooks_client.config.minor_version,
            "query": query
        }
        
        response = quickbooks_client._session.get(url, headers=headers, params=params, timeout=10)
        
        if response.status_code == 200:
            data = response.json()
            query_response = data.get("QueryResponse", {})
            items = query_response.get("Item", [])
            
            if not isinstance(items, list):
                items = [items]
            
            return [
                {
                    "id": item.get("Id"),
                    "name": item.get("Name"),
                    "type": item.get("Type"),
                    "active": item.get("Active", True),
                    "unit_price": item.get("UnitPrice")
                }
                for item in items
            ]
        
        return []
    except Exception as e:
        logger.error(f"Error buscando ítems duplicados: {str(e)}")
        return []


def exportar_items_quickbooks(
    quickbooks_client: Optional[QuickBooksClient] = None,
    formato: Literal["json", "csv"] = "json",
    incluir_inactivos: bool = False,
    max_items: int = 1000
) -> Union[str, Dict[str, Any]]:
    """
    Exporta ítems de QuickBooks a formato JSON o CSV.
    
    Args:
        quickbooks_client: Cliente de QuickBooks (opcional)
        formato: Formato de exportación ("json" o "csv")
        incluir_inactivos: Si incluir ítems inactivos
        max_items: Número máximo de ítems a exportar
    
    Returns:
        String CSV o Dict JSON según el formato
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    try:
        # Obtener ítems
        company_id = quickbooks_client._get_company_id()
        base_url = quickbooks_client.config.base_url or "https://quickbooks.api.intuit.com"
        url = f"{base_url}/v3/company/{company_id}/query"
        
        headers = quickbooks_client._get_headers()
        headers["Content-Type"] = "application/text"
        
        query = f"SELECT * FROM Item MAXRESULTS {max_items}"
        params = {
            "minorversion": quickbooks_client.config.minor_version,
            "query": query
        }
        
        response = quickbooks_client._session.get(url, headers=headers, params=params, timeout=30)
        
        if response.status_code != 200:
            raise QuickBooksAPIError(f"Error obteniendo ítems: {response.status_code}")
        
        data = response.json()
        query_response = data.get("QueryResponse", {})
        items = query_response.get("Item", [])
        
        if not isinstance(items, list):
            items = [items]
        
        # Filtrar inactivos si es necesario
        if not incluir_inactivos:
            items = [item for item in items if item.get("Active", True)]
        
        # Exportar según formato
        if formato == "json":
            return {
                "timestamp": time.time(),
                "total_items": len(items),
                "items": items
            }
        elif formato == "csv":
            import csv
            from io import StringIO
            
            output = StringIO()
            if items:
                fieldnames = ["Id", "Name", "Type", "Active", "UnitPrice", "IncomeAccountRef", "PrivateNote"]
                writer = csv.DictWriter(output, fieldnames=fieldnames, extrasaction='ignore')
                writer.writeheader()
                
                for item in items:
                    row = {
                        "Id": item.get("Id", ""),
                        "Name": item.get("Name", ""),
                        "Type": item.get("Type", ""),
                        "Active": str(item.get("Active", True)),
                        "UnitPrice": str(item.get("UnitPrice", "")),
                        "IncomeAccountRef": str(item.get("IncomeAccountRef", {}).get("name", "")),
                        "PrivateNote": item.get("PrivateNote", "")
                    }
                    writer.writerow(row)
            
            return output.getvalue()
        else:
            raise ValueError(f"Formato no soportado: {formato}")
    
    except Exception as e:
        logger.error(f"Error exportando ítems: {str(e)}")
        raise QuickBooksError(f"Error en exportación: {str(e)}") from e


def reconciliar_stripe_quickbooks(
    productos_stripe: List[Dict[str, Any]],
    quickbooks_client: Optional[QuickBooksClient] = None,
    tolerancia_precio: float = 0.01
) -> Dict[str, Any]:
    """
    Reconciliación avanzada entre productos de Stripe e ítems de QuickBooks.
    
    Args:
        productos_stripe: Lista de productos de Stripe
        quickbooks_client: Cliente de QuickBooks (opcional)
        tolerancia_precio: Tolerancia para comparación de precios
    
    Returns:
        Dict con resultado de la reconciliación
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    reconciliacion = {
        "timestamp": time.time(),
        "total_productos_stripe": len(productos_stripe),
        "items_encontrados": 0,
        "items_no_encontrados": 0,
        "items_con_discrepancias": 0,
        "items_reconciliados": 0,
        "discrepancias_precio": [],
        "discrepancias_nombre": [],
        "detalles_reconciliacion": []
    }
    
    for producto in productos_stripe:
        stripe_id = producto.get("stripe_product_id", "")
        nombre = producto.get("nombre_producto", "")
        precio = producto.get("precio", 0.0)
        
        detalle = {
            "stripe_product_id": stripe_id,
            "nombre_stripe": nombre,
            "precio_stripe": precio,
            "encontrado": False,
            "reconciliado": False,
            "discrepancias": []
        }
        
        try:
            # Buscar ítem en QuickBooks
            item_qb = quickbooks_client.find_item_by_name(nombre)
            
            if item_qb:
                detalle["encontrado"] = True
                reconciliacion["items_encontrados"] += 1
                
                # Verificar precio
                precio_qb = item_qb.get("UnitPrice")
                if precio_qb is not None:
                    precio_qb_float = float(precio_qb) if isinstance(precio_qb, (str, Decimal)) else precio_qb
                    diferencia = abs(float(precio) - precio_qb_float)
                    
                    if diferencia > tolerancia_precio:
                        detalle["discrepancias"].append({
                            "tipo": "precio",
                            "stripe": float(precio),
                            "quickbooks": precio_qb_float,
                            "diferencia": float(precio) - precio_qb_float
                        })
                        reconciliacion["discrepancias_precio"].append({
                            "stripe_product_id": stripe_id,
                            "nombre": nombre,
                            "diferencia": float(precio) - precio_qb_float
                        })
                    else:
                        detalle["reconciliado"] = True
                        reconciliacion["items_reconciliados"] += 1
                
                # Verificar nombre
                nombre_qb = item_qb.get("Name", "")
                if nombre_qb.strip().lower() != nombre.strip().lower():
                    detalle["discrepancias"].append({
                        "tipo": "nombre",
                        "stripe": nombre,
                        "quickbooks": nombre_qb
                    })
                    reconciliacion["discrepancias_nombre"].append({
                        "stripe_product_id": stripe_id,
                        "stripe_nombre": nombre,
                        "qb_nombre": nombre_qb
                    })
                
                if detalle["discrepancias"]:
                    reconciliacion["items_con_discrepancias"] += 1
                
                detalle["qb_item_id"] = item_qb.get("Id")
            else:
                detalle["encontrado"] = False
                reconciliacion["items_no_encontrados"] += 1
            
        except Exception as e:
            logger.error(f"Error reconciliando producto {stripe_id}: {str(e)}")
            detalle["error"] = str(e)
        
        reconciliacion["detalles_reconciliacion"].append(detalle)
    
    # Calcular porcentajes
    if reconciliacion["items_encontrados"] > 0:
        reconciliacion["porcentaje_reconciliacion"] = round(
            (reconciliacion["items_reconciliados"] / reconciliacion["items_encontrados"]) * 100, 2
        )
    
    return reconciliacion


def validar_integridad_datos(
    quickbooks_client: Optional[QuickBooksClient] = None,
    max_items: int = 100
) -> Dict[str, Any]:
    """
    Valida la integridad de los datos en QuickBooks.
    
    Args:
        quickbooks_client: Cliente de QuickBooks (opcional)
        max_items: Número máximo de ítems a validar
    
    Returns:
        Dict con resultado de la validación
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    validacion = {
        "timestamp": time.time(),
        "items_validados": 0,
        "errores_encontrados": 0,
        "advertencias": 0,
        "errores": [],
        "advertencias_list": [],
        "items_por_tipo": {}
    }
    
    try:
        # Obtener ítems
        company_id = quickbooks_client._get_company_id()
        base_url = quickbooks_client.config.base_url or "https://quickbooks.api.intuit.com"
        url = f"{base_url}/v3/company/{company_id}/query"
        
        headers = quickbooks_client._get_headers()
        headers["Content-Type"] = "application/text"
        
        query = f"SELECT * FROM Item MAXRESULTS {max_items}"
        params = {
            "minorversion": quickbooks_client.config.minor_version,
            "query": query
        }
        
        response = quickbooks_client._session.get(url, headers=headers, params=params, timeout=30)
        
        if response.status_code == 200:
            data = response.json()
            query_response = data.get("QueryResponse", {})
            items = query_response.get("Item", [])
            
            if not isinstance(items, list):
                items = [items]
            
            validacion["items_validados"] = len(items)
            
            for item in items:
                item_id = item.get("Id")
                nombre = item.get("Name", "")
                tipo = item.get("Type", "Unknown")
                
                # Contar por tipo
                validacion["items_por_tipo"][tipo] = validacion["items_por_tipo"].get(tipo, 0) + 1
                
                # Validar nombre
                if not nombre or len(nombre.strip()) == 0:
                    validacion["errores_encontrados"] += 1
                    validacion["errores"].append({
                        "item_id": item_id,
                        "campo": "nombre",
                        "problema": "Nombre vacío o nulo"
                    })
                
                # Validar precio
                precio = item.get("UnitPrice")
                if precio is not None:
                    try:
                        precio_float = float(precio) if isinstance(precio, (str, Decimal)) else precio
                        if precio_float < 0:
                            validacion["errores_encontrados"] += 1
                            validacion["errores"].append({
                                "item_id": item_id,
                                "campo": "precio",
                                "problema": "Precio negativo",
                                "valor": precio_float
                            })
                    except (ValueError, TypeError):
                        validacion["advertencias"] += 1
                        validacion["advertencias_list"].append({
                            "item_id": item_id,
                            "campo": "precio",
                            "problema": "Precio no numérico",
                            "valor": precio
                        })
                
                # Validar cuenta de ingresos
                income_account = item.get("IncomeAccountRef", {})
                if not income_account or not income_account.get("name"):
                    validacion["advertencias"] += 1
                    validacion["advertencias_list"].append({
                        "item_id": item_id,
                        "campo": "income_account",
                        "problema": "Cuenta de ingresos no configurada"
                    })
                
                # Validar nombre demasiado largo
                if len(nombre) > MAX_ITEM_NAME_LENGTH:
                    validacion["advertencias"] += 1
                    validacion["advertencias_list"].append({
                        "item_id": item_id,
                        "campo": "nombre",
                        "problema": f"Nombre excede longitud máxima ({len(nombre)} > {MAX_ITEM_NAME_LENGTH})",
                        "valor": nombre[:50] + "..."
                    })
        
    except Exception as e:
        logger.error(f"Error validando integridad: {str(e)}")
        validacion["error"] = str(e)
    
    return validacion


def analizar_tendencias_precios(
    quickbooks_client: Optional[QuickBooksClient] = None,
    max_items: int = 100
) -> Dict[str, Any]:
    """
    Analiza tendencias y estadísticas de precios de ítems en QuickBooks.
    
    Args:
        quickbooks_client: Cliente de QuickBooks (opcional)
        max_items: Número máximo de ítems a analizar
    
    Returns:
        Dict con análisis de precios
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    analisis = {
        "timestamp": time.time(),
        "total_items_analizados": 0,
        "items_con_precio": 0,
        "items_sin_precio": 0,
        "precio_minimo": None,
        "precio_maximo": None,
        "precio_promedio": None,
        "precio_mediana": None,
        "precios_por_tipo": {},
        "distribucion_precios": {}
    }
    
    try:
        # Obtener ítems
        company_id = quickbooks_client._get_company_id()
        base_url = quickbooks_client.config.base_url or "https://quickbooks.api.intuit.com"
        url = f"{base_url}/v3/company/{company_id}/query"
        
        headers = quickbooks_client._get_headers()
        headers["Content-Type"] = "application/text"
        
        query = f"SELECT * FROM Item MAXRESULTS {max_items}"
        params = {
            "minorversion": quickbooks_client.config.minor_version,
            "query": query
        }
        
        response = quickbooks_client._session.get(url, headers=headers, params=params, timeout=30)
        
        if response.status_code == 200:
            data = response.json()
            query_response = data.get("QueryResponse", {})
            items = query_response.get("Item", [])
            
            if not isinstance(items, list):
                items = [items]
            
            analisis["total_items_analizados"] = len(items)
            
            precios = []
            precios_por_tipo = {}
            
            for item in items:
                precio = item.get("UnitPrice")
                tipo = item.get("Type", "Unknown")
                
                if precio is not None:
                    try:
                        precio_float = float(precio) if isinstance(precio, (str, Decimal)) else precio
                        if precio_float >= 0:
                            precios.append(precio_float)
                            analisis["items_con_precio"] += 1
                            
                            # Agrupar por tipo
                            if tipo not in precios_por_tipo:
                                precios_por_tipo[tipo] = []
                            precios_por_tipo[tipo].append(precio_float)
                    except (ValueError, TypeError):
                        pass
                
                if precio is None:
                    analisis["items_sin_precio"] += 1
            
            if precios:
                precios_sorted = sorted(precios)
                analisis["precio_minimo"] = min(precios)
                analisis["precio_maximo"] = max(precios)
                analisis["precio_promedio"] = round(sum(precios) / len(precios), 2)
                
                # Calcular mediana
                n = len(precios_sorted)
                if n % 2 == 0:
                    mediana = (precios_sorted[n//2 - 1] + precios_sorted[n//2]) / 2
                else:
                    mediana = precios_sorted[n//2]
                analisis["precio_mediana"] = round(mediana, 2)
                
                # Estadísticas por tipo
                for tipo, precios_tipo in precios_por_tipo.items():
                    if precios_tipo:
                        analisis["precios_por_tipo"][tipo] = {
                            "cantidad": len(precios_tipo),
                            "minimo": min(precios_tipo),
                            "maximo": max(precios_tipo),
                            "promedio": round(sum(precios_tipo) / len(precios_tipo), 2)
                        }
                
                # Distribución de precios (rangos)
                if analisis["precio_maximo"]:
                    max_precio = analisis["precio_maximo"]
                    rangos = [
                        (0, 10, "$0-$10"),
                        (10, 50, "$10-$50"),
                        (50, 100, "$50-$100"),
                        (100, 500, "$100-$500"),
                        (500, float('inf'), "$500+")
                    ]
                    
                    for min_rango, max_rango, etiqueta in rangos:
                        count = sum(1 for p in precios if min_rango <= p < max_rango)
                        if count > 0:
                            analisis["distribucion_precios"][etiqueta] = count
        
    except Exception as e:
        logger.error(f"Error analizando tendencias: {str(e)}")
        analisis["error"] = str(e)
    
    return analisis


def sincronizar_con_matching_inteligente(
    productos: List[Dict[str, Any]],
    quickbooks_client: Optional[QuickBooksClient] = None,
    umbral_similitud: float = 0.8
) -> Dict[str, Any]:
    """
    Sincroniza productos usando matching inteligente (fuzzy matching) para nombres similares.
    
    Args:
        productos: Lista de productos
        quickbooks_client: Cliente de QuickBooks (opcional)
        umbral_similitud: Umbral de similitud para matching (0.0-1.0)
    
    Returns:
        Dict con resultado de sincronización con matching
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    resultado = {
        "timestamp": time.time(),
        "total_productos": len(productos),
        "productos_sincronizados": 0,
        "productos_con_matching": 0,
        "productos_nuevos": 0,
        "productos_fallidos": 0,
        "detalles": []
    }
    
    # Intentar importar fuzzy matching si está disponible
    try:
        from difflib import SequenceMatcher
        FUZZY_AVAILABLE = True
    except ImportError:
        FUZZY_AVAILABLE = False
        logger.warning("Fuzzy matching no disponible, usando matching exacto")
    
    def calcular_similitud(str1: str, str2: str) -> float:
        """Calcula similitud entre dos strings."""
        if FUZZY_AVAILABLE:
            return SequenceMatcher(None, str1.lower(), str2.lower()).ratio()
        else:
            return 1.0 if str1.lower().strip() == str2.lower().strip() else 0.0
    
    for producto in productos:
        stripe_id = producto.get("stripe_product_id", "")
        nombre = producto.get("nombre_producto", "")
        precio = producto.get("precio", 0.0)
        
        detalle = {
            "stripe_product_id": stripe_id,
            "nombre_producto": nombre,
            "matching_encontrado": False,
            "similitud": 0.0,
            "accion": None
        }
        
        try:
            # Buscar exacto primero
            item_qb = quickbooks_client.find_item_by_name(nombre)
            
            if item_qb:
                # Matching exacto encontrado
                detalle["matching_encontrado"] = True
                detalle["similitud"] = 1.0
                detalle["qb_item_id"] = item_qb.get("Id")
                
                # Verificar si necesita actualización
                precio_qb = item_qb.get("UnitPrice")
                if precio_qb is not None:
                    precio_qb_float = float(precio_qb) if isinstance(precio_qb, (str, Decimal)) else precio_qb
                    if abs(float(precio) - precio_qb_float) > 0.01:
                        # Actualizar precio
                        sync_result = sync_stripe_product_to_quickbooks(
                            stripe_product_id=stripe_id,
                            nombre_producto=nombre,
                            precio=precio,
                            quickbooks_client=quickbooks_client
                        )
                        if sync_result.success:
                            resultado["productos_sincronizados"] += 1
                            detalle["accion"] = "actualizado"
                        else:
                            resultado["productos_fallidos"] += 1
                            detalle["accion"] = "error_actualizacion"
                    else:
                        resultado["productos_sincronizados"] += 1
                        detalle["accion"] = "ya_sincronizado"
            else:
                # Intentar matching inteligente con otros ítems
                # Obtener algunos ítems para comparar
                company_id = quickbooks_client._get_company_id()
                base_url = quickbooks_client.config.base_url or "https://quickbooks.api.intuit.com"
                url = f"{base_url}/v3/company/{company_id}/query"
                
                headers = quickbooks_client._get_headers()
                headers["Content-Type"] = "application/text"
                
                query = f"SELECT Id, Name FROM Item MAXRESULTS 50"
                params = {
                    "minorversion": quickbooks_client.config.minor_version,
                    "query": query
                }
                
                response = quickbooks_client._session.get(url, headers=headers, params=params, timeout=10)
                
                mejor_match = None
                mejor_similitud = 0.0
                
                if response.status_code == 200:
                    data = response.json()
                    query_response = data.get("QueryResponse", {})
                    items = query_response.get("Item", [])
                    
                    if not isinstance(items, list):
                        items = [items]
                    
                    for item in items:
                        nombre_item = item.get("Name", "")
                        similitud = calcular_similitud(nombre, nombre_item)
                        
                        if similitud > mejor_similitud and similitud >= umbral_similitud:
                            mejor_similitud = similitud
                            mejor_match = item
                
                if mejor_match:
                    detalle["matching_encontrado"] = True
                    detalle["similitud"] = mejor_similitud
                    detalle["qb_item_id"] = mejor_match.get("Id")
                    detalle["qb_item_nombre"] = mejor_match.get("Name")
                    resultado["productos_con_matching"] += 1
                    
                    # Actualizar usando el matching encontrado
                    item_completo = quickbooks_client.find_item_by_name(mejor_match.get("Name"))
                    if item_completo:
                        sync_token = item_completo.get("SyncToken", "0")
                        quickbooks_client.update_item(
                            item_id=mejor_match.get("Id"),
                            sync_token=sync_token,
                            price=precio,
                            name=nombre  # Actualizar nombre también
                        )
                        resultado["productos_sincronizados"] += 1
                        detalle["accion"] = "actualizado_con_matching"
                else:
                    # Crear nuevo ítem
                    sync_result = sync_stripe_product_to_quickbooks(
                        stripe_product_id=stripe_id,
                        nombre_producto=nombre,
                        precio=precio,
                        quickbooks_client=quickbooks_client
                    )
                    if sync_result.success:
                        resultado["productos_sincronizados"] += 1
                        resultado["productos_nuevos"] += 1
                        detalle["accion"] = "creado"
                        detalle["qb_item_id"] = sync_result.qb_item_id
                    else:
                        resultado["productos_fallidos"] += 1
                        detalle["accion"] = "error_creacion"
        
        except Exception as e:
            logger.error(f"Error en matching inteligente para {stripe_id}: {str(e)}")
            resultado["productos_fallidos"] += 1
            detalle["accion"] = "error"
            detalle["error"] = str(e)
        
        resultado["detalles"].append(detalle)
    
    return resultado


# Funciones de testing y utilidades avanzadas
def crear_producto_test(
    nombre_producto: str = "Producto Test",
    precio: float = 99.99,
    stripe_product_id: Optional[str] = None,
    quickbooks_client: Optional[QuickBooksClient] = None
) -> SyncResult:
    """
    Crea un producto de prueba para testing.
    
    Args:
        nombre_producto: Nombre del producto de prueba
        precio: Precio del producto
        stripe_product_id: ID de Stripe (si None, se genera uno)
        quickbooks_client: Cliente de QuickBooks (opcional)
    
    Returns:
        SyncResult de la creación
    
    Example:
        >>> result = crear_producto_test("Test Product", 50.0)
        >>> assert result.success
    """
    if stripe_product_id is None:
        stripe_product_id = f"prod_test_{int(time.time())}"
    
    return sync_stripe_product_to_quickbooks(
        stripe_product_id=stripe_product_id,
        nombre_producto=nombre_producto,
        precio=precio,
        quickbooks_client=quickbooks_client
    )


def limpiar_productos_test(
    prefijo: str = "Producto Test",
    quickbooks_client: Optional[QuickBooksClient] = None
) -> Dict[str, Any]:
    """
    Limpia productos de prueba de QuickBooks.
    
    Args:
        prefijo: Prefijo de nombres de productos a limpiar
        quickbooks_client: Cliente de QuickBooks (opcional)
    
    Returns:
        Dict con resultado de la limpieza
    
    Warning:
        Esta función busca y podría eliminar ítems con el prefijo especificado.
        Usar con precaución en producción.
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    resultado = {
        "encontrados": 0,
        "eliminados": 0,
        "errores": [],
        "timestamp": time.time()
    }
    
    try:
        # Buscar ítems con el prefijo
        items_duplicados = buscar_items_duplicados(prefijo, quickbooks_client)
        resultado["encontrados"] = len(items_duplicados)
        
        # Nota: QuickBooks no permite eliminar ítems directamente vía API en algunos casos
        # Esta función documenta los encontrados pero no los elimina por seguridad
        logger.warning(
            f"Encontrados {len(items_duplicados)} ítems con prefijo '{prefijo}'. "
            "Eliminación manual requerida desde QuickBooks UI."
        )
        
        resultado["items_encontrados"] = items_duplicados
        resultado["mensaje"] = "Eliminación manual requerida desde QuickBooks"
        
    except Exception as e:
        resultado["errores"].append(str(e))
        logger.error(f"Error limpiando productos de prueba: {str(e)}")
    
    return resultado


def simular_sincronizacion(
    productos: List[Dict[str, Any]],
    dry_run: bool = True,
    quickbooks_client: Optional[QuickBooksClient] = None
) -> Dict[str, Any]:
    """
    Simula una sincronización sin hacer cambios reales.
    
    Args:
        productos: Lista de productos a simular
        dry_run: Si True, no hace cambios reales
        quickbooks_client: Cliente de QuickBooks (opcional)
    
    Returns:
        Dict con resultado de la simulación
    
    Example:
        >>> productos = [
        ...     {"stripe_product_id": "prod_1", "nombre_producto": "Test", "precio": 99.99}
        ... ]
        >>> resultado = simular_sincronizacion(productos, dry_run=True)
        >>> print(f"Simulados: {resultado['simulados']}")
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    resultado = {
        "simulados": 0,
        "crearian": 0,
        "actualizarian": 0,
        "errores": 0,
        "productos": [],
        "dry_run": dry_run,
        "timestamp": time.time()
    }
    
    for producto in productos:
        try:
            nombre = producto.get("nombre_producto") or producto.get("name", "")
            item_existente = quickbooks_client.find_item_by_name(nombre)
            
            producto_simulado = {
                "stripe_product_id": producto.get("stripe_product_id"),
                "nombre_producto": nombre,
                "precio": producto.get("precio") or producto.get("price"),
                "accion": "actualizaría" if item_existente else "crearía",
                "item_existe": bool(item_existente),
                "qb_item_id_existente": item_existente.get("Id") if item_existente else None
            }
            
            resultado["productos"].append(producto_simulado)
            resultado["simulados"] += 1
            
            if item_existente:
                resultado["actualizarian"] += 1
            else:
                resultado["crearian"] += 1
                
        except Exception as e:
            resultado["errores"] += 1
            logger.warning(f"Error simulando producto {producto.get('stripe_product_id')}: {str(e)}")
    
    return resultado


def exportar_resultados_sincronizacion(
    resultados: Union[SyncResult, BatchSyncResult, List[SyncResult]],
    formato: Literal["json", "csv", "dict"] = "json",
    archivo: Optional[str] = None
) -> Union[str, Dict[str, Any]]:
    """
    Exporta resultados de sincronización en diferentes formatos.
    
    Args:
        resultados: Resultados a exportar
        formato: Formato de exportación ('json', 'csv', 'dict')
        archivo: Ruta del archivo para guardar (opcional)
    
    Returns:
        Resultados en el formato especificado (o string si se guarda a archivo)
    
    Example:
        >>> resultado = sync_stripe_product_to_quickbooks(...)
        >>> exportar_resultados_sincronizacion(resultado, formato="json", archivo="resultado.json")
    """
    import csv
    
    # Convertir a lista si es necesario
    if isinstance(resultados, SyncResult):
        resultados_list = [resultados]
    elif isinstance(resultados, BatchSyncResult):
        resultados_list = resultados.results
    else:
        resultados_list = resultados
    
    # Preparar datos
    datos = [r.to_dict() for r in resultados_list]
    
    if formato == "json":
        output = json.dumps(datos, indent=2, default=str, ensure_ascii=False)
    elif formato == "csv":
        if not datos:
            output = ""
        else:
            fieldnames = datos[0].keys()
            output_lines = []
            writer = csv.DictWriter(output_lines, fieldnames=fieldnames)
            writer.writeheader()
            writer.writerows(datos)
            output = "\n".join(output_lines)
    else:  # dict
        output = datos
    
    # Guardar a archivo si se especifica
    if archivo:
        with open(archivo, 'w', encoding='utf-8') as f:
            if formato == "json":
                f.write(output)
            elif formato == "csv":
                f.write(output)
            else:
                json.dump(output, f, indent=2, default=str, ensure_ascii=False)
        return f"Resultados exportados a {archivo}"
    
    return output


def comparar_productos_stripe_quickbooks(
    stripe_product_id: str,
    quickbooks_item_name: Optional[str] = None,
    quickbooks_client: Optional[QuickBooksClient] = None
) -> Dict[str, Any]:
    """
    Compara un producto de Stripe con su correspondiente ítem en QuickBooks.
    
    Args:
        stripe_product_id: ID del producto en Stripe
        quickbooks_item_name: Nombre del ítem en QuickBooks (opcional)
        quickbooks_client: Cliente de QuickBooks (opcional)
    
    Returns:
        Dict con comparación detallada
    
    Example:
        >>> comparacion = comparar_productos_stripe_quickbooks("prod_123")
        >>> print(f"Coinciden: {comparacion['coinciden']}")
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    comparacion = {
        "stripe_product_id": stripe_product_id,
        "coinciden": False,
        "diferencias": [],
        "stripe": {},
        "quickbooks": {},
        "timestamp": time.time()
    }
    
    try:
        # Obtener producto de Stripe
        producto_stripe = _obtener_producto_stripe(stripe_product_id)
        if producto_stripe:
            comparacion["stripe"] = {
                "nombre": producto_stripe.get("name"),
                "activo": producto_stripe.get("active", True),
                "descripcion": producto_stripe.get("description")
            }
        
        # Buscar ítem en QuickBooks
        nombre_busqueda = quickbooks_item_name or comparacion["stripe"].get("nombre")
        if nombre_busqueda:
            item_qb = quickbooks_client.find_item_by_name(nombre_busqueda)
            if item_qb:
                comparacion["quickbooks"] = {
                    "id": item_qb.get("Id"),
                    "nombre": item_qb.get("Name"),
                    "precio": item_qb.get("UnitPrice"),
                    "activo": item_qb.get("Active", True),
                    "tipo": item_qb.get("Type")
                }
                
                # Comparar
                if producto_stripe:
                    if comparacion["stripe"]["nombre"] != comparacion["quickbooks"]["nombre"]:
                        comparacion["diferencias"].append("nombre")
                    
                    if comparacion["stripe"]["activo"] != comparacion["quickbooks"]["activo"]:
                        comparacion["diferencias"].append("estado_activo")
                
                comparacion["coinciden"] = len(comparacion["diferencias"]) == 0
            else:
                comparacion["diferencias"].append("item_no_encontrado")
        else:
            comparacion["diferencias"].append("nombre_no_disponible")
            
    except Exception as e:
        comparacion["error"] = str(e)
        logger.error(f"Error comparando productos: {str(e)}")
    
    return comparacion


    
    if not isinstance(products, list):
        raise QuickBooksValidationError(
            f"products debe ser una lista, recibido: {type(products).__name__}"
        )
    
    if max_workers < 1:
        raise QuickBooksValidationError(f"max_workers debe ser >= 1, recibido: {max_workers}")
    
    # Validar y normalizar productos
    normalized_products = []
    for i, product in enumerate(products):
        try:
            _validate_product_dict(product, i)
            normalized_products.append(_normalize_product_dict(product))
        except QuickBooksValidationError as e:
            if not continue_on_error:
                raise
            logger.warning(f"Producto #{i + 1} inválido, será omitido: {str(e)}")
    
    if not normalized_products:
        raise QuickBooksValidationError("No hay productos válidos para procesar")
    
    start_time = time.time()
    results: List[SyncResult] = []
    
    # Monitoreo de memoria al inicio
    memory_initial_mb = 0.0
    try:
        if PSUTIL_AVAILABLE:
            import psutil
            process = psutil.Process()
            memory_initial_mb = process.memory_info().rss / (1024 * 1024)
            if STATS_AVAILABLE:
                try:
                    Stats().gauge("quickbooks.batch_sync.initial_memory_mb", memory_initial_mb)
                except Exception:
                    pass
    except Exception:
        pass
    
    # Inicializar cliente si no se proporciona
    if quickbooks_client is None:
        if quickbooks_config is None:
            quickbooks_config = QuickBooksClient._load_config_from_env()
        quickbooks_client = QuickBooksClient(quickbooks_config)
    
    if income_account:
        quickbooks_client.config.income_account = income_account
    
    # Validar tamaño de batch (evitar memory issues)
    if len(normalized_products) > MAX_BATCH_SIZE:
        logger.warning(
            f"Batch size ({len(normalized_products)}) excede máximo ({MAX_BATCH_SIZE}), "
            f"procesando en chunks adaptativos"
        )
    
                        log_with_context(
        logger,
        logging.INFO,
        f"Iniciando sincronización batch de productos",
        total_products=len(products),
        normalized_products=len(normalized_products),
        max_workers=max_workers,
        continue_on_error=continue_on_error,
        batch_size=len(normalized_products),
        memory_initial_mb=memory_initial_mb
    )
    
    # Tracking de progreso
    progress_checkpoint = max(1, len(normalized_products) // 10)  # Log cada 10%
    last_logged_progress = 0
    
    # Procesar productos
    # Guard clause: usar procesamiento paralelo solo si está disponible y hay múltiples productos
    if CONCURRENT_FUTURES_AVAILABLE and max_workers > 1 and len(normalized_products) > 1:
        # Procesamiento paralelo con ThreadPoolExecutor
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_product = {
                executor.submit(
                    sync_stripe_product_to_quickbooks,
                    producto["stripe_product_id"],
                    producto["nombre_producto"],
                    producto["precio"],
                    quickbooks_client,
                    None,  # No crear nuevo cliente en cada worker
                    income_account
                ): producto
                for producto in normalized_products
            }
            
            for future in as_completed(future_to_product):
                producto = future_to_product[future]
                try:
                    result = future.result()
                    results.append(result)
                    
                    # Tracking de progreso
                    processed_count = len(results)
                    if processed_count >= last_logged_progress + progress_checkpoint:
                        progress_pct = (processed_count / len(normalized_products)) * 100.0
                        last_logged_progress = processed_count
                        logger.info(
                            f"Progreso batch: {processed_count}/{len(normalized_products)} ({progress_pct:.1f}%)",
                            extra={"processed": processed_count, "total": len(normalized_products), "progress_pct": progress_pct}
                        )
                    
                    # Limpieza proactiva de memoria cada 50 productos
                    if processed_count % 50 == 0 and PSUTIL_AVAILABLE:
                        try:
                            import psutil
                            process = psutil.Process()
                            memory_mb = process.memory_info().rss / (1024 * 1024)
                            if memory_mb > MEMORY_CLEANUP_THRESHOLD_MB:
                                if CACHETOOLS_AVAILABLE and hasattr(QuickBooksClient, '_item_cache') and QuickBooksClient._item_cache:
                                    QuickBooksClient._item_cache.clear()
                                    logger.debug(f"Cache limpiado por memoria alta ({memory_mb:.2f} MB)")
                        except Exception:
                            pass
                    
                    # Guard clause: detener si hay error y no continuar
                    if not result.success and not continue_on_error:
                        logger.error(
                            f"Error en producto {producto['stripe_product_id']}, deteniendo batch",
                            extra={"producto": producto, "resultado": result.to_dict()}
                        )
                        break
                        
                    # Pequeño delay para respetar rate limits
                    if batch_delay > 0:
                        time.sleep(batch_delay)
                        
                except Exception as e:
                    logger.exception(
                        f"Error procesando producto {producto['stripe_product_id']}: {str(e)}",
                        extra={"producto": producto}
                    )
                    error_result = _create_error_sync_result(
                        producto,
                        f"ERROR_EXCEPTION: {str(e)}"
                    )
                    results.append(error_result)
                    
                    if not continue_on_error:
                        break
    else:
        # Procesamiento secuencial
        for i, producto in enumerate(normalized_products):
            try:
                result = sync_stripe_product_to_quickbooks(
                    stripe_product_id=producto["stripe_product_id"],
                    nombre_producto=producto["nombre_producto"],
                    precio=producto["precio"],
                    quickbooks_client=quickbooks_client,
                    quickbooks_config=None,
                    income_account=income_account
                )
                results.append(result)
                
                # Tracking de progreso
                processed_count = len(results)
                if processed_count >= last_logged_progress + progress_checkpoint:
                    progress_pct = (processed_count / len(normalized_products)) * 100.0
                    last_logged_progress = processed_count
                    logger.info(
                        f"Progreso batch: {processed_count}/{len(normalized_products)} ({progress_pct:.1f}%)",
                        extra={"processed": processed_count, "total": len(normalized_products), "progress_pct": progress_pct}
                    )
                
                # Limpieza proactiva de memoria cada 50 productos
                if processed_count % 50 == 0 and PSUTIL_AVAILABLE:
                    try:
                        import psutil
                        process = psutil.Process()
                        memory_mb = process.memory_info().rss / (1024 * 1024)
                        if memory_mb > MEMORY_CLEANUP_THRESHOLD_MB:
                            if CACHETOOLS_AVAILABLE and hasattr(QuickBooksClient, '_item_cache') and QuickBooksClient._item_cache:
                                QuickBooksClient._item_cache.clear()
                                logger.debug(f"Cache limpiado por memoria alta ({memory_mb:.2f} MB)")
                    except Exception:
                        pass
                
                # Guard clause: detener si hay error y no continuar
                if not result.success and not continue_on_error:
                    logger.error(
                        f"Error en producto {producto['stripe_product_id']}, deteniendo batch",
                        extra={"producto": producto, "resultado": result.to_dict()}
                    )
                    break
                    
                # Delay entre productos
                if i < len(normalized_products) - 1 and batch_delay > 0:
                    time.sleep(batch_delay)
                    
            except Exception as e:
                logger.exception(
                    f"Error procesando producto {producto['stripe_product_id']}: {str(e)}",
                    extra={"producto": producto}
                )
                error_result = _create_error_sync_result(
                    producto,
                    f"ERROR_EXCEPTION: {str(e)}"
                )
                results.append(error_result)
                
                # Guard clause: detener si no continuar en error
                if not continue_on_error:
                    break
    
    duration_ms = (time.time() - start_time) * 1000
    successful = sum(1 for r in results if r.success)
    failed = len(results) - successful
    
    batch_result = BatchSyncResult(
                        total=len(normalized_products),
        successful=successful,
        failed=failed,
        results=results,
        duration_ms=duration_ms
    )
    
    # Análisis estadístico mejorado
    durations = [r.duration_ms for r in results if r.duration_ms is not None]
    avg_duration = sum(durations) / len(durations) if durations else 0.0
    error_categories = {}
    for r in results:
        if not r.success and r.error_message:
            error_lower = r.error_message.lower()
            if "auth" in error_lower or "token" in error_lower:
                category = "auth_error"
            elif "validation" in error_lower or "invalid" in error_lower:
                category = "validation_error"
            elif "rate limit" in error_lower or "429" in error_lower:
                category = "rate_limit"
            elif "timeout" in error_lower:
                category = "timeout"
            elif "connection" in error_lower:
                category = "connection_error"
            elif "server" in error_lower or "500" in error_lower or "502" in error_lower or "503" in error_lower:
                category = "server_error"
            else:
                category = "unknown_error"
            error_categories[category] = error_categories.get(category, 0) + 1
    
    success_rate = batch_result.success_rate
    efficiency_score = (success_rate / 100.0) * (1.0 - min(avg_duration / 5000.0, 1.0)) * 100.0 if avg_duration > 0 else success_rate
    efficiency_score = max(0.0, min(100.0, efficiency_score))
    health_score = success_rate
    if error_categories.get("auth_error", 0) > 0 or error_categories.get("validation_error", 0) > 0:
        health_score = max(0.0, health_score - 20.0)
    
    memory_final_mb = 0.0
    try:
        if PSUTIL_AVAILABLE:
            import psutil
            process = psutil.Process()
            memory_final_mb = process.memory_info().rss / (1024 * 1024)
    except Exception:
        pass
    
    logger.info(
        f"Sincronización batch completada: {successful}/{batch_result.total} exitosos "
        f"({success_rate:.2f}%) en {duration_ms:.2f}ms | "
        f"Eficiencia: {efficiency_score:.1f}% | Salud: {health_score:.1f}%",
        extra={
            "total": batch_result.total,
            "successful": successful,
            "failed": failed,
            "success_rate": batch_result.success_rate,
            "duration_ms": duration_ms
        }
    )
    
    # Trackear métrica de batch con guard clauses
    if STATS_AVAILABLE:
        try:
            stats = Stats()
            stats.incr("quickbooks.batch_sync.total", batch_result.total)
            stats.incr("quickbooks.batch_sync.successful", successful)
            stats.incr("quickbooks.batch_sync.failed", failed)
            stats.timing("quickbooks.batch_sync.duration_ms", int(duration_ms))
            stats.gauge("quickbooks.batch_sync.success_rate", success_rate)
            stats.gauge("quickbooks.batch_sync.efficiency_score", efficiency_score)
            stats.gauge("quickbooks.batch_sync.health_score", health_score)
            if memory_final_mb > 0:
                stats.gauge("quickbooks.batch_sync.memory_mb", memory_final_mb)
            if durations:
                stats.gauge("quickbooks.batch_sync.avg_duration_ms", avg_duration)
            # Métricas por categoría de error
            for category, count in error_categories.items():
                stats.incr(f"quickbooks.batch_sync.errors.{category}", count)
        except Exception as e:
            logger.debug(f"No se pudo trackear métricas de batch: {str(e)}")
    
    return batch_result
def obtener_estadisticas_sincronizacion(
    quickbooks_client: Optional[QuickBooksClient] = None
) -> Dict[str, Any]:
    """
    Obtiene estadísticas de sincronización desde QuickBooks.
    
    Args:
        quickbooks_client: Cliente de QuickBooks (opcional)
    
    Returns:
        Dict con estadísticas de sincronización
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    stats = {
        "timestamp": time.time(),
        "total_items": 0,
        "items_activos": 0,
        "items_inactivos": 0,
        "items_por_tipo": {},
        "cache_stats": {},
        "quickbooks_info": {}
    }
    
    try:
        # Obtener conteo de ítems desde QuickBooks
        company_id = quickbooks_client._get_company_id()
        base_url = quickbooks_client.config.base_url or "https://quickbooks.api.intuit.com"
        
        # Query para contar todos los ítems
        query = "SELECT COUNT(*) FROM Item"
        url = f"{base_url}/v3/company/{company_id}/query"
        headers = quickbooks_client._get_headers()
        headers["Content-Type"] = "application/text"
        
        params = {
            "minorversion": quickbooks_client.config.minor_version,
            "query": query
        }
        
        try:
            response = quickbooks_client._session.get(url, headers=headers, params=params, timeout=10)
            if response.status_code == 200:
                data = response.json()
                query_response = data.get("QueryResponse", {})
                count = query_response.get("maxResults", 0)
                stats["total_items"] = count
                
                # Intentar obtener más detalles
                try:
                    detail_query = "SELECT Id, Name, Active, Type FROM Item MAXRESULTS 100"
                    params["query"] = detail_query
                    detail_response = quickbooks_client._session.get(url, headers=headers, params=params, timeout=10)
                    if detail_response.status_code == 200:
                        detail_data = detail_response.json()
                        items = detail_data.get("QueryResponse", {}).get("Item", [])
                        if not isinstance(items, list):
                            items = [items]
                        
                        stats["items_activos"] = sum(1 for item in items if item.get("Active", True))
                        stats["items_inactivos"] = len(items) - stats["items_activos"]
                        
                        # Contar por tipo
                        for item in items:
                            item_type = item.get("Type", "Unknown")
                            stats["items_por_tipo"][item_type] = stats["items_por_tipo"].get(item_type, 0) + 1
                except Exception as e:
                    logger.debug(f"Error obteniendo detalles de ítems: {str(e)}")
        except Exception as e:
            logger.warning(f"Error obteniendo estadísticas de ítems: {str(e)}")
        
        # Estadísticas de cache
        if CACHETOOLS_AVAILABLE and hasattr(quickbooks_client, '_item_cache') and quickbooks_client._item_cache:
            cache = quickbooks_client._item_cache
            stats["cache_stats"] = {
                "size": len(cache),
                "max_size": cache.maxsize if hasattr(cache, 'maxsize') else None,
                "currsize": getattr(cache, 'currsize', len(cache)),
                "hits": getattr(cache, 'hits', 0) if hasattr(cache, 'hits') else None,
                "misses": getattr(cache, 'misses', 0) if hasattr(cache, 'misses') else None
            }
        
        # Información de QuickBooks
        try:
            company_info_url = f"{base_url}/v3/company/{company_id}/companyinfo/{company_id}"
            info_response = quickbooks_client._session.get(company_info_url, headers=headers, timeout=10)
            if info_response.status_code == 200:
                company_data = info_response.json().get("CompanyInfo", {})
                stats["quickbooks_info"] = {
                    "company_name": company_data.get("CompanyName"),
                    "fiscal_year_start": company_data.get("FiscalYearStartMonth"),
                    "country": company_data.get("Country")
                }
        except Exception as e:
            logger.debug(f"Error obteniendo info de compañía: {str(e)}")
            
    except Exception as e:
        logger.error(f"Error obteniendo estadísticas: {str(e)}")
        stats["error"] = str(e)
    
    return stats


def limpiar_cache_items(quickbooks_client: Optional[QuickBooksClient] = None) -> Dict[str, Any]:
    """
    Limpia el cache de ítems de QuickBooks.
    
    Args:
        quickbooks_client: Cliente de QuickBooks (opcional)
    
    Returns:
        Dict con resultado de la limpieza
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    result = {
        "cache_limpiado": False,
        "items_eliminados": 0,
        "timestamp": time.time()
    }
    
    try:
        if CACHETOOLS_AVAILABLE and hasattr(quickbooks_client, '_item_cache') and quickbooks_client._item_cache:
            cache = quickbooks_client._item_cache
            items_eliminados = len(cache)
            cache.clear()
            result["cache_limpiado"] = True
            result["items_eliminados"] = items_eliminados
            logger.info(
                f"Cache limpiado: {items_eliminados} ítems eliminados",
                extra={"items_eliminados": items_eliminados}
            )
        else:
            result["mensaje"] = "Cache no disponible o no inicializado"
    except Exception as e:
        logger.error(f"Error limpiando cache: {str(e)}")
        result["error"] = str(e)
    
    return result


def diagnosticar_sincronizacion(
    stripe_product_id: str,
    quickbooks_client: Optional[QuickBooksClient] = None
) -> Dict[str, Any]:
    """
    Diagnostica problemas potenciales con la sincronización de un producto específico.
    
    Args:
        stripe_product_id: ID del producto en Stripe
        quickbooks_client: Cliente de QuickBooks (opcional)
    
    Returns:
        Dict con diagnóstico detallado
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    diagnostico = {
        "stripe_product_id": stripe_product_id,
        "timestamp": time.time(),
        "stripe": {},
        "quickbooks": {},
        "problemas": [],
        "recomendaciones": []
    }
    
    # Verificar producto en Stripe
    try:
        producto_stripe = _obtener_producto_stripe(stripe_product_id)
        if producto_stripe:
            diagnostico["stripe"] = {
                "encontrado": True,
                "nombre": producto_stripe.get("name"),
                "activo": producto_stripe.get("active", True),
                "descripcion": producto_stripe.get("description")
            }
        else:
            diagnostico["stripe"]["encontrado"] = False
            diagnostico["problemas"].append("Producto no encontrado en Stripe")
    except Exception as e:
        diagnostico["stripe"]["error"] = str(e)
        diagnostico["problemas"].append(f"Error al consultar Stripe: {str(e)}")
    
    # Verificar ítem en QuickBooks
    try:
        # Intentar buscar por nombre si tenemos información de Stripe
        nombre_busqueda = diagnostico["stripe"].get("nombre")
        if nombre_busqueda:
            item_encontrado = quickbooks_client.find_item_by_name(nombre_busqueda)
            if item_encontrado:
                diagnostico["quickbooks"] = {
                    "encontrado": True,
                    "item": {
                        "id": item_encontrado.get("Id"),
                        "name": item_encontrado.get("Name"),
                        "active": item_encontrado.get("Active", True),
                        "type": item_encontrado.get("Type")
                    }
                }
            else:
                diagnostico["quickbooks"]["encontrado"] = False
                diagnostico["recomendaciones"].append("Ítem no encontrado en QuickBooks - sincronización recomendada")
        else:
            diagnostico["quickbooks"]["busqueda_realizada"] = False
            diagnostico["problemas"].append("No se pudo obtener nombre del producto para buscar en QuickBooks")
    except Exception as e:
        diagnostico["quickbooks"]["error"] = str(e)
        diagnostico["problemas"].append(f"Error al consultar QuickBooks: {str(e)}")
    
    # Verificar configuración
    try:
        health = quickbooks_client.health_check()
        if health["status"] != "ok":
            diagnostico["problemas"].append(f"Health check de QuickBooks: {health['status']}")
    except Exception as e:
        diagnostico["problemas"].append(f"Error en health check: {str(e)}")
    
    # Generar recomendaciones basadas en el diagnóstico
    if not diagnostico["problemas"]:
        diagnostico["recomendaciones"].append("Todo parece estar en orden")
    
    return diagnostico


def obtener_resumen_sincronizaciones_recientes(
    limit: int = 50,
    quickbooks_client: Optional[QuickBooksClient] = None
) -> Dict[str, Any]:
    """
    Obtiene un resumen de sincronizaciones recientes basado en el cache y estadísticas.
    
    Args:
        limit: Número máximo de entradas a retornar
        quickbooks_client: Cliente de QuickBooks (opcional)
    
    Returns:
        Dict con resumen de sincronizaciones
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    resumen = {
        "timestamp": time.time(),
        "cache_info": {},
        "estadisticas": obtener_estadisticas_sincronizacion(quickbooks_client),
        "health_status": {}
    }
    
    # Información del cache
    if CACHETOOLS_AVAILABLE and hasattr(quickbooks_client, '_item_cache') and quickbooks_client._item_cache:
        cache = quickbooks_client._item_cache
        resumen["cache_info"] = {
            "size": len(cache),
            "max_size": cache.maxsize if hasattr(cache, 'maxsize') else None,
def validar_configuracion_quickbooks(
    quickbooks_client: Optional[QuickBooksClient] = None
) -> Dict[str, Any]:
    """
    Valida la configuración de QuickBooks y retorna un reporte detallado.
    
    Args:
        quickbooks_client: Cliente de QuickBooks (opcional)
    
    Returns:
        Dict con reporte de validación
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    validacion = {
        "timestamp": time.time(),
        "valida": True,
        "errores": [],
        "advertencias": [],
        "checks": {}
    }
    
    # Validar variables de entorno requeridas
    required_vars = ["QUICKBOOKS_ACCESS_TOKEN", "QUICKBOOKS_REALM_ID"]
    for var in required_vars:
        if not os.environ.get(var):
            validacion["valida"] = False
            validacion["errores"].append(f"Variable de entorno faltante: {var}")
    
    # Validar acceso a QuickBooks
    try:
        health = quickbooks_client.health_check()
        validacion["checks"]["health"] = health
        
        if health.get("status") != "ok":
            validacion["advertencias"].append(f"Health check no está OK: {health.get('status')}")
    except Exception as e:
        validacion["valida"] = False
        validacion["errores"].append(f"Error en health check: {str(e)}")
    
    # Validar cuenta de ingresos
    try:
        income_account = quickbooks_client.config.income_account
        if not income_account:
            validacion["advertencias"].append("QUICKBOOKS_INCOME_ACCOUNT no configurado")
    except Exception as e:
        validacion["advertencias"].append(f"Error verificando cuenta de ingresos: {str(e)}")
    
    # Validar configuración de entorno
    environment = os.environ.get("QUICKBOOKS_ENVIRONMENT", "production")
    if environment not in ["production", "sandbox"]:
        validacion["advertencias"].append(f"QUICKBOOKS_ENVIRONMENT tiene valor inválido: {environment}")
    
    validacion["checks"]["environment"] = environment
    validacion["checks"]["base_url"] = quickbooks_client.config.base_url
    
    return validacion


def buscar_items_duplicados(
    nombre_item: str,
    quickbooks_client: Optional[QuickBooksClient] = None
) -> List[Dict[str, Any]]:
    """
    Busca ítems duplicados en QuickBooks por nombre (búsqueda parcial).
    
    Args:
        nombre_item: Nombre del ítem a buscar
        quickbooks_client: Cliente de QuickBooks (opcional)
    
    Returns:
        Lista de ítems encontrados que coinciden con el nombre
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    try:
        # Buscar ítems que contengan el nombre
        nombre_escaped = nombre_item.replace("'", "''")
        query = f"SELECT * FROM Item WHERE Name LIKE '%{nombre_escaped}%' MAXRESULTS 20"
        
        company_id = quickbooks_client._get_company_id()
        base_url = quickbooks_client.config.base_url or "https://quickbooks.api.intuit.com"
        url = f"{base_url}/v3/company/{company_id}/query"
        
        headers = quickbooks_client._get_headers()
        headers["Content-Type"] = "application/text"
def exportar_items_quickbooks(
    quickbooks_client: Optional[QuickBooksClient] = None,
    formato: Literal["json", "csv"] = "json",
    incluir_inactivos: bool = False,
    max_items: int = 1000
) -> Union[str, Dict[str, Any]]:
def reconciliar_stripe_quickbooks(
    productos_stripe: List[Dict[str, Any]],
    quickbooks_client: Optional[QuickBooksClient] = None,
    tolerancia_precio: float = 0.01
) -> Dict[str, Any]:
    """
    Reconciliación avanzada entre productos de Stripe e ítems de QuickBooks.
    
    Args:
        productos_stripe: Lista de productos de Stripe
        quickbooks_client: Cliente de QuickBooks (opcional)
        tolerancia_precio: Tolerancia para comparación de precios
    
    Returns:
        Dict con resultado de la reconciliación
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    reconciliacion = {
        "timestamp": time.time(),
        "total_productos_stripe": len(productos_stripe),
        "items_encontrados": 0,
        "items_no_encontrados": 0,
        "items_con_discrepancias": 0,
        "items_reconciliados": 0,
        "discrepancias_precio": [],
        "discrepancias_nombre": [],
        "detalles_reconciliacion": []
    }
    
    for producto in productos_stripe:
        stripe_id = producto.get("stripe_product_id", "")
        nombre = producto.get("nombre_producto", "")
        precio = producto.get("precio", 0.0)
        
        detalle = {
            "stripe_product_id": stripe_id,
            "nombre_stripe": nombre,
            "precio_stripe": precio,
            "encontrado": False,
            "reconciliado": False,
            "discrepancias": []
        }
        
        try:
            # Buscar ítem en QuickBooks
            item_qb = quickbooks_client.find_item_by_name(nombre)
            
            if item_qb:
                detalle["encontrado"] = True
                reconciliacion["items_encontrados"] += 1
                
                # Verificar precio
                precio_qb = item_qb.get("UnitPrice")
                if precio_qb is not None:
                    precio_qb_float = float(precio_qb) if isinstance(precio_qb, (str, Decimal)) else precio_qb
                    diferencia = abs(float(precio) - precio_qb_float)
                    
                    if diferencia > tolerancia_precio:
                        detalle["discrepancias"].append({
                            "tipo": "precio",
                            "stripe": float(precio),
                            "quickbooks": precio_qb_float,
                            "diferencia": float(precio) - precio_qb_float
                        })
                        reconciliacion["discrepancias_precio"].append({
                            "stripe_product_id": stripe_id,
                            "nombre": nombre,
                            "diferencia": float(precio) - precio_qb_float
                        })
                    else:
                        detalle["reconciliado"] = True
                        reconciliacion["items_reconciliados"] += 1
                
                # Verificar nombre
                nombre_qb = item_qb.get("Name", "")
                if nombre_qb.strip().lower() != nombre.strip().lower():
                    detalle["discrepancias"].append({
                        "tipo": "nombre",
                        "stripe": nombre,
                        "quickbooks": nombre_qb
                    })
                    reconciliacion["discrepancias_nombre"].append({
                        "stripe_product_id": stripe_id,
                        "stripe_nombre": nombre,
                        "qb_nombre": nombre_qb
                    })
                
                if detalle["discrepancias"]:
                    reconciliacion["items_con_discrepancias"] += 1
                
                detalle["qb_item_id"] = item_qb.get("Id")
            else:
                detalle["encontrado"] = False
                reconciliacion["items_no_encontrados"] += 1
            
        except Exception as e:
            logger.error(f"Error reconciliando producto {stripe_id}: {str(e)}")
            detalle["error"] = str(e)
        
        reconciliacion["detalles_reconciliacion"].append(detalle)
    
    # Calcular porcentajes
    if reconciliacion["items_encontrados"] > 0:
        reconciliacion["porcentaje_reconciliacion"] = round(
            (reconciliacion["items_reconciliados"] / reconciliacion["items_encontrados"]) * 100, 2
        )
    
    return reconciliacion


def validar_integridad_datos(
    quickbooks_client: Optional[QuickBooksClient] = None,
    max_items: int = 100
) -> Dict[str, Any]:
    """
    Valida la integridad de los datos en QuickBooks.
    
    Args:
        quickbooks_client: Cliente de QuickBooks (opcional)
        max_items: Número máximo de ítems a validar
    
    Returns:
        Dict con resultado de la validación
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    validacion = {
        "timestamp": time.time(),
        "items_validados": 0,
        "errores_encontrados": 0,
        "advertencias": 0,
        "errores": [],
        "advertencias_list": [],
        "items_por_tipo": {}
    }
    
    try:
        # Obtener ítems
        company_id = quickbooks_client._get_company_id()
        base_url = quickbooks_client.config.base_url or "https://quickbooks.api.intuit.com"
        url = f"{base_url}/v3/company/{company_id}/query"
        
        headers = quickbooks_client._get_headers()
        headers["Content-Type"] = "application/text"
        
        query = f"SELECT * FROM Item MAXRESULTS {max_items}"
        params = {
            "minorversion": quickbooks_client.config.minor_version,
            "query": query
        }
        
        response = quickbooks_client._session.get(url, headers=headers, params=params, timeout=30)
        
        if response.status_code == 200:
            data = response.json()
            query_response = data.get("QueryResponse", {})
            items = query_response.get("Item", [])
            
            if not isinstance(items, list):
                items = [items]
            
            validacion["items_validados"] = len(items)
            
            for item in items:
                item_id = item.get("Id")
                nombre = item.get("Name", "")
                tipo = item.get("Type", "Unknown")
                
                # Contar por tipo
                validacion["items_por_tipo"][tipo] = validacion["items_por_tipo"].get(tipo, 0) + 1
                
                # Validar nombre
                if not nombre or len(nombre.strip()) == 0:
                    validacion["errores_encontrados"] += 1
                    validacion["errores"].append({
                        "item_id": item_id,
                        "campo": "nombre",
                        "problema": "Nombre vacío o nulo"
                    })
                
                # Validar precio
                precio = item.get("UnitPrice")
                if precio is not None:
                    try:
                        precio_float = float(precio) if isinstance(precio, (str, Decimal)) else precio
                        if precio_float < 0:
                            validacion["errores_encontrados"] += 1
                            validacion["errores"].append({
                                "item_id": item_id,
                                "campo": "precio",
                                "problema": "Precio negativo",
                                "valor": precio_float
                            })
                    except (ValueError, TypeError):
                        validacion["advertencias"] += 1
                        validacion["advertencias_list"].append({
                            "item_id": item_id,
                            "campo": "precio",
                            "problema": "Precio no numérico",
                            "valor": precio
                        })
                
                # Validar cuenta de ingresos
                income_account = item.get("IncomeAccountRef", {})
                if not income_account or not income_account.get("name"):
                    validacion["advertencias"] += 1
                    validacion["advertencias_list"].append({
                        "item_id": item_id,
                        "campo": "income_account",
                        "problema": "Cuenta de ingresos no configurada"
                    })
                
                # Validar nombre demasiado largo
                if len(nombre) > MAX_ITEM_NAME_LENGTH:
                    validacion["advertencias"] += 1
                    validacion["advertencias_list"].append({
                        "item_id": item_id,
                        "campo": "nombre",
                        "problema": f"Nombre excede longitud máxima ({len(nombre)} > {MAX_ITEM_NAME_LENGTH})",
                        "valor": nombre[:50] + "..."
                    })
        
    except Exception as e:
        logger.error(f"Error validando integridad: {str(e)}")
        validacion["error"] = str(e)
    
    return validacion


def analizar_tendencias_precios(
    quickbooks_client: Optional[QuickBooksClient] = None,
    max_items: int = 100
) -> Dict[str, Any]:
    """
    Analiza tendencias y estadísticas de precios de ítems en QuickBooks.
    
    Args:
        quickbooks_client: Cliente de QuickBooks (opcional)
        max_items: Número máximo de ítems a analizar
    
    Returns:
        Dict con análisis de precios
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    analisis = {
        "timestamp": time.time(),
        "total_items_analizados": 0,
        "items_con_precio": 0,
        "items_sin_precio": 0,
        "precio_minimo": None,
        "precio_maximo": None,
        "precio_promedio": None,
        "precio_mediana": None,
        "precios_por_tipo": {},
        "distribucion_precios": {}
    }
    
    try:
        # Obtener ítems
        company_id = quickbooks_client._get_company_id()
        base_url = quickbooks_client.config.base_url or "https://quickbooks.api.intuit.com"
        url = f"{base_url}/v3/company/{company_id}/query"
        
        headers = quickbooks_client._get_headers()
        headers["Content-Type"] = "application/text"
        
        query = f"SELECT * FROM Item MAXRESULTS {max_items}"
        params = {
            "minorversion": quickbooks_client.config.minor_version,
            "query": query
        }
        
        response = quickbooks_client._session.get(url, headers=headers, params=params, timeout=30)
        
        if response.status_code == 200:
            data = response.json()
            query_response = data.get("QueryResponse", {})
            items = query_response.get("Item", [])
            
            if not isinstance(items, list):
                items = [items]
            
            analisis["total_items_analizados"] = len(items)
            
            precios = []
            precios_por_tipo = {}
            
            for item in items:
                precio = item.get("UnitPrice")
                tipo = item.get("Type", "Unknown")
                
                if precio is not None:
                    try:
                        precio_float = float(precio) if isinstance(precio, (str, Decimal)) else precio
                        if precio_float >= 0:
                            precios.append(precio_float)
                            analisis["items_con_precio"] += 1
                            
                            # Agrupar por tipo
                            if tipo not in precios_por_tipo:
                                precios_por_tipo[tipo] = []
                            precios_por_tipo[tipo].append(precio_float)
                    except (ValueError, TypeError):
                        pass
                
                if precio is None:
                    analisis["items_sin_precio"] += 1
            
            if precios:
                precios_sorted = sorted(precios)
                analisis["precio_minimo"] = min(precios)
                analisis["precio_maximo"] = max(precios)
                analisis["precio_promedio"] = round(sum(precios) / len(precios), 2)
                
                # Calcular mediana
                n = len(precios_sorted)
                if n % 2 == 0:
                    mediana = (precios_sorted[n//2 - 1] + precios_sorted[n//2]) / 2
                else:
                    mediana = precios_sorted[n//2]
                analisis["precio_mediana"] = round(mediana, 2)
                
                # Estadísticas por tipo
                for tipo, precios_tipo in precios_por_tipo.items():
                    if precios_tipo:
                        analisis["precios_por_tipo"][tipo] = {
                            "cantidad": len(precios_tipo),
                            "minimo": min(precios_tipo),
                            "maximo": max(precios_tipo),
                            "promedio": round(sum(precios_tipo) / len(precios_tipo), 2)
                        }
                
                # Distribución de precios (rangos)
                if analisis["precio_maximo"]:
                    max_precio = analisis["precio_maximo"]
                    rangos = [
                        (0, 10, "$0-$10"),
                        (10, 50, "$10-$50"),
                        (50, 100, "$50-$100"),
                        (100, 500, "$100-$500"),
                        (500, float('inf'), "$500+")
                    ]
                    
                    for min_rango, max_rango, etiqueta in rangos:
                        count = sum(1 for p in precios if min_rango <= p < max_rango)
                        if count > 0:
                            analisis["distribucion_precios"][etiqueta] = count
        
    except Exception as e:
        logger.error(f"Error analizando tendencias: {str(e)}")
        analisis["error"] = str(e)
    
    return analisis


def sincronizar_con_matching_inteligente(
    productos: List[Dict[str, Any]],
    quickbooks_client: Optional[QuickBooksClient] = None,
    umbral_similitud: float = 0.8
) -> Dict[str, Any]:
    """
    Sincroniza productos usando matching inteligente (fuzzy matching) para nombres similares.
    
    Args:
        productos: Lista de productos
        quickbooks_client: Cliente de QuickBooks (opcional)
        umbral_similitud: Umbral de similitud para matching (0.0-1.0)
    
    Returns:
        Dict con resultado de sincronización con matching
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    resultado = {
        "timestamp": time.time(),
        "total_productos": len(productos),
        "productos_sincronizados": 0,
        "productos_con_matching": 0,
        "productos_nuevos": 0,
        "productos_fallidos": 0,
        "detalles": []
    }
    
    # Intentar importar fuzzy matching si está disponible
    try:
        from difflib import SequenceMatcher
        FUZZY_AVAILABLE = True
    except ImportError:
        FUZZY_AVAILABLE = False
        logger.warning("Fuzzy matching no disponible, usando matching exacto")
    
    def calcular_similitud(str1: str, str2: str) -> float:
        """Calcula similitud entre dos strings."""
        if FUZZY_AVAILABLE:
            return SequenceMatcher(None, str1.lower(), str2.lower()).ratio()
        else:
            return 1.0 if str1.lower().strip() == str2.lower().strip() else 0.0
    
    for producto in productos:
        stripe_id = producto.get("stripe_product_id", "")
        nombre = producto.get("nombre_producto", "")
        precio = producto.get("precio", 0.0)
        
        detalle = {
            "stripe_product_id": stripe_id,
            "nombre_producto": nombre,
            "matching_encontrado": False,
            "similitud": 0.0,
            "accion": None
        }
        
        try:
            # Buscar exacto primero
            item_qb = quickbooks_client.find_item_by_name(nombre)
            
            if item_qb:
                # Matching exacto encontrado
                detalle["matching_encontrado"] = True
                detalle["similitud"] = 1.0
                detalle["qb_item_id"] = item_qb.get("Id")
                
                # Verificar si necesita actualización
                precio_qb = item_qb.get("UnitPrice")
                if precio_qb is not None:
                    precio_qb_float = float(precio_qb) if isinstance(precio_qb, (str, Decimal)) else precio_qb
                    if abs(float(precio) - precio_qb_float) > 0.01:
                        # Actualizar precio
                        sync_result = sync_stripe_product_to_quickbooks(
                            stripe_product_id=stripe_id,
                            nombre_producto=nombre,
                            precio=precio,
                            quickbooks_client=quickbooks_client
                        )
                        if sync_result.success:
                            resultado["productos_sincronizados"] += 1
                            detalle["accion"] = "actualizado"
                        else:
                            resultado["productos_fallidos"] += 1
                            detalle["accion"] = "error_actualizacion"
                    else:
                        resultado["productos_sincronizados"] += 1
                        detalle["accion"] = "ya_sincronizado"
            else:
                # Intentar matching inteligente con otros ítems
                # Obtener algunos ítems para comparar
                company_id = quickbooks_client._get_company_id()
                base_url = quickbooks_client.config.base_url or "https://quickbooks.api.intuit.com"
                url = f"{base_url}/v3/company/{company_id}/query"
                
                headers = quickbooks_client._get_headers()
                headers["Content-Type"] = "application/text"
                
                query = f"SELECT Id, Name FROM Item MAXRESULTS 50"
                params = {
                    "minorversion": quickbooks_client.config.minor_version,
                    "query": query
                }
                
                response = quickbooks_client._session.get(url, headers=headers, params=params, timeout=10)
                
                mejor_match = None
                mejor_similitud = 0.0
                
                if response.status_code == 200:
                    data = response.json()
                    query_response = data.get("QueryResponse", {})
                    items = query_response.get("Item", [])
                    
                    if not isinstance(items, list):
                        items = [items]
                    
                    for item in items:
                        nombre_item = item.get("Name", "")
                        similitud = calcular_similitud(nombre, nombre_item)
                        
                        if similitud > mejor_similitud and similitud >= umbral_similitud:
                            mejor_similitud = similitud
                            mejor_match = item
                
                if mejor_match:
                    detalle["matching_encontrado"] = True
                    detalle["similitud"] = mejor_similitud
                    detalle["qb_item_id"] = mejor_match.get("Id")
                    detalle["qb_item_nombre"] = mejor_match.get("Name")
                    resultado["productos_con_matching"] += 1
                    
                    # Actualizar usando el matching encontrado
                    item_completo = quickbooks_client.find_item_by_name(mejor_match.get("Name"))
                    if item_completo:
                        sync_token = item_completo.get("SyncToken", "0")
                        quickbooks_client.update_item(
                            item_id=mejor_match.get("Id"),
                            sync_token=sync_token,
                            price=precio,
                            name=nombre  # Actualizar nombre también
                        )
                        resultado["productos_sincronizados"] += 1
                        detalle["accion"] = "actualizado_con_matching"
                else:
                    # Crear nuevo ítem
                    sync_result = sync_stripe_product_to_quickbooks(
                        stripe_product_id=stripe_id,
                        nombre_producto=nombre,
                        precio=precio,
                        quickbooks_client=quickbooks_client
                    )
                    if sync_result.success:
                        resultado["productos_sincronizados"] += 1
                        resultado["productos_nuevos"] += 1
                        detalle["accion"] = "creado"
                        detalle["qb_item_id"] = sync_result.qb_item_id
                    else:
                        resultado["productos_fallidos"] += 1
                        detalle["accion"] = "error_creacion"
        
        except Exception as e:
            logger.error(f"Error en matching inteligente para {stripe_id}: {str(e)}")
            resultado["productos_fallidos"] += 1
            detalle["accion"] = "error"
            detalle["error"] = str(e)
        
        resultado["detalles"].append(detalle)
    
    return resultado


# Funciones de testing y utilidades avanzadas
def crear_producto_test(
    nombre_producto: str = "Producto Test",
    precio: float = 99.99,
    stripe_product_id: Optional[str] = None,
    quickbooks_client: Optional[QuickBooksClient] = None
) -> SyncResult:
    """
    Crea un producto de prueba para testing.
    
    Args:
        nombre_producto: Nombre del producto de prueba
        precio: Precio del producto
        stripe_product_id: ID de Stripe (si None, se genera uno)
        quickbooks_client: Cliente de QuickBooks (opcional)
    
    Returns:
        SyncResult de la creación
    
    Example:
        >>> result = crear_producto_test("Test Product", 50.0)
        >>> assert result.success
    """
    if stripe_product_id is None:
        stripe_product_id = f"prod_test_{int(time.time())}"
    
    return sync_stripe_product_to_quickbooks(
        stripe_product_id=stripe_product_id,
        nombre_producto=nombre_producto,
        precio=precio,
        quickbooks_client=quickbooks_client
    )


def limpiar_productos_test(
    prefijo: str = "Producto Test",
    quickbooks_client: Optional[QuickBooksClient] = None
) -> Dict[str, Any]:
    """
    Limpia productos de prueba de QuickBooks.
    
    Args:
        prefijo: Prefijo de nombres de productos a limpiar
        quickbooks_client: Cliente de QuickBooks (opcional)
    
    Returns:
        Dict con resultado de la limpieza
    
    Warning:
        Esta función busca y podría eliminar ítems con el prefijo especificado.
        Usar con precaución en producción.
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    resultado = {
        "encontrados": 0,
        "eliminados": 0,
        "errores": [],
        "timestamp": time.time()
    }
    
    try:
        # Buscar ítems con el prefijo
        items_duplicados = buscar_items_duplicados(prefijo, quickbooks_client)
        resultado["encontrados"] = len(items_duplicados)
        
        # Nota: QuickBooks no permite eliminar ítems directamente vía API en algunos casos
        # Esta función documenta los encontrados pero no los elimina por seguridad
        logger.warning(
            f"Encontrados {len(items_duplicados)} ítems con prefijo '{prefijo}'. "
            "Eliminación manual requerida desde QuickBooks UI."
        )
        
        resultado["items_encontrados"] = items_duplicados
        resultado["mensaje"] = "Eliminación manual requerida desde QuickBooks"
        
    except Exception as e:
        resultado["errores"].append(str(e))
        logger.error(f"Error limpiando productos de prueba: {str(e)}")
    
    return resultado


def simular_sincronizacion(
    productos: List[Dict[str, Any]],
    dry_run: bool = True,
    quickbooks_client: Optional[QuickBooksClient] = None
) -> Dict[str, Any]:
    """
    Simula una sincronización sin hacer cambios reales.
    
    Args:
        productos: Lista de productos a simular
        dry_run: Si True, no hace cambios reales
        quickbooks_client: Cliente de QuickBooks (opcional)
    
    Returns:
        Dict con resultado de la simulación
    
    Example:
        >>> productos = [
        ...     {"stripe_product_id": "prod_1", "nombre_producto": "Test", "precio": 99.99}
        ... ]
        >>> resultado = simular_sincronizacion(productos, dry_run=True)
        >>> print(f"Simulados: {resultado['simulados']}")
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    resultado = {
        "simulados": 0,
        "crearian": 0,
        "actualizarian": 0,
        "errores": 0,
        "productos": [],
        "dry_run": dry_run,
        "timestamp": time.time()
    }
    
    for producto in productos:
        try:
            nombre = producto.get("nombre_producto") or producto.get("name", "")
            item_existente = quickbooks_client.find_item_by_name(nombre)
            
            producto_simulado = {
                "stripe_product_id": producto.get("stripe_product_id"),
                "nombre_producto": nombre,
                "precio": producto.get("precio") or producto.get("price"),
                "accion": "actualizaría" if item_existente else "crearía",
                "item_existe": bool(item_existente),
                "qb_item_id_existente": item_existente.get("Id") if item_existente else None
            }
            
            resultado["productos"].append(producto_simulado)
            resultado["simulados"] += 1
            
            if item_existente:
                resultado["actualizarian"] += 1
            else:
                resultado["crearian"] += 1
                
        except Exception as e:
            resultado["errores"] += 1
            logger.warning(f"Error simulando producto {producto.get('stripe_product_id')}: {str(e)}")
    
    return resultado


def exportar_resultados_sincronizacion(
    resultados: Union[SyncResult, BatchSyncResult, List[SyncResult]],
    formato: Literal["json", "csv", "dict"] = "json",
    archivo: Optional[str] = None
) -> Union[str, Dict[str, Any]]:
    """
    Exporta resultados de sincronización en diferentes formatos.
    
    Args:
        resultados: Resultados a exportar
        formato: Formato de exportación ('json', 'csv', 'dict')
        archivo: Ruta del archivo para guardar (opcional)
    
    Returns:
        Resultados en el formato especificado (o string si se guarda a archivo)
    
    Example:
        >>> resultado = sync_stripe_product_to_quickbooks(...)
        >>> exportar_resultados_sincronizacion(resultado, formato="json", archivo="resultado.json")
    """
    import csv
    
    # Convertir a lista si es necesario
    if isinstance(resultados, SyncResult):
        resultados_list = [resultados]
    elif isinstance(resultados, BatchSyncResult):
        resultados_list = resultados.results
    else:
        resultados_list = resultados
    
    # Preparar datos
    datos = [r.to_dict() for r in resultados_list]
    
    if formato == "json":
        output = json.dumps(datos, indent=2, default=str, ensure_ascii=False)
    elif formato == "csv":
        if not datos:
            output = ""
        else:
            fieldnames = datos[0].keys()
            output_lines = []
            writer = csv.DictWriter(output_lines, fieldnames=fieldnames)
            writer.writeheader()
            writer.writerows(datos)
            output = "\n".join(output_lines)
    else:  # dict
        output = datos
    
    # Guardar a archivo si se especifica
    if archivo:
        with open(archivo, 'w', encoding='utf-8') as f:
            if formato == "json":
                f.write(output)
            elif formato == "csv":
                f.write(output)
            else:
                json.dump(output, f, indent=2, default=str, ensure_ascii=False)
        return f"Resultados exportados a {archivo}"
    
    return output


def comparar_productos_stripe_quickbooks(
    stripe_product_id: str,
    quickbooks_item_name: Optional[str] = None,
    quickbooks_client: Optional[QuickBooksClient] = None
) -> Dict[str, Any]:
    """
    Compara un producto de Stripe con su correspondiente ítem en QuickBooks.
    
    Args:
        stripe_product_id: ID del producto en Stripe
        quickbooks_item_name: Nombre del ítem en QuickBooks (opcional)
        quickbooks_client: Cliente de QuickBooks (opcional)
    
    Returns:
        Dict con comparación detallada
    
    Example:
        >>> comparacion = comparar_productos_stripe_quickbooks("prod_123")
        >>> print(f"Coinciden: {comparacion['coinciden']}")
    """
    if quickbooks_client is None:
        quickbooks_client = QuickBooksClient()
    
    comparacion = {
        "stripe_product_id": stripe_product_id,
        "coinciden": False,
        "diferencias": [],
        "stripe": {},
        "quickbooks": {},
        "timestamp": time.time()
    }
    
    try:
        # Obtener producto de Stripe
        producto_stripe = _obtener_producto_stripe(stripe_product_id)
        if producto_stripe:
            comparacion["stripe"] = {
                "nombre": producto_stripe.get("name"),
                "activo": producto_stripe.get("active", True),
                "descripcion": producto_stripe.get("description")
            }
        
        # Buscar ítem en QuickBooks
        nombre_busqueda = quickbooks_item_name or comparacion["stripe"].get("nombre")
        if nombre_busqueda:
            item_qb = quickbooks_client.find_item_by_name(nombre_busqueda)
            if item_qb:
                comparacion["quickbooks"] = {
                    "id": item_qb.get("Id"),
                    "nombre": item_qb.get("Name"),
                    "precio": item_qb.get("UnitPrice"),
                    "activo": item_qb.get("Active", True),
                    "tipo": item_qb.get("Type")
                }
                
                # Comparar
                if producto_stripe:
                    if comparacion["stripe"]["nombre"] != comparacion["quickbooks"]["nombre"]:
                        comparacion["diferencias"].append("nombre")
                    
                    if comparacion["stripe"]["activo"] != comparacion["quickbooks"]["activo"]:
                        comparacion["diferencias"].append("estado_activo")
                
                comparacion["coinciden"] = len(comparacion["diferencias"]) == 0
            else:
                comparacion["diferencias"].append("item_no_encontrado")
        else:
            comparacion["diferencias"].append("nombre_no_disponible")
            
    except Exception as e:
        comparacion["error"] = str(e)
        logger.error(f"Error comparando productos: {str(e)}")
    
    return comparacion

        "quickbooks": {},
        "timestamp": time.time()
    }
    
    try:
        # Obtener producto de Stripe
        producto_stripe = _obtener_producto_stripe(stripe_product_id)
        if producto_stripe:
            comparacion["stripe"] = {
                "nombre": producto_stripe.get("name"),
                "activo": producto_stripe.get("active", True),
                "descripcion": producto_stripe.get("description")
            }
        
        # Buscar ítem en QuickBooks
        nombre_busqueda = quickbooks_item_name or comparacion["stripe"].get("nombre")
        if nombre_busqueda:
            item_qb = quickbooks_client.find_item_by_name(nombre_busqueda)
            if item_qb:
                comparacion["quickbooks"] = {
                    "id": item_qb.get("Id"),
                    "nombre": item_qb.get("Name"),
                    "precio": item_qb.get("UnitPrice"),
                    "activo": item_qb.get("Active", True),
                    "tipo": item_qb.get("Type")
                }
                
                # Comparar
                if producto_stripe:
                    if comparacion["stripe"]["nombre"] != comparacion["quickbooks"]["nombre"]:
                        comparacion["diferencias"].append("nombre")
                    
                    if comparacion["stripe"]["activo"] != comparacion["quickbooks"]["activo"]:
                        comparacion["diferencias"].append("estado_activo")
                
                comparacion["coinciden"] = len(comparacion["diferencias"]) == 0
            else:
                comparacion["diferencias"].append("item_no_encontrado")
        else:
            comparacion["diferencias"].append("nombre_no_disponible")
            
    except Exception as e:
        comparacion["error"] = str(e)
        logger.error(f"Error comparando productos: {str(e)}")
    
    return comparacion




# ============================================================================
# MEJORAS AVANZADAS V6: Async Support, Observability, Webhooks, Event Sourcing
# ============================================================================
