{
  "description": "Nodos avanzados para predicci√≥n, A/B testing y optimizaci√≥n multi-objetivo",
  "nodes": [
    {
      "id": "predict-engagement",
      "name": "Predict Engagement Before Publishing",
      "type": "n8n-nodes-base.code",
      "parameters": {
        "jsCode": "// Predecir engagement antes de publicar\nconst videoData = $json;\nconst historicalData = $workflow.staticData.engagementHistory || [];\n\nif (historicalData.length < 20) {\n  return {\n    json: {\n      ...videoData,\n      prediction: {\n        available: false,\n        reason: 'insufficient_data',\n        minRequired: 20,\n        current: historicalData.length\n      }\n    }\n  };\n}\n\n// Extraer features del video\nconst features = {\n  hashtagCount: (videoData.hashtags || []).length,\n  captionLength: (videoData.caption || '').length,\n  hourOfDay: new Date().getHours(),\n  dayOfWeek: new Date().getDay(),\n  videoDuration: videoData.videoAnalysis?.duration || 0,\n  hashtagQuality: calculateHashtagQuality(videoData.hashtags, historicalData),\n  captionQuality: calculateCaptionQuality(videoData.caption, historicalData)\n};\n\n// Predecir para cada plataforma\nconst predictions = {};\n\n['instagram', 'tiktok', 'youtube'].forEach(platform => {\n  const platformData = historicalData.filter(h => \n    Object.keys(h.platformMetrics || {}).includes(platform)\n  );\n  \n  if (platformData.length < 5) {\n    predictions[platform] = {\n      available: false,\n      reason: 'insufficient_platform_data'\n    };\n    return;\n  }\n  \n  // Calcular promedios hist√≥ricos\n  const avgEngagementRate = platformData.reduce((sum, h) => \n    sum + (h.platformMetrics[platform]?.engagementRate || 0), 0\n  ) / platformData.length;\n  \n  // Ajustar basado en features\n  let predictedRate = avgEngagementRate;\n  \n  // Ajustar por calidad de hashtags\n  if (features.hashtagQuality > 0.7) predictedRate *= 1.2;\n  else if (features.hashtagQuality < 0.3) predictedRate *= 0.8;\n  \n  // Ajustar por calidad de caption\n  if (features.captionQuality > 0.7) predictedRate *= 1.15;\n  else if (features.captionQuality < 0.3) predictedRate *= 0.85;\n  \n  // Ajustar por horario\n  const bestHours = $workflow.staticData.bestHours || [];\n  const isOptimalHour = bestHours.some(h => h.hour === features.hourOfDay);\n  if (isOptimalHour) predictedRate *= 1.1;\n  \n  // Ajustar por cantidad de hashtags\n  if (features.hashtagCount >= 10 && features.hashtagCount <= 15) predictedRate *= 1.05;\n  else if (features.hashtagCount < 5) predictedRate *= 0.9;\n  \n  predictions[platform] = {\n    available: true,\n    expectedEngagementRate: Math.max(0, predictedRate),\n    expectedLikes: Math.round(predictedRate * 1000 / 100),\n    expectedComments: Math.round(predictedRate * 1000 / 100 * 0.1),\n    expectedShares: Math.round(predictedRate * 1000 / 100 * 0.05),\n    confidence: Math.min(100, platformData.length * 5)\n  };\n});\n\n// Encontrar mejor plataforma\nconst availablePredictions = Object.entries(predictions)\n  .filter(([_, p]) => p.available);\n\nif (availablePredictions.length === 0) {\n  return {\n    json: {\n      ...videoData,\n      prediction: {\n        available: false,\n        reason: 'no_platform_predictions'\n      }\n    }\n  };\n}\n\nconst bestPlatform = availablePredictions\n  .sort((a, b) => b[1].expectedEngagementRate - a[1].expectedEngagementRate)[0][0];\n\n// Generar recomendaciones\nconst recommendations = [];\n\nif (features.hashtagQuality < 0.5) {\n  recommendations.push({\n    type: 'hashtags',\n    priority: 'high',\n    message: 'Mejorar calidad de hashtags usando top hashtags probados',\n    action: 'use_top_hashtags'\n  });\n}\n\nif (features.captionQuality < 0.5) {\n  recommendations.push({\n    type: 'caption',\n    priority: 'medium',\n    message: 'Mejorar caption agregando elementos que funcionan (preguntas, emojis)',\n    action: 'enhance_caption'\n  });\n}\n\nconst bestHours = $workflow.staticData.bestHours || [];\nif (bestHours.length > 0 && !bestHours.some(h => h.hour === features.hourOfDay)) {\n  const nextBestHour = bestHours[0].hour;\n  recommendations.push({\n    type: 'timing',\n    priority: 'low',\n    message: `Considerar publicar a las ${nextBestHour}:00 para mejor engagement`,\n    action: 'schedule_optimal_time'\n  });\n}\n\nreturn {\n  json: {\n    ...videoData,\n    prediction: {\n      available: true,\n      predictions: predictions,\n      bestPlatform: bestPlatform,\n      recommendations: recommendations,\n      confidence: Math.round(\n        availablePredictions.reduce((sum, [_, p]) => sum + p.confidence, 0) / \n        availablePredictions.length\n      ),\n      shouldPublish: predictions[bestPlatform].expectedEngagementRate > 5.0,\n      expectedImprovement: predictions[bestPlatform].expectedEngagementRate > 8.0 ? 'high' :\n                          predictions[bestPlatform].expectedEngagementRate > 5.0 ? 'medium' : 'low'\n    }\n  }\n};\n\nfunction calculateHashtagQuality(hashtags, historicalData) {\n  if (!hashtags || hashtags.length === 0) return 0;\n  \n  const topHashtags = $workflow.staticData.topHashtags || [];\n  const topHashtagSet = new Set(topHashtags.map(h => h.tag.toLowerCase()));\n  \n  const hashtagArray = typeof hashtags === 'string' ? \n    hashtags.split(/\\s+/).filter(h => h.startsWith('#')) :\n    (Array.isArray(hashtags) ? hashtags : []);\n  \n  const matchingCount = hashtagArray.filter(h => \n    topHashtagSet.has(h.toLowerCase().replace('#', ''))\n  ).length;\n  \n  return hashtagArray.length > 0 ? matchingCount / hashtagArray.length : 0;\n}\n\nfunction calculateCaptionQuality(caption, historicalData) {\n  if (!caption || caption.length === 0) return 0;\n  \n  let score = 0;\n  \n  // Longitud √≥ptima (200-300 caracteres)\n  if (caption.length >= 200 && caption.length <= 300) score += 0.3;\n  else if (caption.length >= 150 && caption.length <= 400) score += 0.2;\n  \n  // Tiene pregunta\n  if (/\\?/.test(caption)) score += 0.2;\n  \n  // Tiene emojis\n  const emojiCount = (caption.match(/[\\u{1F300}-\\u{1F9FF}]/gu) || []).length;\n  if (emojiCount >= 2 && emojiCount <= 5) score += 0.2;\n  \n  // Tiene llamada a la acci√≥n\n  const ctaWords = ['comparte', 'comenta', 'like', 'sigue', 'guarda', 'descubre'];\n  if (ctaWords.some(word => caption.toLowerCase().includes(word))) score += 0.15;\n  \n  // Tiene n√∫meros/m√©tricas\n  if (/\\d+/.test(caption)) score += 0.15;\n  \n  return Math.min(1, score);\n}"
      },
      "position": [3650, 500],
      "notes": "Predice engagement antes de publicar"
    },
    {
      "id": "generate-ab-variants",
      "name": "Generate A/B Test Variants",
      "type": "n8n-nodes-base.code",
      "parameters": {
        "jsCode": "// Generar variantes para A/B testing\nconst originalContent = $json;\nconst historicalData = $workflow.staticData.engagementHistory || [];\nconst topHashtags = ($workflow.staticData.topHashtags || []).slice(0, 10).map(h => h.tag);\n\nconst variants = [];\n\n// Variante 1: Caption m√°s corta (70%)\nif (originalContent.caption && originalContent.caption.length > 150) {\n  const shortCaption = originalContent.caption.substring(0, Math.floor(originalContent.caption.length * 0.7));\n  variants.push({\n    id: 'variant_short_caption',\n    type: 'short_caption',\n    caption: shortCaption + '...',\n    hashtags: originalContent.hashtags,\n    thumbnail: originalContent.thumbnail,\n    description: 'Caption m√°s corta para mayor impacto'\n  });\n}\n\n// Variante 2: M√°s hashtags populares\nif (topHashtags.length > 0) {\n  const originalHashtags = typeof originalContent.hashtags === 'string' ?\n    originalContent.hashtags.split(/\\s+/) :\n    (Array.isArray(originalContent.hashtags) ? originalContent.hashtags : []);\n  \n  const combinedHashtags = [\n    ...originalHashtags.slice(0, 5),\n    ...topHashtags.slice(0, 10)\n  ];\n  \n  variants.push({\n    id: 'variant_popular_hashtags',\n    type: 'popular_hashtags',\n    caption: originalContent.caption,\n    hashtags: [...new Set(combinedHashtags)].slice(0, 15).join(' '),\n    thumbnail: originalContent.thumbnail,\n    description: 'Hashtags populares probados'\n  });\n}\n\n// Variante 3: Caption con pregunta\nif (originalContent.caption && !/\\?/.test(originalContent.caption)) {\n  const questionVariants = [\n    '¬øQu√© opinas?',\n    '¬øHas visto algo as√≠?',\n    '¬øTe gusta?',\n    '¬øQu√© te parece?'\n  ];\n  const randomQuestion = questionVariants[Math.floor(Math.random() * questionVariants.length)];\n  \n  variants.push({\n    id: 'variant_question',\n    type: 'question_caption',\n    caption: originalContent.caption + '\\n\\n' + randomQuestion,\n    hashtags: originalContent.hashtags,\n    thumbnail: originalContent.thumbnail,\n    description: 'Caption con pregunta para aumentar engagement'\n  });\n}\n\n// Variante 4: Caption con emojis estrat√©gicos\nif (originalContent.caption) {\n  const emojiCount = (originalContent.caption.match(/[\\u{1F300}-\\u{1F9FF}]/gu) || []).length;\n  if (emojiCount < 3) {\n    const strategicEmojis = ['üî•', '‚ú®', 'üíØ', 'üéØ', 'üöÄ'];\n    const emojiToAdd = strategicEmojis[Math.floor(Math.random() * strategicEmojis.length)];\n    \n    variants.push({\n      id: 'variant_emojis',\n      type: 'emojis_caption',\n      caption: emojiToAdd + ' ' + originalContent.caption + ' ' + emojiToAdd,\n      hashtags: originalContent.hashtags,\n      thumbnail: originalContent.thumbnail,\n      description: 'Caption con emojis estrat√©gicos'\n    });\n  }\n}\n\n// Variante 5: Original (control)\nvariants.unshift({\n  id: 'variant_control',\n  type: 'control',\n  caption: originalContent.caption,\n  hashtags: originalContent.hashtags,\n  thumbnail: originalContent.thumbnail,\n  description: 'Versi√≥n original (control)'\n});\n\nreturn {\n  json: {\n    ...originalContent,\n    abTestVariants: variants,\n    variantCount: variants.length,\n    testingEnabled: variants.length > 1\n  }\n};"
      },
      "position": [3850, 500],
      "notes": "Genera variantes para A/B testing"
    },
    {
      "id": "detect-emerging-trends",
      "name": "Detect Emerging Trends",
      "type": "n8n-nodes-base.code",
      "parameters": {
        "jsCode": "// Detectar tendencias emergentes\nconst historicalData = $workflow.staticData.engagementHistory || [];\nconst windowDays = parseInt($env.TREND_WINDOW_DAYS || '7');\n\nif (historicalData.length < 20) {\n  return {\n    json: {\n      ...$input.item.json,\n      trends: {\n        available: false,\n        reason: 'insufficient_data'\n      }\n    }\n  };\n}\n\nconst now = Date.now();\nconst windowStart = now - (windowDays * 24 * 60 * 60 * 1000);\nconst recentStart = now - (3 * 24 * 60 * 60 * 1000);\n\n// Analizar crecimiento de hashtags\nconst hashtagPerformance = {};\n\nhistoricalData.forEach(video => {\n  const videoDate = new Date(video.publishedAt).getTime();\n  if (videoDate < windowStart) return;\n  \n  const hashtags = typeof video.hashtags === 'string' ?\n    video.hashtags.split(/\\s+/).filter(h => h.startsWith('#')) :\n    (Array.isArray(video.hashtags) ? video.hashtags : []);\n  \n  hashtags.forEach(tag => {\n    const cleanTag = tag.toLowerCase().trim();\n    if (!hashtagPerformance[cleanTag]) {\n      hashtagPerformance[cleanTag] = {\n        early: { count: 0, totalRate: 0 },\n        recent: { count: 0, totalRate: 0 }\n      };\n    }\n    \n    const isRecent = videoDate > recentStart;\n    const period = isRecent ? 'recent' : 'early';\n    \n    hashtagPerformance[cleanTag][period].count++;\n    hashtagPerformance[cleanTag][period].totalRate += \n      video.overallMetrics?.avgEngagementRate || 0;\n  });\n});\n\n// Calcular crecimiento\nconst trends = Object.entries(hashtagPerformance)\n  .map(([tag, data]) => {\n    const earlyAvg = data.early.count > 0 ? \n      data.early.totalRate / data.early.count : 0;\n    const recentAvg = data.recent.count > 0 ? \n      data.recent.totalRate / data.recent.count : 0;\n    const growth = recentAvg - earlyAvg;\n    const growthPercent = earlyAvg > 0 ? (growth / earlyAvg) * 100 : 0;\n    \n    return {\n      tag: tag,\n      earlyAvg: earlyAvg,\n      recentAvg: recentAvg,\n      growth: growth,\n      growthPercent: growthPercent,\n      usageCount: data.recent.count + data.early.count,\n      trend: growthPercent > 50 ? 'hot' : \n             growthPercent > 20 ? 'emerging' : \n             growthPercent > 0 ? 'growing' : 'declining'\n    };\n  })\n  .filter(t => t.usageCount >= 2 && t.growthPercent > 0)\n  .sort((a, b) => b.growthPercent - a.growthPercent);\n\n// Categorizar tendencias\nconst categorizedTrends = {\n  hot: trends.filter(t => t.trend === 'hot').slice(0, 10),\n  emerging: trends.filter(t => t.trend === 'emerging').slice(0, 15),\n  growing: trends.filter(t => t.trend === 'growing').slice(0, 20),\n  all: trends.slice(0, 30)\n};\n\n// Guardar tendencias\n$workflow.staticData.emergingTrends = categorizedTrends;\n\nreturn {\n  json: {\n    ...$input.item.json,\n    trends: {\n      available: true,\n      hotTrends: categorizedTrends.hot,\n      emergingTrends: categorizedTrends.emerging,\n      growingTrends: categorizedTrends.growing,\n      allTrends: categorizedTrends.all,\n      windowDays: windowDays,\n      totalAnalyzed: historicalData.length\n    }\n  }\n};"
      },
      "position": [6050, 400],
      "notes": "Detecta tendencias emergentes"
    },
    {
      "id": "generate-intelligent-alerts",
      "name": "Generate Intelligent Alerts",
      "type": "n8n-nodes-base.code",
      "parameters": {
        "jsCode": "// Generar alertas inteligentes\nconst engagementHistory = $workflow.staticData.engagementHistory || [];\nconst recentHistory = engagementHistory.filter(h => {\n  const daysSince = (Date.now() - new Date(h.publishedAt).getTime()) / (24 * 60 * 60 * 1000);\n  return daysSince <= 7;\n});\n\nconst alerts = [];\n\n// Alerta: Contenido bajo performance\nconst lowPerformanceThreshold = parseFloat($env.LOW_PERFORMANCE_THRESHOLD || '3.0');\nconst lowPerformance = recentHistory.filter(\n  h => h.overallMetrics?.avgEngagementRate < lowPerformanceThreshold\n);\n\nif (lowPerformance.length > 0) {\n  alerts.push({\n    type: 'low_performance',\n    severity: 'medium',\n    title: 'Contenido con Bajo Engagement',\n    message: `${lowPerformance.length} videos con engagement < ${lowPerformanceThreshold}% en √∫ltimos 7 d√≠as`,\n    count: lowPerformance.length,\n    videos: lowPerformance.map(v => ({\n      id: v.videoId,\n      title: v.title,\n      engagementRate: v.overallMetrics?.avgEngagementRate || 0\n    })),\n    recommendations: [\n      'Revisar hashtags usados',\n      'Mejorar calidad de captions',\n      'Considerar diferentes horarios',\n      'Analizar contenido exitoso para replicar'\n    ]\n  });\n}\n\n// Alerta: Oportunidades de mejora\nif (recentHistory.length >= 5) {\n  const avgEngagement = recentHistory.reduce((sum, h) => \n    sum + (h.overallMetrics?.avgEngagementRate || 0), 0\n  ) / recentHistory.length;\n  \n  const topEngagement = Math.max(...recentHistory.map(h => \n    h.overallMetrics?.avgEngagementRate || 0\n  ));\n  \n  if (topEngagement > avgEngagement * 1.5) {\n    alerts.push({\n      type: 'improvement_opportunity',\n      severity: 'low',\n      title: 'Oportunidad de Mejora',\n      message: `El mejor video tiene ${topEngagement.toFixed(1)}% engagement vs promedio de ${avgEngagement.toFixed(1)}%`,\n      opportunity: `Replicar elementos del video exitoso puede mejorar engagement en ${((topEngagement / avgEngagement - 1) * 100).toFixed(0)}%`,\n      recommendations: [\n        'Analizar qu√© hizo diferente el video exitoso',\n        'Aplicar patrones similares a futuros videos',\n        'Considerar A/B testing con variantes'\n      ]\n    });\n  }\n}\n\n// Alerta: Tendencias emergentes\nconst emergingTrends = $workflow.staticData.emergingTrends || {};\nif (emergingTrends.hot && emergingTrends.hot.length > 0) {\n  alerts.push({\n    type: 'trending_opportunity',\n    severity: 'high',\n    title: 'Tendencias Calientes Detectadas',\n    message: `${emergingTrends.hot.length} hashtags con crecimiento >50% detectados`,\n    trends: emergingTrends.hot.slice(0, 5).map(t => ({\n      tag: t.tag,\n      growth: `${t.growthPercent.toFixed(1)}%`,\n      recentAvg: t.recentAvg.toFixed(2)\n    })),\n    recommendations: [\n      'Usar hashtags trending en pr√≥ximos videos',\n      'Publicar contenido relacionado r√°pidamente',\n      'Capitalizar tendencias antes de que se saturen'\n    ]\n  });\n}\n\n// Alerta: Contenido viral reciente\nconst viralVideos = recentHistory.filter(h => \n  h.overallMetrics?.viralOn && h.overallMetrics.viralOn.length > 0\n);\n\nif (viralVideos.length > 0) {\n  alerts.push({\n    type: 'viral_content',\n    severity: 'high',\n    title: 'üéâ Contenido Viral Detectado',\n    message: `${viralVideos.length} videos virales en √∫ltimos 7 d√≠as`,\n    videos: viralVideos.map(v => ({\n      id: v.videoId,\n      title: v.title,\n      platforms: v.overallMetrics?.viralOn || [],\n      engagementRate: v.overallMetrics?.avgEngagementRate || 0\n    })),\n    recommendations: [\n      'Analizar qu√© hizo viral este contenido',\n      'Replicar elementos exitosos',\n      'Crear contenido similar pero mejorado'\n    ]\n  });\n}\n\n// Alerta: Sistema necesita m√°s datos\nif (engagementHistory.length < 20) {\n  alerts.push({\n    type: 'insufficient_data',\n    severity: 'low',\n    title: 'M√°s Datos Necesarios',\n    message: `Sistema necesita al menos 20 videos para predicciones precisas. Actualmente: ${engagementHistory.length}`,\n    recommendations: [\n      'Continuar publicando contenido',\n      'Sistema mejorar√° con m√°s datos',\n      `Faltan ${20 - engagementHistory.length} videos para an√°lisis completo`\n    ]\n  });\n}\n\nreturn {\n  json: {\n    ...$input.item.json,\n    alerts: alerts,\n    alertCount: alerts.length,\n    criticalAlerts: alerts.filter(a => a.severity === 'high').length,\n    timestamp: new Date().toISOString()\n  }\n};"
      },
      "position": [6250, 400],
      "notes": "Genera alertas inteligentes"
    },
    {
      "id": "integrate-python-analysis",
      "name": "Integrate Python Analysis Script",
      "type": "n8n-nodes-base.executeCommand",
      "parameters": {
        "command": "cd /Users/adan/IA/scripts && python3 analisis_engagement_contenido.py /tmp/engagement_export.json --format json",
        "options": {}
      },
      "position": [6450, 400],
      "continueOnFail": true,
      "notes": "Integra con script Python de an√°lisis"
    }
  ],
  "integration_points": {
    "predict_engagement": "Agregar despu√©s de 'Process AI Generated Content', antes de publicar",
    "generate_ab_variants": "Agregar despu√©s de 'Generate Content', antes de publicar",
    "detect_emerging_trends": "Agregar en workflow de tracking, despu√©s de 'Update Learning Model'",
    "generate_intelligent_alerts": "Agregar en workflow de tracking, al final",
    "integrate_python_analysis": "Agregar en workflow de tracking, opcional"
  },
  "usage": {
    "description": "Nodos avanzados para predicci√≥n, A/B testing y an√°lisis predictivo",
    "setup": "1. Agregar nodos seg√∫n integration_points\n2. Configurar variables de entorno\n3. Sistema mejorar√° con m√°s datos"
  }
}



