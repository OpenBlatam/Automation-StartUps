[
  {
    "parameters": {
      "jsCode": "// Sistema de Scoring de Contenido en Tiempo Real\nconst data = $json;\nconst posts = data.postsByType ? Object.values(data.postsByType).flatMap(type => type.posts || []) : [];\n\nif (posts.length < 5) {\n  return [{\n    json: {\n      ...data,\n      contentScoring: null\n    }\n  }];\n}\n\n// Calcular scores para posts recientes\nconst scoredPosts = posts.slice(0, 10).map(post => {\n  let score = 0;\n  const factors = {};\n  const recommendations = [];\n  \n  // Factor 1: Tipo de contenido (0-20 puntos)\n  const contentType = post.contentType || 'unknown';\n  const typeStats = data.postsByType[contentType];\n  if (typeStats) {\n    const avgEngagement = typeStats.avgEngagementPerPost || 0;\n    const bestAvg = Math.max(...Object.values(data.postsByType).map(t => t.avgEngagementPerPost || 0));\n    if (avgEngagement >= bestAvg * 0.9) {\n      factors.typeContent = 20;\n    } else if (avgEngagement >= bestAvg * 0.7) {\n      factors.typeContent = 15;\n    } else {\n      factors.typeContent = 10;\n      recommendations.push(`Considerar cambiar tipo de contenido a ${data.bestContentType}`);\n    }\n  } else {\n    factors.typeContent = 10;\n  }\n  score += factors.typeContent;\n  \n  // Factor 2: Timing (0-15 puntos)\n  if (post.published_at) {\n    const pubDate = new Date(post.published_at);\n    const hour = pubDate.getHours();\n    const day = pubDate.getDay();\n    const bestHour = data.bestPostingHour || 10;\n    const bestDay = data.bestPostingDay || 3; // Wednesday\n    \n    let timingScore = 0;\n    if (day === bestDay && Math.abs(hour - bestHour) <= 1) {\n      timingScore = 15;\n    } else if (day === bestDay && Math.abs(hour - bestHour) <= 3) {\n      timingScore = 12;\n    } else if (day === bestDay) {\n      timingScore = 8;\n    } else {\n      timingScore = 5;\n      recommendations.push(`Mejor momento: ${['Domingo','Lunes','Martes','Miércoles','Jueves','Viernes','Sábado'][bestDay]} a las ${bestHour}:00`);\n    }\n    factors.timing = timingScore;\n    score += timingScore;\n  } else {\n    factors.timing = 7;\n    score += 7;\n  }\n  \n  // Factor 3: Hashtags (0-15 puntos)\n  const hashtags = post.hashtags || [];\n  if (hashtags.length > 0 && data.topHashtags) {\n    const topHashtags = data.topHashtags.slice(0, 10).map(h => h.hashtag.toLowerCase());\n    const effectiveHashtags = hashtags.filter(h => topHashtags.includes(h.toLowerCase())).length;\n    factors.hashtags = Math.min(15, (effectiveHashtags / hashtags.length) * 15);\n    if (factors.hashtags < 10) {\n      recommendations.push(`Usar hashtags más efectivos: ${data.topHashtags.slice(0, 3).map(h => h.hashtag).join(', ')}`);\n    }\n  } else {\n    factors.hashtags = 0;\n    recommendations.push('Agregar hashtags relevantes');\n  }\n  score += factors.hashtags;\n  \n  // Factor 4: Longitud del título (0-10 puntos)\n  const title = post.article_title || post.content || '';\n  const titleLength = title.length;\n  if (titleLength >= 50 && titleLength <= 150) {\n    factors.titleLength = 10;\n  } else if (titleLength >= 30 && titleLength <= 200) {\n    factors.titleLength = 7;\n  } else {\n    factors.titleLength = 5;\n    recommendations.push('Optimizar longitud del título (50-150 caracteres recomendado)');\n  }\n  score += factors.titleLength;\n  \n  // Factor 5: Plataforma (0-15 puntos)\n  const platform = post.platform || 'unknown';\n  if (platform === data.bestPlatform) {\n    factors.platform = 15;\n  } else if (data.platformStats && data.platformStats[platform]) {\n    const platformStats = data.platformStats[platform];\n    const bestPlatformStats = data.platformStats[data.bestPlatform] || {};\n    const ratio = (platformStats.avgEngagementPerPost || 0) / (bestPlatformStats.avgEngagementPerPost || 1);\n    factors.platform = Math.round(15 * ratio);\n    if (ratio < 0.7) {\n      recommendations.push(`Considerar publicar en ${data.bestPlatform} en su lugar`);\n    }\n  } else {\n    factors.platform = 7;\n  }\n  score += factors.platform;\n  \n  // Factor 6: Engagement actual vs esperado (0-25 puntos)\n  const currentEngagement = post.totalEngagement || 0;\n  const expectedEngagement = typeStats ? (typeStats.avgEngagementPerPost || 0) : 0;\n  if (expectedEngagement > 0) {\n    const ratio = currentEngagement / expectedEngagement;\n    if (ratio >= 1.2) {\n      factors.performance = 25;\n    } else if (ratio >= 1.0) {\n      factors.performance = 20;\n    } else if (ratio >= 0.8) {\n      factors.performance = 15;\n    } else {\n      factors.performance = 10;\n      recommendations.push('Engagement por debajo del esperado, revisar estrategia');\n    }\n  } else {\n    factors.performance = 12;\n  }\n  score += factors.performance;\n  \n  // Clasificación final\n  let level = 'Bajo';\n  let viralProbability = 'Baja';\n  if (score >= 85) {\n    level = 'Excelente';\n    viralProbability = 'Muy Alta';\n  } else if (score >= 70) {\n    level = 'Bueno';\n    viralProbability = 'Alta';\n  } else if (score >= 55) {\n    level = 'Regular';\n    viralProbability = 'Media';\n  } else {\n    level = 'Bajo';\n    viralProbability = 'Baja';\n  }\n  \n  return {\n    post_id: post.post_id,\n    title: title.substring(0, 100),\n    platform: platform,\n    contentType: contentType,\n    score: Math.round(score),\n    level: level,\n    viralProbability: viralProbability,\n    factors: factors,\n    recommendations: recommendations,\n    currentEngagement: currentEngagement,\n    expectedEngagement: expectedEngagement\n  };\n});\n\n// Estadísticas generales\nconst avgScore = scoredPosts.reduce((sum, p) => sum + p.score, 0) / scoredPosts.length;\nconst excellentPosts = scoredPosts.filter(p => p.level === 'Excelente').length;\nconst goodPosts = scoredPosts.filter(p => p.level === 'Bueno').length;\n\nreturn [{\n  json: {\n    ...data,\n    contentScoring: {\n      totalScored: scoredPosts.length,\n      averageScore: Math.round(avgScore),\n      excellentCount: excellentPosts,\n      goodCount: goodPosts,\n      scoredPosts: scoredPosts.slice(0, 5),\n      recommendations: {\n        improveTiming: scoredPosts.filter(p => p.factors.timing < 10).length,\n        improveHashtags: scoredPosts.filter(p => p.factors.hashtags < 10).length,\n        improvePlatform: scoredPosts.filter(p => p.factors.platform < 10).length\n      }\n    }\n  }\n}];"
    },
    "id": "content-scoring",
    "name": "Content Scoring Real-Time",
    "type": "n8n-nodes-base.code",
    "typeVersion": 2,
    "position": [1650, 2600],
    "notes": "Sistema de scoring de contenido en tiempo real",
    "continueOnFail": true
  },
  {
    "parameters": {
      "jsCode": "// Análisis de Tendencias de Mercado Avanzado\nconst data = $json;\nconst posts = data.postsByType ? Object.values(data.postsByType).flatMap(type => type.posts || []) : [];\n\nif (posts.length < 10) {\n  return [{\n    json: {\n      ...data,\n      marketTrends: null\n    }\n  }];\n}\n\n// Extraer palabras clave de títulos\nconst stopWords = new Set(['el', 'la', 'los', 'las', 'un', 'una', 'de', 'del', 'en', 'y', 'o', 'a', 'que', 'es', 'se', 'por', 'con', 'para', 'como', 'más', 'muy']);\nconst keywordData = {};\n\nposts.forEach(post => {\n  const title = (post.article_title || post.content || '').toLowerCase();\n  const words = title.match(/\\b\\w{4,}\\b/g) || [];\n  const pubDate = post.published_at ? new Date(post.published_at) : null;\n  \n  words.forEach(word => {\n    if (!stopWords.has(word) && word.length >= 4) {\n      if (!keywordData[word]) {\n        keywordData[word] = {\n          keyword: word,\n          posts: [],\n          engagements: []\n        };\n      }\n      keywordData[word].posts.push({ date: pubDate, engagement: post.totalEngagement || 0 });\n      keywordData[word].engagements.push(post.totalEngagement || 0);\n    }\n  });\n});\n\n// Analizar tendencias por palabra clave\nconst trends = [];\nconst now = new Date();\nconst thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n\nObject.keys(keywordData).forEach(keyword => {\n  const data = keywordData[keyword];\n  if (data.posts.length < 2) return;\n  \n  // Dividir en dos períodos\n  const sortedPosts = data.posts.filter(p => p.date).sort((a, b) => a.date - b.date);\n  if (sortedPosts.length < 2) return;\n  \n  const midpoint = Math.floor(sortedPosts.length / 2);\n  const firstHalf = sortedPosts.slice(0, midpoint);\n  const secondHalf = sortedPosts.slice(midpoint);\n  \n  const firstHalfAvg = firstHalf.length > 0 ? \n    firstHalf.reduce((sum, p) => sum + p.engagement, 0) / firstHalf.length : 0;\n  const secondHalfAvg = secondHalf.length > 0 ? \n    secondHalf.reduce((sum, p) => sum + p.engagement, 0) / secondHalf.length : 0;\n  \n  const change = secondHalfAvg - firstHalfAvg;\n  const changePercent = firstHalfAvg > 0 ? ((change / firstHalfAvg) * 100) : 0;\n  \n  const firstHalfFreq = firstHalf.length;\n  const secondHalfFreq = secondHalf.length;\n  const freqGrowth = firstHalfFreq > 0 ? ((secondHalfFreq - firstHalfFreq) / firstHalfFreq * 100) : 0;\n  \n  // Clasificar tendencia\n  let trendType = 'ESTABLE';\n  if (changePercent > 20 && freqGrowth > 10) {\n    trendType = 'EMERGENTE';\n  } else if (changePercent < -20) {\n    trendType = 'DECLINANTE';\n  } else if (changePercent > 0) {\n    trendType = 'CRECIENTE';\n  } else if (changePercent < 0) {\n    trendType = 'DECRECIENTE';\n  }\n  \n  trends.push({\n    keyword: keyword,\n    trendType: trendType,\n    avgEngagement: data.engagements.reduce((a, b) => a + b, 0) / data.engagements.length,\n    changePercent: Math.round(changePercent * 10) / 10,\n    frequency: data.posts.length,\n    freqGrowth: Math.round(freqGrowth * 10) / 10,\n    recommendation: trendType === 'EMERGENTE' ? `Incrementar uso de '${keyword}' - tendencia emergente` :\n                   trendType === 'CRECIENTE' ? `Mantener uso de '${keyword}' - tendencia creciente` :\n                   trendType === 'DECRECIENTE' ? `Reducir uso de '${keyword}' - tendencia decreciente` :\n                   trendType === 'DECLINANTE' ? `Evitar '${keyword}' - en declive` :\n                   `Monitorear '${keyword}' - tendencia estable`\n  });\n});\n\n// Ordenar por engagement promedio\ntrends.sort((a, b) => b.avgEngagement - a.avgEngagement);\n\n// Identificar tendencias emergentes y declinantes\nconst emerging = trends.filter(t => t.trendType === 'EMERGENTE').slice(0, 5);\nconst declining = trends.filter(t => t.trendType === 'DECLINANTE').slice(0, 5);\n\n// Recomendaciones estratégicas\nconst strategicRecommendations = [];\nif (emerging.length > 0) {\n  const bestEmerging = emerging[0];\n  strategicRecommendations.push({\n    type: 'OPORTUNIDAD',\n    priority: 'Alta',\n    description: `Palabra clave '${bestEmerging.keyword}' está emergiendo con alto engagement (${bestEmerging.avgEngagement.toFixed(0)})`,\n    action: `Incrementar uso de '${bestEmerging.keyword}' en próximas publicaciones`\n  });\n}\n\nif (declining.length > 0) {\n  strategicRecommendations.push({\n    type: 'ADVERTENCIA',\n    priority: 'Media',\n    description: `Palabras clave en declive: ${declining.slice(0, 3).map(t => t.keyword).join(', ')}`,\n    action: 'Considerar reducir uso o buscar alternativas'\n  });\n}\n\nreturn [{\n  json: {\n    ...data,\n    marketTrends: {\n      totalKeywords: trends.length,\n      emergingTrends: emerging.length,\n      decliningTrends: declining.length,\n      trends: trends.slice(0, 15),\n      topEmerging: emerging,\n      topDeclining: declining,\n      strategicRecommendations: strategicRecommendations\n    }\n  }\n}];"
    },
    "id": "market-trends",
    "name": "Market Trends Analysis",
    "type": "n8n-nodes-base.code",
    "typeVersion": 2,
    "position": [1650, 2800],
    "notes": "Análisis avanzado de tendencias de mercado",
    "continueOnFail": true
  },
  {
    "parameters": {
      "jsCode": "// Análisis de Sentimiento Avanzado\nconst data = $json;\nconst posts = data.postsByType ? Object.values(data.postsByType).flatMap(type => type.posts || []) : [];\n\nif (posts.length < 5) {\n  return [{\n    json: {\n      ...data,\n      sentimentAnalysis: null\n    }\n  }];\n}\n\n// Palabras positivas y negativas\nconst positiveWords = ['excelente', 'genial', 'bueno', 'mejor', 'increíble', 'fantástico', 'perfecto', 'amor', 'feliz', 'éxito', 'ganar', 'victoria', 'satisfecho', 'recomendar', 'impresionante'];\nconst negativeWords = ['malo', 'terrible', 'horrible', 'odio', 'triste', 'decepcionado', 'problema', 'error', 'fallo', 'fracaso', 'pérdida', 'mal', 'peor', 'insatisfecho', 'queja'];\n\nconst sentimentResults = [];\n\nposts.slice(0, 20).forEach(post => {\n  const text = ((post.article_title || '') + ' ' + (post.content || '')).toLowerCase();\n  \n  // Contar palabras positivas y negativas\n  const positives = positiveWords.filter(word => text.includes(word)).length;\n  const negatives = negativeWords.filter(word => text.includes(word)).length;\n  \n  const total = positives + negatives;\n  let sentimentScore = 0;\n  let sentiment = 'NEUTRAL';\n  \n  if (total > 0) {\n    sentimentScore = ((positives - negatives) / total) * 100;\n    if (sentimentScore > 30) {\n      sentiment = 'POSITIVO';\n    } else if (sentimentScore < -30) {\n      sentiment = 'NEGATIVO';\n    }\n  }\n  \n  const confidence = Math.min(100, Math.abs(sentimentScore) + 50);\n  \n  // Análisis por aspectos\n  const aspects = [];\n  \n  // Aspecto: Calidad\n  if (text.includes('calidad') || text.includes('bueno') || text.includes('excelente') || text.includes('malo')) {\n    const qualityPositive = ['calidad', 'bueno', 'excelente'].some(w => text.includes(w));\n    const qualityNegative = ['malo', 'terrible'].some(w => text.includes(w));\n    aspects.push({\n      aspect: 'calidad',\n      mentioned: true,\n      sentiment: qualityPositive && !qualityNegative ? 'POSITIVO' : qualityNegative ? 'NEGATIVO' : 'NEUTRAL'\n    });\n  }\n  \n  // Aspecto: Precio\n  if (text.includes('precio') || text.includes('caro') || text.includes('barato') || text.includes('costoso')) {\n    const pricePositive = ['barato', 'económico'].some(w => text.includes(w));\n    const priceNegative = ['caro', 'costoso'].some(w => text.includes(w));\n    aspects.push({\n      aspect: 'precio',\n      mentioned: true,\n      sentiment: pricePositive && !priceNegative ? 'POSITIVO' : priceNegative ? 'NEGATIVO' : 'NEUTRAL'\n    });\n  }\n  \n  // Aspecto: Servicio\n  if (text.includes('servicio') || text.includes('atención') || text.includes('soporte') || text.includes('ayuda')) {\n    aspects.push({\n      aspect: 'servicio',\n      mentioned: true,\n      sentiment: 'NEUTRAL' // Simplificado\n    });\n  }\n  \n  sentimentResults.push({\n    post_id: post.post_id,\n    title: (post.article_title || post.content || '').substring(0, 100),\n    sentiment: sentiment,\n    sentimentScore: Math.round(sentimentScore * 10) / 10,\n    confidence: Math.round(confidence),\n    positiveWords: positives,\n    negativeWords: negatives,\n    aspects: aspects\n  });\n});\n\n// Estadísticas generales\nconst totalPositive = sentimentResults.filter(r => r.sentiment === 'POSITIVO').length;\nconst totalNegative = sentimentResults.filter(r => r.sentiment === 'NEGATIVO').length;\nconst totalNeutral = sentimentResults.filter(r => r.sentiment === 'NEUTRAL').length;\nconst avgSentimentScore = sentimentResults.reduce((sum, r) => sum + r.sentimentScore, 0) / sentimentResults.length;\n\n// Análisis por aspectos\nconst aspectAnalysis = {};\nsentimentResults.forEach(result => {\n  result.aspects.forEach(aspect => {\n    if (!aspectAnalysis[aspect.aspect]) {\n      aspectAnalysis[aspect.aspect] = { positive: 0, negative: 0, neutral: 0, total: 0 };\n    }\n    aspectAnalysis[aspect.aspect].total++;\n    if (aspect.sentiment === 'POSITIVO') aspectAnalysis[aspect.aspect].positive++;\n    else if (aspect.sentiment === 'NEGATIVO') aspectAnalysis[aspect.aspect].negative++;\n    else aspectAnalysis[aspect.aspect].neutral++;\n  });\n});\n\nreturn [{\n  json: {\n    ...data,\n    sentimentAnalysis: {\n      totalAnalyzed: sentimentResults.length,\n      positiveCount: totalPositive,\n      negativeCount: totalNegative,\n      neutralCount: totalNeutral,\n      positivePercentage: ((totalPositive / sentimentResults.length) * 100).toFixed(1),\n      avgSentimentScore: Math.round(avgSentimentScore * 10) / 10,\n      overallSentiment: avgSentimentScore > 20 ? 'POSITIVO' : avgSentimentScore < -20 ? 'NEGATIVO' : 'NEUTRAL',\n      aspectAnalysis: aspectAnalysis,\n      topResults: sentimentResults.slice(0, 5)\n    }\n  }\n}];"
    },
    "id": "sentiment-analysis",
    "name": "Advanced Sentiment Analysis",
    "type": "n8n-nodes-base.code",
    "typeVersion": 2,
    "position": [1650, 3000],
    "notes": "Análisis avanzado de sentimiento con NLP",
    "continueOnFail": true
  },
  {
    "parameters": {
      "jsCode": "// ROI Predictivo Avanzado\nconst data = $json;\n\nif (!data.postsByType || !data.roi) {\n  return [{\n    json: {\n      ...data,\n      predictiveROI: null\n    }\n  }];\n}\n\n// Obtener ROI actual\nconst currentROI = data.roi;\n\n// Proyecciones futuras (6 meses)\nconst projections = [];\nconst months = 6;\n\n// Calcular tendencia de engagement\nlet engagementTrend = 'stable';\nlet trendMultiplier = 1.0;\n\nif (data.predictions && data.predictions.byType) {\n  const bestType = data.bestContentType;\n  if (bestType && data.predictions.byType[bestType]) {\n    const prediction = data.predictions.byType[bestType];\n    engagementTrend = prediction.trend;\n    if (prediction.trend === 'increasing') {\n      trendMultiplier = 1.1; // +10% por mes\n    } else if (prediction.trend === 'decreasing') {\n      trendMultiplier = 0.95; // -5% por mes\n    }\n  }\n}\n\n// Generar proyecciones mensuales\nfor (let month = 1; month <= months; month++) {\n  const baseROI = currentROI.roiPromedio || 0;\n  const projectedROI = baseROI * Math.pow(trendMultiplier, month);\n  \n  const date = new Date();\n  date.setMonth(date.getMonth() + month);\n  \n  projections.push({\n    month: month,\n    date: date.toISOString().split('T')[0],\n    projectedROI: Math.round(projectedROI * 10) / 10,\n    engagementMultiplier: Math.pow(trendMultiplier, month),\n    confidence: month <= 2 ? 'high' : month <= 4 ? 'medium' : 'low'\n  });\n}\n\n// Calcular ROI promedio proyectado\nconst avgProjectedROI = projections.reduce((sum, p) => sum + p.projectedROI, 0) / projections.length;\n\n// Determinar tendencia de ROI\nlet roiTrend = 'stable';\nif (projections.length >= 2) {\n  const firstROI = projections[0].projectedROI;\n  const lastROI = projections[projections.length - 1].projectedROI;\n  const change = lastROI - firstROI;\n  if (change > 5) {\n    roiTrend = 'creciente';\n  } else if (change < -5) {\n    roiTrend = 'decreciente';\n  }\n}\n\n// Recomendaciones de inversión\nconst investmentRecommendations = [];\n\nif (avgProjectedROI > (currentROI.roiPromedio || 0)) {\n  investmentRecommendations.push({\n    type: 'AUMENTAR_INVERSION',\n    priority: 'Alta',\n    description: `ROI proyectado (${avgProjectedROI.toFixed(1)}%) es mejor que actual (${(currentROI.roiPromedio || 0).toFixed(1)}%)`,\n    action: 'Considerar aumentar inversión en contenido'\n  });\n} else if (avgProjectedROI < (currentROI.roiPromedio || 0)) {\n  investmentRecommendations.push({\n    type: 'OPTIMIZAR_INVERSION',\n    priority: 'Media',\n    description: `ROI proyectado (${avgProjectedROI.toFixed(1)}%) es menor que actual`,\n    action: 'Optimizar estrategia antes de aumentar inversión'\n  });\n}\n\n// Calcular break-even proyectado\nlet breakEven = null;\nfor (const proj of projections) {\n  if (proj.projectedROI > 0 && !breakEven) {\n    breakEven = {\n      month: proj.month,\n      date: proj.date,\n      roi: proj.projectedROI\n    };\n    break;\n  }\n}\n\nreturn [{\n  json: {\n    ...data,\n    predictiveROI: {\n      currentROI: currentROI.roiPromedio || 0,\n      avgProjectedROI: Math.round(avgProjectedROI * 10) / 10,\n      roiTrend: roiTrend,\n      engagementTrend: engagementTrend,\n      projections: projections,\n      breakEven: breakEven,\n      investmentRecommendations: investmentRecommendations\n    }\n  }\n}];"
    },
    "id": "predictive-roi",
    "name": "Predictive ROI Analysis",
    "type": "n8n-nodes-base.code",
    "typeVersion": 2,
    "position": [1650, 3200],
    "notes": "Análisis de ROI predictivo avanzado",
    "continueOnFail": true
  },
  {
    "parameters": {
      "jsCode": "// Análisis Cross-Platform Avanzado\nconst data = $json;\n\nif (!data.platformStats || Object.keys(data.platformStats).length < 2) {\n  return [{\n    json: {\n      ...data,\n      crossPlatformAnalysis: null\n    }\n  }];\n}\n\nconst platforms = Object.keys(data.platformStats);\nconst platformAnalyses = [];\n\nplatforms.forEach(platform => {\n  const stats = data.platformStats[platform];\n  const posts = data.postsByType ? Object.values(data.postsByType).flatMap(type => \n    (type.posts || []).filter(p => p.platform === platform)\n  ) : [];\n  \n  const viralPosts = posts.filter(p => {\n    const rate = p.engagementRate || 0;\n    const total = p.totalEngagement || 0;\n    return rate > 10 && total > 500;\n  });\n  \n  platformAnalyses.push({\n    platform: platform,\n    totalPosts: stats.totalPosts || 0,\n    avgEngagement: stats.avgEngagementPerPost || 0,\n    avgEngagementRate: stats.avgEngagementRate || 0,\n    viralRate: posts.length > 0 ? ((viralPosts.length / posts.length) * 100).toFixed(2) : 0,\n    totalViralPosts: viralPosts.length\n  });\n});\n\n// Identificar mejor plataforma\nconst bestPlatform = platformAnalyses.reduce((best, current) => \n  current.avgEngagement > best.avgEngagement ? current : best\n);\n\n// Oportunidades cross-platform\nconst opportunities = [];\n\nplatformAnalyses.forEach(platform => {\n  if (platform.platform !== bestPlatform.platform) {\n    const difference = bestPlatform.avgEngagement - platform.avgEngagement;\n    if (difference > 50) {\n      opportunities.push({\n        type: 'MEJORAR_PLATAFORMA',\n        platform: platform.platform,\n        description: `${platform.platform} tiene ${difference.toFixed(1)} puntos menos que ${bestPlatform.platform}`,\n        impact: 'Alto',\n        action: `Optimizar estrategia en ${platform.platform}`,\n        potentialGain: difference.toFixed(0)\n      });\n    }\n  }\n});\n\n// Estrategia cross-platform\nlet strategy = 'No hay suficientes datos para recomendación';\nif (bestPlatform) {\n  strategy = `Enfocarse en ${bestPlatform.platform} como plataforma principal (engagement promedio: ${bestPlatform.avgEngagement.toFixed(1)}), replicar estrategia exitosa en otras plataformas`;\n}\n\n// Análisis de distribución\nconst totalPostsAll = platformAnalyses.reduce((sum, p) => sum + p.totalPosts, 0);\nconst distribution = platformAnalyses.map(p => ({\n  platform: p.platform,\n  percentage: totalPostsAll > 0 ? ((p.totalPosts / totalPostsAll) * 100).toFixed(1) : 0,\n  avgEngagement: p.avgEngagement\n}));\n\nreturn [{\n  json: {\n    ...data,\n    crossPlatformAnalysis: {\n      platformsAnalyzed: platformAnalyses.length,\n      platformAnalyses: platformAnalyses,\n      bestPlatform: bestPlatform,\n      opportunities: opportunities,\n      strategy: strategy,\n      distribution: distribution,\n      recommendations: opportunities.length > 0 ? opportunities.slice(0, 3) : []\n    }\n  }\n}];"
    },
    "id": "cross-platform",
    "name": "Cross-Platform Analysis",
    "type": "n8n-nodes-base.code",
    "typeVersion": 2,
    "position": [1650, 3400],
    "notes": "Análisis cross-platform avanzado",
    "continueOnFail": true
  }
]

