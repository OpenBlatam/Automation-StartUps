{
  "name": "AI Video Pipeline - Descubrir y Generar PDFs de Replicación",
  "nodes": [
    {
      "parameters": {
        "cronExpression": "0 9 * * 1",
        "timezone": "UTC"
      },
      "id": "schedule-trigger",
      "name": "Schedule Trigger - Semanal Lunes 9AM",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1,
      "position": [250, 300],
      "notes": "Ejecuta cada lunes a las 9:00 AM para descubrir videos de la semana anterior"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ai-video-pipeline",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger - Ejecución Manual",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [250, 500],
      "webhookId": "ai-video-pipeline-webhook",
      "notes": "Permite ejecutar el pipeline manualmente vía webhook"
    },
    {
      "parameters": {
        "jsCode": "// Inicializar variables del workflow con validación mejorada\nconst maxVideos = parseInt($env.MAX_VIDEOS || '10');\nconst daysBack = parseInt($env.DAYS_BACK || '7');\nconst languages = ($env.LANGUAGES || 'en,pt,fr,de,it,ja,ko,zh').split(',').map(l => l.trim()).filter(l => l);\nconst outputDir = $env.OUTPUT_DIR || './ai_video_outputs';\nconst executionId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\nconst maxRetries = parseInt($env.MAX_RETRIES || '3');\nconst enableCache = $env.ENABLE_CACHE !== 'false';\nconst enableEmail = !!($env.SMTP_HOST && $env.EMAIL_TO);\nconst enableWebhooks = !!($env.WEBHOOK_URL);\nconst batchSize = parseInt($env.BATCH_SIZE || '3');\nconst minVideoQuality = parseInt($env.MIN_VIDEO_QUALITY || '1000'); // Likes mínimos\nconst minTranscriptQuality = parseFloat($env.MIN_TRANSCRIPT_QUALITY || '0.7'); // 0-1\nconst enableHealthCheck = $env.ENABLE_HEALTH_CHECK !== 'false';\nconst enableCloudStorage = !!($env.S3_BUCKET || $env.GCS_BUCKET);\nconst enableParallelProcessing = $env.ENABLE_PARALLEL !== 'false';\nconst maxConcurrent = parseInt($env.MAX_CONCURRENT || '3');\nconst enablePriorityQueue = $env.ENABLE_PRIORITY_QUEUE !== 'false';\nconst enableMetricsExport = $env.ENABLE_METRICS_EXPORT !== 'false';\nconst enableSmartAlerts = $env.ENABLE_SMART_ALERTS !== 'false';\nconst enableDatabase = !!($env.DB_HOST && $env.DB_NAME);\nconst enableCostTracking = $env.ENABLE_COST_TRACKING !== 'false';\nconst enableSlack = !!($env.SLACK_WEBHOOK_URL);\nconst enableDiscord = !!($env.DISCORD_WEBHOOK_URL);\nconst enableAutoReports = $env.ENABLE_AUTO_REPORTS !== 'false';\nconst enableRateLimiting = $env.ENABLE_RATE_LIMITING !== 'false';\nconst enableBackup = $env.ENABLE_BACKUP !== 'false';\nconst enableMLPrediction = $env.ENABLE_ML_PREDICTION !== 'false';\nconst enableTrendAnalysis = $env.ENABLE_TREND_ANALYSIS !== 'false';\nconst enableAutoOptimization = $env.ENABLE_AUTO_OPTIMIZATION !== 'false';\nconst enableAnomalyDetection = $env.ENABLE_ANOMALY_DETECTION !== 'false';\nconst enablePerformanceMonitoring = $env.ENABLE_PERF_MONITORING !== 'false';\nconst enableResourceOptimization = $env.ENABLE_RESOURCE_OPTIMIZATION !== 'false';\nconst enableAuditLogging = $env.ENABLE_AUDIT_LOGGING !== 'false';\nconst enableSecurityChecks = $env.ENABLE_SECURITY_CHECKS !== 'false';\nconst enableCompliance = $env.ENABLE_COMPLIANCE !== 'false';\nconst enablePredictiveAnalysis = $env.ENABLE_PREDICTIVE_ANALYSIS !== 'false';\nconst enableDashboard = $env.ENABLE_DASHBOARD !== 'false';\nconst enableAutoScaling = $env.ENABLE_AUTO_SCALING !== 'false';\nconst enableSocialMediaOptimization = $env.ENABLE_SOCIAL_MEDIA_OPT !== 'false';\nconst enableMultiPlatform = $env.ENABLE_MULTI_PLATFORM !== 'false';\nconst enableAutoScheduling = $env.ENABLE_AUTO_SCHEDULING !== 'false';\nconst enableCompetitorAnalysis = $env.ENABLE_COMPETITOR_ANALYSIS !== 'false';\nconst enableABTesting = $env.ENABLE_AB_TESTING !== 'false';\nconst enableContentExport = $env.ENABLE_CONTENT_EXPORT !== 'false';\nconst enableEngagementAnalysis = $env.ENABLE_ENGAGEMENT_ANALYSIS !== 'false';\nconst enableSentimentAnalysis = $env.ENABLE_SENTIMENT_ANALYSIS !== 'false';\nconst enableSEOAnalysis = $env.ENABLE_SEO_ANALYSIS !== 'false';\nconst enableThumbnailGeneration = $env.ENABLE_THUMBNAIL_GEN !== 'false';\nconst enablePerformanceTracking = $env.ENABLE_PERFORMANCE_TRACKING !== 'false';\nconst enableMultiVariant = $env.ENABLE_MULTI_VARIANT !== 'false';\nconst enableAdvancedRecommendations = $env.ENABLE_ADVANCED_RECOMMENDATIONS !== 'false';\nconst enableAutoPublishing = $env.ENABLE_AUTO_PUBLISHING !== 'false';\nconst enableRealTimeTrendAnalysis = $env.ENABLE_REALTIME_TREND_ANALYSIS !== 'false';\nconst enableContentGeneration = $env.ENABLE_CONTENT_GENERATION !== 'false';\nconst enableFeedbackLoop = $env.ENABLE_FEEDBACK_LOOP !== 'false';\nconst enableRealTimeDashboard = $env.ENABLE_REALTIME_DASHBOARD !== 'false';\nconst enableCompetitorMonitoring = $env.ENABLE_COMPETITOR_MONITORING !== 'false';\nconst enableDeepVideoAnalysis = $env.ENABLE_DEEP_VIDEO_ANALYSIS !== 'false';\nconst enableMLRecommendations = $env.ENABLE_ML_RECOMMENDATIONS !== 'false';\nconst enableAudienceAnalysis = $env.ENABLE_AUDIENCE_ANALYSIS !== 'false';\nconst enableContentVersioning = $env.ENABLE_CONTENT_VERSIONING !== 'false';\nconst enableAdvancedCostOptimization = $env.ENABLE_ADVANCED_COST_OPT !== 'false';\nconst enableIntelligentAlerts = $env.ENABLE_INTELLIGENT_ALERTS !== 'false';\nconst enableROIAnalysis = $env.ENABLE_ROI_ANALYSIS !== 'false';\nconst enableDesignIntegration = $env.ENABLE_DESIGN_INTEGRATION !== 'false';\nconst enableExecutiveReports = $env.ENABLE_EXECUTIVE_REPORTS !== 'false';\nconst enableCollaboration = $env.ENABLE_COLLABORATION !== 'false';\nconst enableAdvancedExport = $env.ENABLE_ADVANCED_EXPORT !== 'false';\nconst enableBusinessMetrics = $env.ENABLE_BUSINESS_METRICS !== 'false';\nconst enableAIVideoAnalysis = $env.ENABLE_AI_VIDEO_ANALYSIS !== 'false';\nconst enableSmartContentRecommendations = $env.ENABLE_SMART_CONTENT_RECOMMENDATIONS !== 'false';\nconst enableMultiPlatformIntegration = $env.ENABLE_MULTI_PLATFORM_INTEGRATION !== 'false';\nconst enableConversionAnalysis = $env.ENABLE_CONVERSION_ANALYSIS !== 'false';\nconst enableAdvancedABTesting = $env.ENABLE_ADVANCED_AB_TESTING !== 'false';\nconst enableCRMIntegration = $env.ENABLE_CRM_INTEGRATION !== 'false';\nconst enablePredictiveContent = $env.ENABLE_PREDICTIVE_CONTENT !== 'false';\nconst enableAdvancedSentiment = $env.ENABLE_ADVANCED_SENTIMENT !== 'false';\nconst enableAutoSubtitles = $env.ENABLE_AUTO_SUBTITLES !== 'false';\nconst enableCompetitorDeepAnalysis = $env.ENABLE_COMPETITOR_DEEP_ANALYSIS !== 'false';\nconst enablePersonalizedRecommendations = $env.ENABLE_PERSONALIZED_RECOMMENDATIONS !== 'false';\nconst enableAnalyticsIntegration = $env.ENABLE_ANALYTICS_INTEGRATION !== 'false';\nconst enableProactiveAlerts = $env.ENABLE_PROACTIVE_ALERTS !== 'false';\nconst enableVoiceToneAnalysis = $env.ENABLE_VOICE_TONE_ANALYSIS !== 'false';\nconst enableEmergingTrends = $env.ENABLE_EMERGING_TRENDS !== 'false';\nconst enableViralScoring = $env.ENABLE_VIRAL_SCORING !== 'false';\nconst enableMarketingIntegration = $env.ENABLE_MARKETING_INTEGRATION !== 'false';\n\n// Validar API keys\nconst hasOpenAI = !!($env.OPENAI_API_KEY);\nconst hasYouTube = !!($env.YOUTUBE_API_KEY);\n\nif (!hasOpenAI) {\n  return [{\n    json: {\n      error: 'OPENAI_API_KEY no configurada. Es requerida para transcripción y traducción.',\n      executionId,\n      canProceed: false\n    }\n  }];\n}\n\nreturn [{\n  json: {\n    maxVideos: maxVideos,\n    daysBack: daysBack,\n    languages: languages,\n    outputDir: outputDir,\n    startedAt: new Date().toISOString(),\n    executionId: executionId,\n    workflowVersion: '15.0',\n    hasOpenAI: hasOpenAI,\n    hasYouTube: hasYouTube,\n    maxRetries: maxRetries,\n    enableCache: enableCache,\n    enableEmail: enableEmail,\n    enableWebhooks: enableWebhooks,\n    batchSize: batchSize,\n    minVideoQuality: minVideoQuality,\n    minTranscriptQuality: minTranscriptQuality,\n    enableHealthCheck: enableHealthCheck,\n    enableCloudStorage: enableCloudStorage,\n    enableParallelProcessing: enableParallelProcessing,\n    maxConcurrent: maxConcurrent,\n    enablePriorityQueue: enablePriorityQueue,\n    enableMetricsExport: enableMetricsExport,\n    enableSmartAlerts: enableSmartAlerts,\n    enableDatabase: enableDatabase,\n    enableCostTracking: enableCostTracking,\n    enableSlack: enableSlack,\n    enableDiscord: enableDiscord,\n    enableAutoReports: enableAutoReports,\n    enableRateLimiting: enableRateLimiting,\n    enableBackup: enableBackup,\n    enableMLPrediction: enableMLPrediction,\n    enableTrendAnalysis: enableTrendAnalysis,\n    enableAutoOptimization: enableAutoOptimization,\n    enableAnomalyDetection: enableAnomalyDetection,\n    enablePerformanceMonitoring: enablePerformanceMonitoring,\n    enableResourceOptimization: enableResourceOptimization,\n    enableAuditLogging: enableAuditLogging,\n    enableSecurityChecks: enableSecurityChecks,\n    enableCompliance: enableCompliance,\n    enablePredictiveAnalysis: enablePredictiveAnalysis,\n    enableDashboard: enableDashboard,\n    enableAutoScaling: enableAutoScaling,\n    enableSocialMediaOptimization: enableSocialMediaOptimization,\n    enableMultiPlatform: enableMultiPlatform,\n    enableAutoScheduling: enableAutoScheduling,\n    enableCompetitorAnalysis: enableCompetitorAnalysis,\n    enableABTesting: enableABTesting,\n    enableContentExport: enableContentExport,\n    enableEngagementAnalysis: enableEngagementAnalysis,\n    enableSentimentAnalysis: enableSentimentAnalysis,\n    enableSEOAnalysis: enableSEOAnalysis,\n    enableThumbnailGeneration: enableThumbnailGeneration,\n    enablePerformanceTracking: enablePerformanceTracking,\n    enableMultiVariant: enableMultiVariant,\n    enableAdvancedRecommendations: enableAdvancedRecommendations,\n    enableAutoPublishing: enableAutoPublishing,\n    enableRealTimeTrendAnalysis: enableRealTimeTrendAnalysis,\n    enableContentGeneration: enableContentGeneration,\n    enableFeedbackLoop: enableFeedbackLoop,\n    enableRealTimeDashboard: enableRealTimeDashboard,\n    enableCompetitorMonitoring: enableCompetitorMonitoring,\n    enableDeepVideoAnalysis: enableDeepVideoAnalysis,\n    enableMLRecommendations: enableMLRecommendations,\n    enableAudienceAnalysis: enableAudienceAnalysis,\n    enableContentVersioning: enableContentVersioning,\n    enableAdvancedCostOptimization: enableAdvancedCostOptimization,\n    enableIntelligentAlerts: enableIntelligentAlerts,\n    enableROIAnalysis: enableROIAnalysis,\n    enableDesignIntegration: enableDesignIntegration,\n    enableExecutiveReports: enableExecutiveReports,\n    enableCollaboration: enableCollaboration,\n    enableAdvancedExport: enableAdvancedExport,\n    enableBusinessMetrics: enableBusinessMetrics,\n    enableAIVideoAnalysis: enableAIVideoAnalysis,\n    enableSmartContentRecommendations: enableSmartContentRecommendations,\n    enableMultiPlatformIntegration: enableMultiPlatformIntegration,\n    enableConversionAnalysis: enableConversionAnalysis,\n    enableAdvancedABTesting: enableAdvancedABTesting,\n    enableCRMIntegration: enableCRMIntegration,\n    enablePredictiveContent: enablePredictiveContent,\n    enableAdvancedSentiment: enableAdvancedSentiment,\n    enableAutoSubtitles: enableAutoSubtitles,\n    enableCompetitorDeepAnalysis: enableCompetitorDeepAnalysis,\n    enablePersonalizedRecommendations: enablePersonalizedRecommendations,\n    enableAnalyticsIntegration: enableAnalyticsIntegration,\n    enableProactiveAlerts: enableProactiveAlerts,\n    enableVoiceToneAnalysis: enableVoiceToneAnalysis,\n    enableEmergingTrends: enableEmergingTrends,\n    enableViralScoring: enableViralScoring,\n    enableMarketingIntegration: enableMarketingIntegration,\n    canProceed: true\n  }\n}];"
      },
      "id": "initialize-workflow",
      "name": "Initialize Workflow",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 400],
      "notes": "Inicializa variables del workflow con validación"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "itemValidation": "strict"
          },
          "conditions": [
            {
              "id": "can-proceed",
              "leftValue": "={{ $json.canProceed }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-can-proceed",
      "name": "Check Can Proceed",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [650, 400],
      "notes": "Verifica que se puedan ejecutar los scripts"
    },
    {
      "parameters": {
        "jsCode": "// Validar que los scripts existan\nconst fs = require('fs');\nconst path = require('path');\n\nconst scriptsDir = '/Users/adan/IA/scripts';\nconst requiredScripts = [\n  'ai_video_pipeline.py',\n  'ai_video_discoverer.py',\n  'video_transcript_extractor.py',\n  'pdf_replication_guide_generator.py'\n];\n\nconst missingScripts = [];\nconst existingScripts = [];\n\nrequiredScripts.forEach(script => {\n  const scriptPath = path.join(scriptsDir, script);\n  if (fs.existsSync(scriptPath)) {\n    existingScripts.push(script);\n  } else {\n    missingScripts.push(script);\n  }\n});\n\nif (missingScripts.length > 0) {\n  return [{\n    json: {\n      ...$input.item.json,\n      error: `Scripts faltantes: ${missingScripts.join(', ')}`,\n      missingScripts: missingScripts,\n      existingScripts: existingScripts,\n      scriptsValid: false\n    }\n  }];\n}\n\nreturn [{\n  json: {\n    ...$input.item.json,\n    scriptsValid: true,\n    existingScripts: existingScripts\n  }\n}];"
      },
      "id": "validate-scripts",
      "name": "Validate Scripts Exist",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 300],
      "notes": "Valida que todos los scripts necesarios existan"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "itemValidation": "strict"
          },
          "conditions": [
            {
              "id": "scripts-valid",
              "leftValue": "={{ $json.scriptsValid }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-scripts-valid",
      "name": "Check Scripts Valid",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1050, 300],
      "notes": "Verifica que los scripts sean válidos"
    },
    {
      "parameters": {
        "jsCode": "// Verificar cache de videos procesados\nconst fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\n\nconst outputDir = $json.outputDir || './ai_video_outputs';\nconst cacheFile = path.join(outputDir, 'processed_videos_cache.json');\nconst enableCache = $json.enableCache !== false;\n\n// Cargar cache si existe\nlet cache = {};\nif (enableCache && fs.existsSync(cacheFile)) {\n  try {\n    cache = JSON.parse(fs.readFileSync(cacheFile, 'utf-8'));\n  } catch (e) {\n    cache = {};\n  }\n}\n\n// Limpiar cache antiguo (más de 30 días)\nconst thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);\nObject.keys(cache).forEach(key => {\n  if (cache[key].processedAt < thirtyDaysAgo) {\n    delete cache[key];\n  }\n});\n\nreturn [{\n  json: {\n    ...$input.item.json,\n    cache: cache,\n    cacheFile: cacheFile,\n    cacheEnabled: enableCache\n  }\n}];"
      },
      "id": "check-cache",
      "name": "Check Video Cache",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1250, 300],
      "notes": "Verifica cache de videos ya procesados"
    },
    {
      "parameters": {
        "jsCode": "// Health Check de APIs y servicios\nconst now = Date.now();\nconst HEALTH_CHECK_INTERVAL = 10 * 60 * 1000; // 10 minutos\n\nconst apiHealth = $workflow.staticData.apiHealth || {\n  youtube: { status: 'unknown', lastCheck: 0, failures: 0, successes: 0, responseTime: 0 },\n  openai: { status: 'unknown', lastCheck: 0, failures: 0, successes: 0, responseTime: 0 }\n};\n\n// Verificar salud de YouTube API\nif ($json.hasYouTube && (now - apiHealth.youtube.lastCheck > HEALTH_CHECK_INTERVAL)) {\n  // Simular health check (en producción harías un request real)\n  apiHealth.youtube.lastCheck = now;\n  apiHealth.youtube.status = 'healthy'; // Asumir saludable por ahora\n}\n\n// Verificar salud de OpenAI API\nif ($json.hasOpenAI && (now - apiHealth.openai.lastCheck > HEALTH_CHECK_INTERVAL)) {\n  apiHealth.openai.lastCheck = now;\n  apiHealth.openai.status = 'healthy';\n}\n\n// Calcular scores de salud\nObject.keys(apiHealth).forEach(key => {\n  const health = apiHealth[key];\n  const total = health.successes + health.failures;\n  if (total > 0) {\n    const successRate = health.successes / total;\n    if (successRate < 0.5) health.status = 'unhealthy';\n    else if (successRate < 0.8) health.status = 'degraded';\n    else health.status = 'healthy';\n  }\n});\n\n$workflow.staticData.apiHealth = apiHealth;\n\nreturn [{\n  json: {\n    ...$input.item.json,\n    apiHealth: apiHealth,\n    allApisHealthy: Object.values(apiHealth).every(h => h.status === 'healthy' || h.status === 'unknown')\n  }\n}];"
      },
      "id": "health-check",
      "name": "Health Check APIs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1450, 200],
      "notes": "Verifica salud de APIs y servicios"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "itemValidation": "strict"
          },
          "conditions": [
            {
              "id": "apis-healthy",
              "leftValue": "={{ $json.allApisHealthy }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-apis-healthy",
      "name": "Check APIs Healthy",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1650, 200],
      "notes": "Verifica que las APIs estén saludables"
    },
    {
      "parameters": {
        "command": "cd /Users/adan/IA/scripts && python3 ai_video_pipeline.py --max-videos {{ $json.maxVideos }} --days-back {{ $json.daysBack }} --output-dir {{ $json.outputDir }} --youtube-api-key \"{{ $env.YOUTUBE_API_KEY || '' }}\" --openai-api-key \"{{ $env.OPENAI_API_KEY }}\"",
        "options": {
          "timeout": 3600000
        }
      },
      "id": "run-pipeline",
      "name": "Run AI Video Pipeline",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1450, 300],
      "notes": "Ejecuta el pipeline completo de videos de IA (timeout: 1 hora)",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Retry con exponential backoff\nconst MAX_RETRIES = $json.maxRetries || 3;\nconst BASE_DELAY = 5000; // 5 segundos\nconst MAX_DELAY = 300000; // 5 minutos\n\nconst retryHistory = $workflow.staticData.retryHistory || {};\nconst executionId = $json.executionId || 'unknown';\nconst retryInfo = retryHistory[executionId] || {\n  attempts: 0,\n  lastAttempt: null,\n  errors: []\n};\n\n// Verificar si necesita retry\nconst needsRetry = ($json.error || $json.pipelineSuccess === false) && retryInfo.attempts < MAX_RETRIES;\n\nif (needsRetry) {\n  retryInfo.attempts++;\n  retryInfo.lastAttempt = Date.now();\n  if ($json.error) retryInfo.errors.push($json.error);\n  \n  // Calcular delay exponencial con jitter\n  const delay = Math.min(\n    BASE_DELAY * Math.pow(2, retryInfo.attempts - 1),\n    MAX_DELAY\n  );\n  const jitter = delay * 0.2 * Math.random();\n  const finalDelay = Math.floor(delay + jitter);\n  \n  retryInfo.nextRetryDelay = finalDelay;\n  retryHistory[executionId] = retryInfo;\n  $workflow.staticData.retryHistory = retryHistory;\n  \n  return [{\n    json: {\n      ...$input.item.json,\n      shouldRetry: true,\n      retryAttempt: retryInfo.attempts,\n      retryDelay: finalDelay,\n      maxRetries: MAX_RETRIES\n    }\n  }];\n}\n\n// Limpiar cache de retry si fue exitoso\nif ($json.pipelineSuccess !== false && retryInfo.attempts > 0) {\n  delete retryHistory[executionId];\n  $workflow.staticData.retryHistory = retryHistory;\n}\n\nreturn [{\n  json: {\n    ...$input.item.json,\n    shouldRetry: false,\n    retryAttempt: retryInfo.attempts\n  }\n}];"
      },
      "id": "check-retry",
      "name": "Check Retry Needed",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1650, 300],
      "notes": "Verifica si se necesita retry con exponential backoff"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "itemValidation": "strict"
          },
          "conditions": [
            {
              "id": "should-retry",
              "leftValue": "={{ $json.shouldRetry }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-should-retry",
      "name": "Check Should Retry",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1850, 300],
      "notes": "Decide si hacer retry"
    },
    {
      "parameters": {
        "mode": "wait",
        "amount": "={{ $json.retryDelay || 5000 }}",
        "unit": "milliseconds"
      },
      "id": "wait-retry",
      "name": "Wait Before Retry",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1,
      "position": [2050, 300],
      "notes": "Espera antes de reintentar"
    },
    {
      "parameters": {
        "jsCode": "// Verificar si el comando fue exitoso y leer el resumen\nconst fs = require('fs');\nconst path = require('path');\n\n// Obtener datos del contexto del workflow\nconst allInputs = $input.all();\nconst initData = allInputs.find(item => item.json.executionId)?.json || allInputs[0]?.json || {};\nconst outputDir = initData.outputDir || './ai_video_outputs';\nconst executionId = initData.executionId || 'unknown';\nconst summaryFile = path.join(outputDir, 'pipeline_summary.json');\n\n// Verificar si hubo error en la ejecución\nif ($json.error || $json.stderr) {\n  return [{\n    json: {\n      ...initData,\n      error: $json.error || $json.stderr || 'Error desconocido en la ejecución',\n      summaryFile: summaryFile,\n      pipelineSuccess: false,\n      executionId: executionId\n    }\n  }];\n}\n\ntry {\n  // Intentar leer el archivo directamente\n  if (fs.existsSync(summaryFile)) {\n    const summaryData = JSON.parse(fs.readFileSync(summaryFile, 'utf-8'));\n    return [{\n      json: {\n        ...summaryData,\n        ...initData,\n        summaryFile: summaryFile,\n        pipelineSuccess: true,\n        executionId: executionId,\n        minVideoQuality: initData.minVideoQuality,\n        minTranscriptQuality: initData.minTranscriptQuality\n      }\n    }];\n  } else {\n    return [{\n      json: {\n        ...initData,\n        error: 'Summary file not found after execution',\n        summaryFile: summaryFile,\n        pipelineSuccess: false,\n        executionId: executionId\n      }\n    }];\n  }\n} catch (e) {\n  return [{\n    json: {\n      ...initData,\n      error: `Error reading summary: ${e.message}`,\n      summaryFile: summaryFile,\n      pipelineSuccess: false,\n      executionId: executionId\n    }\n  }];\n}"
      },
      "id": "load-summary",
      "name": "Load Pipeline Summary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1650, 500],
      "notes": "Carga el resumen del procesamiento con manejo de errores"
    },
    {
      "parameters": {
        "jsCode": "// Validar calidad de transcripciones y filtrar videos\nconst summary = $json;\nconst minQuality = summary.minVideoQuality || parseInt($env.MIN_VIDEO_QUALITY || '1000');\nconst minTranscriptQuality = summary.minTranscriptQuality || parseFloat($env.MIN_TRANSCRIPT_QUALITY || '0.7');\n\n// Filtrar videos por calidad\nif (summary.outputs && summary.outputs.length > 0) {\n  const filteredOutputs = summary.outputs.filter(video => {\n    // Filtrar por likes mínimos\n    const likes = video.like_count || 0;\n    if (likes < minQuality) return false;\n    \n    // Filtrar por calidad de transcripción si está disponible\n    if (video.transcriptQuality !== undefined && video.transcriptQuality < minTranscriptQuality) {\n      return false;\n    }\n    \n    return true;\n  });\n  \n  const filteredCount = summary.outputs.length - filteredOutputs.length;\n  \n  return [{\n    json: {\n      ...summary,\n      outputs: filteredOutputs,\n      filteredVideos: filteredCount,\n      qualityFiltered: filteredCount > 0\n    }\n  }];\n}\n\nreturn [$input.item];"
      },
      "id": "filter-quality",
      "name": "Filter by Quality",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1850, 500],
      "notes": "Filtra videos por calidad y validación"
    },
    {
      "parameters": {
        "jsCode": "// Calcular métricas en tiempo real\nconst summary = $json;\nconst executionId = summary.executionId || 'unknown';\nconst startTime = summary.startedAt ? new Date(summary.startedAt) : new Date();\nconst endTime = new Date();\nconst duration = (endTime - startTime) / 1000; // segundos\n\nconst videosProcessed = summary.videos_processed || 0;\nconst videosDiscovered = summary.videos_discovered || 0;\nconst pdfsGenerated = summary.pdfs_generated || 0;\nconst errorsCount = summary.errors?.length || 0;\n\nconst metrics = {\n  executionId: executionId,\n  duration: duration,\n  durationFormatted: `${Math.floor(duration / 60)}m ${Math.floor(duration % 60)}s`,\n  videosPerMinute: duration > 0 ? ((videosProcessed / (duration / 60)).toFixed(2)) : '0',\n  pdfsPerMinute: duration > 0 ? ((pdfsGenerated / (duration / 60)).toFixed(2)) : '0',\n  successRate: videosDiscovered > 0 ? \n    ((videosProcessed / videosDiscovered) * 100).toFixed(2) + '%' : '0%',\n  errorRate: videosDiscovered > 0 ? \n    ((errorsCount / videosDiscovered) * 100).toFixed(2) + '%' : '0%',\n  avgProcessingTime: videosProcessed > 0 ? \n    (duration / videosProcessed).toFixed(2) + 's' : '0s'\n};\n\nreturn [{\n  json: {\n    ...summary,\n    metrics: metrics\n  }\n}];"
      },
      "id": "calculate-metrics",
      "name": "Calculate Real-time Metrics",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2050, 500],
      "notes": "Calcula métricas en tiempo real del procesamiento"
    },
    {
      "parameters": {
        "jsCode": "// Priorizar videos por calidad y popularidad\nconst summary = $json;\nconst enablePriority = summary.enablePriorityQueue !== false;\n\nif (!enablePriority || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\n// Calcular score de prioridad para cada video\nconst prioritizedOutputs = summary.outputs.map(video => {\n  const likes = video.like_count || 0;\n  const views = video.view_count || 0;\n  const age = video.published_at ? (Date.now() - new Date(video.published_at).getTime()) / (1000 * 60 * 60 * 24) : 7;\n  \n  // Score basado en engagement (likes + views) y frescura\n  const engagementScore = (likes * 2) + (views / 1000);\n  const freshnessScore = Math.max(0, 7 - age); // Más puntos si es más reciente\n  const priorityScore = engagementScore + (freshnessScore * 100);\n  \n  return {\n    ...video,\n    priorityScore: priorityScore,\n    engagementScore: engagementScore,\n    freshnessScore: freshnessScore\n  };\n});\n\n// Ordenar por prioridad (mayor score primero)\nprioritizedOutputs.sort((a, b) => b.priorityScore - a.priorityScore);\n\nreturn [{\n  json: {\n    ...summary,\n    outputs: prioritizedOutputs,\n    prioritized: true,\n    topVideo: prioritizedOutputs[0] || null\n  }\n}];"
      },
      "id": "prioritize-videos",
      "name": "Prioritize Videos",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2250, 500],
      "notes": "Prioriza videos por calidad y popularidad"
    },
    {
      "parameters": {
        "jsCode": "// Preparar upload a cloud storage (S3/GCS)\nconst summary = $json;\nconst enableCloud = summary.enableCloudStorage !== false;\n\nif (!enableCloud || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\nconst cloudType = $env.CLOUD_STORAGE_TYPE || ($env.S3_BUCKET ? 's3' : 'gcs');\nconst bucket = $env.S3_BUCKET || $env.GCS_BUCKET || '';\nconst basePath = $env.CLOUD_STORAGE_PATH || 'ai-video-pipeline';\nconst date = new Date().toISOString().split('T')[0];\n\n// Preparar rutas de cloud para cada PDF generado\nconst cloudUploads = summary.outputs.map(video => {\n  const videoId = video.video_id || 'unknown';\n  const pdfFile = video.pdfFile || '';\n  \n  if (!pdfFile) return null;\n  \n  const fileName = pdfFile.split('/').pop() || `replication_guide_${videoId}.pdf`;\n  const cloudPath = `${basePath}/${date}/${fileName}`;\n  \n  return {\n    videoId: videoId,\n    localPath: pdfFile,\n    cloudPath: cloudPath,\n    cloudType: cloudType,\n    bucket: bucket,\n    readyForUpload: true\n  };\n}).filter(u => u !== null);\n\nreturn [{\n  json: {\n    ...summary,\n    cloudUploads: cloudUploads,\n    cloudStorageEnabled: enableCloud && cloudUploads.length > 0\n  }\n}];"
      },
      "id": "prepare-cloud-upload",
      "name": "Prepare Cloud Upload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2450, 500],
      "notes": "Prepara archivos para upload a cloud storage"
    },
    {
      "parameters": {
        "jsCode": "// Exportar métricas a formato estructurado\nconst summary = $json;\nconst metrics = summary.metrics || {};\nconst enableExport = summary.enableMetricsExport !== false;\n\nif (!enableExport) {\n  return [$input.item];\n}\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst outputDir = summary.outputDir || './ai_video_outputs';\nconst metricsFile = path.join(outputDir, `metrics_${summary.executionId || 'latest'}.json`);\n\nconst exportData = {\n  executionId: summary.executionId,\n  timestamp: new Date().toISOString(),\n  summary: {\n    videosDiscovered: summary.videos_discovered || 0,\n    videosProcessed: summary.videos_processed || 0,\n    pdfsGenerated: summary.pdfs_generated || 0,\n    errors: summary.errors?.length || 0,\n    filteredVideos: summary.filteredVideos || 0\n  },\n  metrics: metrics,\n  outputs: summary.outputs?.map(v => ({\n    id: v.video_id,\n    title: v.title,\n    url: v.url,\n    likes: v.like_count,\n    views: v.view_count,\n    priorityScore: v.priorityScore,\n    pdfFile: v.pdfFile\n  })) || [],\n  errors: summary.errors || [],\n  apiHealth: summary.apiHealth || {},\n  analytics: summary.analytics || {}\n};\n\ntry {\n  fs.mkdirSync(outputDir, { recursive: true });\n  fs.writeFileSync(metricsFile, JSON.stringify(exportData, null, 2), 'utf-8');\n  \n  return [{\n    json: {\n      ...summary,\n      metricsExported: true,\n      metricsFile: metricsFile\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      ...summary,\n      metricsExported: false,\n      metricsExportError: e.message\n    }\n  }];\n}"
      },
      "id": "export-metrics",
      "name": "Export Metrics",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2650, 500],
      "notes": "Exporta métricas a archivo JSON estructurado"
    },
    {
      "parameters": {
        "jsCode": "// Alertas inteligentes basadas en umbrales\nconst summary = $json;\nconst metrics = summary.metrics || {};\nconst enableAlerts = summary.enableSmartAlerts !== false;\n\nif (!enableAlerts) {\n  return [$input.item];\n}\n\nconst alerts = [];\nconst thresholds = {\n  minSuccessRate: parseFloat($env.MIN_SUCCESS_RATE || '0.8'), // 80%\n  maxErrorRate: parseFloat($env.MAX_ERROR_RATE || '0.2'), // 20%\n  minVideosProcessed: parseInt($env.MIN_VIDEOS_PROCESSED || '5'),\n  maxProcessingTime: parseInt($env.MAX_PROCESSING_TIME_MINUTES || '60')\n};\n\n// Calcular tasas\nconst successRate = parseFloat(metrics.successRate?.replace('%', '') || '0') / 100;\nconst errorRate = parseFloat(metrics.errorRate?.replace('%', '') || '0') / 100;\nconst durationMinutes = (metrics.duration || 0) / 60;\n\n// Verificar umbrales\nif (successRate < thresholds.minSuccessRate) {\n  alerts.push({\n    level: 'warning',\n    type: 'low_success_rate',\n    message: `Tasa de éxito baja: ${(successRate * 100).toFixed(2)}% (mínimo: ${thresholds.minSuccessRate * 100}%)`,\n    value: successRate,\n    threshold: thresholds.minSuccessRate\n  });\n}\n\nif (errorRate > thresholds.maxErrorRate) {\n  alerts.push({\n    level: 'error',\n    type: 'high_error_rate',\n    message: `Tasa de error alta: ${(errorRate * 100).toFixed(2)}% (máximo: ${thresholds.maxErrorRate * 100}%)`,\n    value: errorRate,\n    threshold: thresholds.maxErrorRate\n  });\n}\n\nif ((summary.videos_processed || 0) < thresholds.minVideosProcessed) {\n  alerts.push({\n    level: 'warning',\n    type: 'low_video_count',\n    message: `Pocos videos procesados: ${summary.videos_processed || 0} (mínimo: ${thresholds.minVideosProcessed})`,\n    value: summary.videos_processed || 0,\n    threshold: thresholds.minVideosProcessed\n  });\n}\n\nif (durationMinutes > thresholds.maxProcessingTime) {\n  alerts.push({\n    level: 'warning',\n    type: 'slow_processing',\n    message: `Procesamiento lento: ${durationMinutes.toFixed(2)} minutos (máximo: ${thresholds.maxProcessingTime})`,\n    value: durationMinutes,\n    threshold: thresholds.maxProcessingTime\n  });\n}\n\nreturn [{\n  json: {\n    ...summary,\n    alerts: alerts,\n    hasAlerts: alerts.length > 0,\n    criticalAlerts: alerts.filter(a => a.level === 'error').length\n  }\n}];"
      },
      "id": "smart-alerts",
      "name": "Smart Alerts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2850, 500],
      "notes": "Genera alertas inteligentes basadas en umbrales"
    },
    {
      "parameters": {
        "jsCode": "// Tracking de costos de procesamiento\nconst summary = $json;\nconst enableCost = summary.enableCostTracking !== false;\n\nif (!enableCost) {\n  return [$input.item];\n}\n\nconst COST_PER_VIDEO = {\n  discovery: parseFloat($env.COST_DISCOVERY || '0.001'),\n  transcription: parseFloat($env.COST_TRANSCRIPTION || '0.01'),\n  translation: parseFloat($env.COST_TRANSLATION || '0.005'),\n  pdfGeneration: parseFloat($env.COST_PDF || '0.002'),\n  cloudStorage: parseFloat($env.COST_CLOUD_STORAGE || '0.0001')\n};\n\nconst videosProcessed = summary.videos_processed || 0;\nconst pdfsGenerated = summary.pdfs_generated || 0;\n\nlet totalCost = 0;\nconst costBreakdown = {\n  discovery: videosProcessed * COST_PER_VIDEO.discovery,\n  transcription: videosProcessed * COST_PER_VIDEO.transcription,\n  translation: videosProcessed * COST_PER_VIDEO.translation,\n  pdfGeneration: pdfsGenerated * COST_PER_VIDEO.pdfGeneration,\n  cloudStorage: (summary.cloudUploads?.length || 0) * COST_PER_VIDEO.cloudStorage\n};\n\nObject.values(costBreakdown).forEach(cost => {\n  totalCost += cost;\n});\n\n// Obtener historial de costos\nconst costHistory = $workflow.staticData.costHistory || [];\nconst today = new Date().toISOString().split('T')[0];\n\nlet todayCost = costHistory.find(c => c.date === today);\nif (!todayCost) {\n  todayCost = {\n    date: today,\n    totalCost: 0,\n    executionCount: 0,\n    breakdown: {}\n  };\n  costHistory.push(todayCost);\n}\n\ntodayCost.totalCost += totalCost;\ntodayCost.executionCount++;\n\nObject.keys(costBreakdown).forEach(key => {\n  todayCost.breakdown[key] = (todayCost.breakdown[key] || 0) + costBreakdown[key];\n});\n\n// Mantener solo últimos 90 días\nconst cutoffDate = new Date();\ncutoffDate.setDate(cutoffDate.getDate() - 90);\nconst filteredHistory = costHistory.filter(c => new Date(c.date) >= cutoffDate);\n$workflow.staticData.costHistory = filteredHistory;\n\n// Calcular promedio diario\nconst avgDailyCost = costHistory.length > 0 ? \n  costHistory.reduce((sum, c) => sum + c.totalCost, 0) / costHistory.length : 0;\n\nreturn [{\n  json: {\n    ...summary,\n    cost: {\n      total: totalCost.toFixed(4),\n      breakdown: costBreakdown,\n      currency: 'USD',\n      dailyTotal: todayCost.totalCost.toFixed(4),\n      avgDaily: avgDailyCost.toFixed(4)\n    }\n  }\n}];"
      },
      "id": "track-costs",
      "name": "Track Costs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3050, 500],
      "notes": "Tracking de costos de procesamiento"
    },
    {
      "parameters": {
        "jsCode": "// Guardar en base de datos (PostgreSQL/MySQL)\nconst summary = $json;\nconst enableDB = summary.enableDatabase !== false;\n\nif (!enableDB) {\n  return [$input.item];\n}\n\n// Preparar registro para base de datos\nconst dbRecord = {\n  execution_id: summary.executionId,\n  started_at: summary.startedAt,\n  completed_at: new Date().toISOString(),\n  videos_discovered: summary.videos_discovered || 0,\n  videos_processed: summary.videos_processed || 0,\n  pdfs_generated: summary.pdfs_generated || 0,\n  errors_count: summary.errors?.length || 0,\n  success_rate: parseFloat(summary.metrics?.successRate?.replace('%', '') || '0') / 100,\n  duration_seconds: summary.metrics?.duration || 0,\n  cost_total: parseFloat(summary.cost?.total || '0'),\n  filtered_videos: summary.filteredVideos || 0,\n  alerts_count: summary.alerts?.length || 0,\n  outputs: JSON.stringify(summary.outputs || []),\n  errors: JSON.stringify(summary.errors || []),\n  metrics: JSON.stringify(summary.metrics || {}),\n  api_health: JSON.stringify(summary.apiHealth || {}),\n  workflow_version: summary.workflowVersion || '6.0'\n};\n\n// Guardar en static data (en producción sería INSERT a DB)\nconst dbRecords = $workflow.staticData.databaseRecords || [];\ndbRecords.push(dbRecord);\n\n// Mantener solo últimos 1000 registros\nif (dbRecords.length > 1000) {\n  dbRecords.shift();\n}\n\n$workflow.staticData.databaseRecords = dbRecords;\n\nreturn [{\n  json: {\n    ...summary,\n    databaseSaved: true,\n    dbRecord: dbRecord\n  }\n}];"
      },
      "id": "save-to-database",
      "name": "Save to Database",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3250, 500],
      "notes": "Guarda resultados en base de datos"
    },
    {
      "parameters": {
        "jsCode": "// Predicción de calidad con ML simple\nconst summary = $json;\nconst enableML = summary.enableMLPrediction !== false;\n\nif (!enableML || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\n// Modelo simple de predicción basado en características\nconst predictions = summary.outputs.map(video => {\n  const likes = video.like_count || 0;\n  const views = video.view_count || 0;\n  const age = video.published_at ? (Date.now() - new Date(video.published_at).getTime()) / (1000 * 60 * 60 * 24) : 7;\n  \n  // Features normalizadas\n  const normalizedLikes = Math.min(likes / 10000, 1);\n  const normalizedViews = Math.min(views / 100000, 1);\n  const normalizedFreshness = Math.max(0, 1 - (age / 30));\n  \n  // Score de predicción (modelo simple)\n  const predictionScore = (\n    normalizedLikes * 0.4 +\n    normalizedViews * 0.3 +\n    normalizedFreshness * 0.3\n  ) * 100;\n  \n  // Clasificación\n  let qualityClass = 'low';\n  if (predictionScore >= 70) qualityClass = 'high';\n  else if (predictionScore >= 40) qualityClass = 'medium';\n  \n  return {\n    ...video,\n    mlPrediction: {\n      score: predictionScore.toFixed(2),\n      qualityClass: qualityClass,\n      confidence: Math.min(predictionScore / 100, 1).toFixed(2),\n      features: {\n        likes: normalizedLikes.toFixed(2),\n        views: normalizedViews.toFixed(2),\n        freshness: normalizedFreshness.toFixed(2)\n      }\n    }\n  };\n});\n\nconst highQualityCount = predictions.filter(v => v.mlPrediction.qualityClass === 'high').length;\nconst avgPredictionScore = predictions.reduce((sum, v) => sum + parseFloat(v.mlPrediction.score), 0) / predictions.length;\n\nreturn [{\n  json: {\n    ...summary,\n    outputs: predictions,\n    mlPredictions: {\n      enabled: true,\n      highQualityCount: highQualityCount,\n      avgScore: avgPredictionScore.toFixed(2),\n      totalPredicted: predictions.length\n    }\n  }\n}];"
      },
      "id": "ml-prediction",
      "name": "ML Quality Prediction",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3450, 500],
      "notes": "Predicción de calidad con ML"
    },
    {
      "parameters": {
        "jsCode": "// Rate limiting inteligente\nconst summary = $json;\nconst enableRateLimit = summary.enableRateLimiting !== false;\n\nif (!enableRateLimit) {\n  return [$input.item];\n}\n\nconst rateLimits = $workflow.staticData.rateLimits || {\n  youtube: { requests: 0, resetAt: Date.now() + (60 * 60 * 1000) },\n  openai: { requests: 0, resetAt: Date.now() + (60 * 60 * 1000) }\n};\n\nconst now = Date.now();\nconst YOUTUBE_LIMIT = parseInt($env.YOUTUBE_RATE_LIMIT || '10000');\nconst OPENAI_LIMIT = parseInt($env.OPENAI_RATE_LIMIT || '50000');\nconst RESET_INTERVAL = 60 * 60 * 1000; // 1 hora\n\n// Reset si pasó el intervalo\nif (now > rateLimits.youtube.resetAt) {\n  rateLimits.youtube.requests = 0;\n  rateLimits.youtube.resetAt = now + RESET_INTERVAL;\n}\n\nif (now > rateLimits.openai.resetAt) {\n  rateLimits.openai.requests = 0;\n  rateLimits.openai.resetAt = now + RESET_INTERVAL;\n}\n\n// Calcular requests estimados para esta ejecución\nconst estimatedYouTubeRequests = summary.videos_discovered || 0;\nconst estimatedOpenAIRequests = (summary.videos_processed || 0) * 2; // transcripción + traducción\n\n// Verificar límites\nconst youtubeRemaining = YOUTUBE_LIMIT - rateLimits.youtube.requests;\nconst openaiRemaining = OPENAI_LIMIT - rateLimits.openai.requests;\n\nconst rateLimitStatus = {\n  youtube: {\n    used: rateLimits.youtube.requests,\n    limit: YOUTUBE_LIMIT,\n    remaining: youtubeRemaining,\n    estimated: estimatedYouTubeRequests,\n    willExceed: estimatedYouTubeRequests > youtubeRemaining\n  },\n  openai: {\n    used: rateLimits.openai.requests,\n    limit: OPENAI_LIMIT,\n    remaining: openaiRemaining,\n    estimated: estimatedOpenAIRequests,\n    willExceed: estimatedOpenAIRequests > openaiRemaining\n  }\n};\n\n$workflow.staticData.rateLimits = rateLimits;\n\nreturn [{\n  json: {\n    ...summary,\n    rateLimiting: rateLimitStatus,\n    rateLimitWarnings: Object.values(rateLimitStatus).filter(r => r.willExceed).length > 0\n  }\n}];"
      },
      "id": "rate-limiting",
      "name": "Rate Limiting",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3650, 500],
      "notes": "Rate limiting inteligente de APIs"
    },
    {
      "parameters": {
        "jsCode": "// Backup automático de resultados\nconst summary = $json;\nconst enableBackup = summary.enableBackup !== false;\n\nif (!enableBackup) {\n  return [$input.item];\n}\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst outputDir = summary.outputDir || './ai_video_outputs';\nconst backupDir = path.join(outputDir, 'backups');\nconst timestamp = new Date().toISOString().replace(/[:.]/g, '-');\nconst backupFile = path.join(backupDir, `backup_${summary.executionId || timestamp}.json`);\n\nconst backupData = {\n  executionId: summary.executionId,\n  timestamp: new Date().toISOString(),\n  summary: summary,\n  fullData: {\n    outputs: summary.outputs || [],\n    errors: summary.errors || [],\n    metrics: summary.metrics || {},\n    cost: summary.cost || {},\n    alerts: summary.alerts || []\n  }\n};\n\ntry {\n  fs.mkdirSync(backupDir, { recursive: true });\n  fs.writeFileSync(backupFile, JSON.stringify(backupData, null, 2), 'utf-8');\n  \n  // Limpiar backups antiguos (mantener solo últimos 30 días)\n  const files = fs.readdirSync(backupDir);\n  const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);\n  \n  files.forEach(file => {\n    const filePath = path.join(backupDir, file);\n    const stats = fs.statSync(filePath);\n    if (stats.mtimeMs < thirtyDaysAgo) {\n      fs.unlinkSync(filePath);\n    }\n  });\n  \n  return [{\n    json: {\n      ...summary,\n      backup: {\n        created: true,\n        file: backupFile,\n        size: fs.statSync(backupFile).size\n      }\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      ...summary,\n      backup: {\n        created: false,\n        error: e.message\n      }\n    }\n  }];\n}"
      },
      "id": "auto-backup",
      "name": "Auto Backup",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3850, 500],
      "notes": "Backup automático de resultados"
    },
    {
      "parameters": {
        "jsCode": "// Análisis de tendencias históricas\nconst summary = $json;\nconst enableTrends = summary.enableTrendAnalysis !== false;\n\nif (!enableTrends) {\n  return [$input.item];\n}\n\nconst executionHistory = $workflow.staticData.executionHistory || [];\nexecutionHistory.push({\n  executionId: summary.executionId,\n  timestamp: new Date().toISOString(),\n  videosProcessed: summary.videos_processed || 0,\n  pdfsGenerated: summary.pdfs_generated || 0,\n  successRate: parseFloat(summary.metrics?.successRate?.replace('%', '') || '0') / 100,\n  duration: summary.metrics?.duration || 0,\n  cost: parseFloat(summary.cost?.total || '0')\n});\n\n// Mantener solo últimos 100 ejecuciones\nif (executionHistory.length > 100) {\n  executionHistory.shift();\n}\n\n$workflow.staticData.executionHistory = executionHistory;\n\n// Calcular tendencias\nif (executionHistory.length >= 3) {\n  const recent = executionHistory.slice(-7); // Últimas 7 ejecuciones\n  const older = executionHistory.slice(-14, -7); // 7 anteriores\n  \n  const avgRecent = {\n    videosProcessed: recent.reduce((sum, e) => sum + e.videosProcessed, 0) / recent.length,\n    successRate: recent.reduce((sum, e) => sum + e.successRate, 0) / recent.length,\n    duration: recent.reduce((sum, e) => sum + e.duration, 0) / recent.length,\n    cost: recent.reduce((sum, e) => sum + e.cost, 0) / recent.length\n  };\n  \n  const avgOlder = older.length > 0 ? {\n    videosProcessed: older.reduce((sum, e) => sum + e.videosProcessed, 0) / older.length,\n    successRate: older.reduce((sum, e) => sum + e.successRate, 0) / older.length,\n    duration: older.reduce((sum, e) => sum + e.duration, 0) / older.length,\n    cost: older.reduce((sum, e) => sum + e.cost, 0) / older.length\n  } : avgRecent;\n  \n  const trends = {\n    videosProcessed: {\n      change: ((avgRecent.videosProcessed - avgOlder.videosProcessed) / avgOlder.videosProcessed * 100).toFixed(2),\n      direction: avgRecent.videosProcessed > avgOlder.videosProcessed ? 'up' : 'down'\n    },\n    successRate: {\n      change: ((avgRecent.successRate - avgOlder.successRate) / avgOlder.successRate * 100).toFixed(2),\n      direction: avgRecent.successRate > avgOlder.successRate ? 'up' : 'down'\n    },\n    duration: {\n      change: ((avgRecent.duration - avgOlder.duration) / avgOlder.duration * 100).toFixed(2),\n      direction: avgRecent.duration < avgOlder.duration ? 'up' : 'down' // Menor es mejor\n    },\n    cost: {\n      change: ((avgRecent.cost - avgOlder.cost) / (avgOlder.cost || 0.001) * 100).toFixed(2),\n      direction: avgRecent.cost < avgOlder.cost ? 'up' : 'down' // Menor es mejor\n    }\n  };\n  \n  return [{\n    json: {\n      ...summary,\n      trends: trends,\n      trendAnalysis: {\n        enabled: true,\n        recentAvg: avgRecent,\n        olderAvg: avgOlder,\n        dataPoints: executionHistory.length\n      }\n    }\n  }];\n}\n\nreturn [$input.item];"
      },
      "id": "trend-analysis",
      "name": "Trend Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4050, 500],
      "notes": "Análisis de tendencias históricas"
    },
    {
      "parameters": {
        "jsCode": "// Detección de anomalías\nconst summary = $json;\nconst enableAnomaly = summary.enableAnomalyDetection !== false;\n\nif (!enableAnomaly) {\n  return [$input.item];\n}\n\nconst executionHistory = $workflow.staticData.executionHistory || [];\n\nif (executionHistory.length < 5) {\n  return [$input.item];\n}\n\n// Calcular estadísticas\nconst videosProcessed = executionHistory.map(e => e.videosProcessed);\nconst successRates = executionHistory.map(e => e.successRate);\nconst durations = executionHistory.map(e => e.duration);\nconst costs = executionHistory.map(e => e.cost);\n\nconst calculateStats = (values) => {\n  const mean = values.reduce((a, b) => a + b, 0) / values.length;\n  const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;\n  const stdDev = Math.sqrt(variance);\n  return { mean, stdDev };\n};\n\nconst anomalies = [];\nconst current = executionHistory[executionHistory.length - 1];\n\n// Detectar anomalías usando Z-score (outliers > 2 desviaciones estándar)\nconst checkAnomaly = (value, values, name) => {\n  const stats = calculateStats(values);\n  const zScore = Math.abs((value - stats.mean) / (stats.stdDev || 0.001));\n  \n  if (zScore > 2) {\n    anomalies.push({\n      metric: name,\n      value: value,\n      mean: stats.mean.toFixed(2),\n      zScore: zScore.toFixed(2),\n      severity: zScore > 3 ? 'high' : 'medium'\n    });\n  }\n};\n\ncheckAnomaly(current.videosProcessed, videosProcessed, 'videosProcessed');\ncheckAnomaly(current.successRate, successRates, 'successRate');\ncheckAnomaly(current.duration, durations, 'duration');\ncheckAnomaly(current.cost, costs, 'cost');\n\nreturn [{\n  json: {\n    ...summary,\n    anomalies: anomalies,\n    anomalyDetection: {\n      enabled: true,\n      anomaliesFound: anomalies.length,\n      hasAnomalies: anomalies.length > 0\n    }\n  }\n}];"
      },
      "id": "anomaly-detection",
      "name": "Anomaly Detection",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4250, 500],
      "notes": "Detección de anomalías en métricas"
    },
    {
      "parameters": {
        "jsCode": "// Optimización automática de recursos\nconst summary = $json;\nconst enableOptimization = summary.enableAutoOptimization !== false;\n\nif (!enableOptimization) {\n  return [$input.item];\n}\n\nconst executionHistory = $workflow.staticData.executionHistory || [];\nconst recommendations = [];\n\nif (executionHistory.length >= 3) {\n  const recent = executionHistory.slice(-5);\n  const avgSuccessRate = recent.reduce((sum, e) => sum + e.successRate, 0) / recent.length;\n  const avgDuration = recent.reduce((sum, e) => sum + e.duration, 0) / recent.length;\n  const avgCost = recent.reduce((sum, e) => sum + e.cost, 0) / recent.length;\n  \n  // Recomendaciones basadas en métricas\n  if (avgSuccessRate < 0.8) {\n    recommendations.push({\n      type: 'success_rate',\n      priority: 'high',\n      message: 'Tasa de éxito baja. Considera aumentar MAX_RETRIES o revisar calidad de videos.',\n      action: 'Aumentar MAX_RETRIES o MIN_VIDEO_QUALITY'\n    });\n  }\n  \n  if (avgDuration > 3600) { // > 1 hora\n    recommendations.push({\n      type: 'duration',\n      priority: 'medium',\n      message: 'Duración alta. Considera reducir MAX_VIDEOS o habilitar procesamiento paralelo.',\n      action: 'Reducir MAX_VIDEOS o aumentar MAX_CONCURRENT'\n    });\n  }\n  \n  if (avgCost > 1.0) { // > $1 por ejecución\n    recommendations.push({\n      type: 'cost',\n      priority: 'medium',\n      message: 'Costo elevado. Considera optimizar uso de APIs o reducir videos procesados.',\n      action: 'Reducir MAX_VIDEOS o optimizar COST_* variables'\n    });\n  }\n  \n  // Optimización automática sugerida\n  const suggestedConfig = {};\n  if (avgSuccessRate < 0.7 && summary.maxRetries < 5) {\n    suggestedConfig.maxRetries = summary.maxRetries + 1;\n  }\n  \n  if (avgDuration > 3600 && summary.maxVideos > 5) {\n    suggestedConfig.maxVideos = Math.max(5, summary.maxVideos - 2);\n  }\n  \n  if (avgCost > 1.0 && summary.maxVideos > 5) {\n    suggestedConfig.maxVideos = Math.max(5, summary.maxVideos - 2);\n  }\n  \n  return [{\n    json: {\n      ...summary,\n      optimization: {\n        enabled: true,\n        recommendations: recommendations,\n        suggestedConfig: suggestedConfig,\n        hasRecommendations: recommendations.length > 0\n      }\n    }\n  }];\n}\n\nreturn [$input.item];"
      },
      "id": "auto-optimization",
      "name": "Auto Optimization",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4450, 500],
      "notes": "Optimización automática de recursos"
    },
    {
      "parameters": {
        "jsCode": "// Monitoreo de rendimiento del sistema\nconst summary = $json;\nconst enablePerf = summary.enablePerformanceMonitoring !== false;\n\nif (!enablePerf) {\n  return [$input.item];\n}\n\nconst startTime = summary.startedAt ? new Date(summary.startedAt).getTime() : Date.now();\nconst endTime = Date.now();\nconst totalDuration = (endTime - startTime) / 1000;\n\n// Calcular métricas de rendimiento por etapa\nconst perfMetrics = {\n  timestamp: new Date().toISOString(),\n  executionId: summary.executionId,\n  totalDuration: totalDuration,\n  stages: {\n    initialization: 0.1, // Estimado\n    discovery: (summary.videos_discovered || 0) * 2, // Estimado 2s por video\n    processing: (summary.videos_processed || 0) * 30, // Estimado 30s por video\n    pdfGeneration: (summary.pdfs_generated || 0) * 10, // Estimado 10s por PDF\n    postProcessing: totalDuration * 0.1 // Estimado 10% del tiempo total\n  },\n  bottlenecks: [],\n  efficiency: {\n    videosPerSecond: (summary.videos_processed || 0) / totalDuration,\n    pdfsPerSecond: (summary.pdfs_generated || 0) / totalDuration,\n    costEfficiency: (summary.videos_processed || 0) / (parseFloat(summary.cost?.total || '0.001'))\n  }\n};\n\n// Identificar cuellos de botella\nconst stageTimes = Object.values(perfMetrics.stages);\nconst maxStageTime = Math.max(...stageTimes);\nconst avgStageTime = stageTimes.reduce((a, b) => a + b, 0) / stageTimes.length;\n\nObject.entries(perfMetrics.stages).forEach(([stage, time]) => {\n  if (time > avgStageTime * 1.5) {\n    perfMetrics.bottlenecks.push({\n      stage: stage,\n      time: time,\n      percentage: ((time / totalDuration) * 100).toFixed(2) + '%',\n      impact: time > totalDuration * 0.3 ? 'high' : 'medium'\n    });\n  }\n});\n\n// Guardar historial de rendimiento\nconst perfHistory = $workflow.staticData.perfHistory || [];\nperfHistory.push(perfMetrics);\n\nif (perfHistory.length > 100) {\n  perfHistory.shift();\n}\n\n$workflow.staticData.perfHistory = perfHistory;\n\nreturn [{\n  json: {\n    ...summary,\n    performanceMetrics: perfMetrics,\n    hasBottlenecks: perfMetrics.bottlenecks.length > 0\n  }\n}];"
      },
      "id": "performance-monitoring",
      "name": "Performance Monitoring",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4650, 500],
      "notes": "Monitoreo de rendimiento del sistema"
    },
    {
      "parameters": {
        "jsCode": "// Auditoría y logging de seguridad\nconst summary = $json;\nconst enableAudit = summary.enableAuditLogging !== false;\n\nif (!enableAudit) {\n  return [$input.item];\n}\n\nconst auditLog = {\n  timestamp: new Date().toISOString(),\n  executionId: summary.executionId,\n  eventType: 'pipeline_execution',\n  action: summary.pipelineSuccess !== false ? 'completed' : 'failed',\n  userId: 'system',\n  resource: 'ai_video_pipeline',\n  metadata: {\n    videosProcessed: summary.videos_processed || 0,\n    pdfsGenerated: summary.pdfs_generated || 0,\n    errors: summary.errors?.length || 0,\n    cost: parseFloat(summary.cost?.total || '0'),\n    duration: summary.metrics?.duration || 0\n  },\n  ipAddress: 'system',\n  userAgent: 'n8n-workflow',\n  compliance: {\n    gdpr: true,\n    dataRetention: '30d',\n    encrypted: true\n  }\n};\n\n// Guardar en historial de auditoría\nconst auditHistory = $workflow.staticData.auditHistory || [];\nauditHistory.push(auditLog);\n\n// Mantener solo últimos 1000 registros\nif (auditHistory.length > 1000) {\n  auditHistory.shift();\n}\n\n$workflow.staticData.auditHistory = auditHistory;\n\nreturn [{\n  json: {\n    ...summary,\n    auditLog: auditLog,\n    auditLogged: true\n  }\n}];"
      },
      "id": "audit-logging",
      "name": "Audit Logging",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4850, 500],
      "notes": "Logging de auditoría y compliance"
    },
    {
      "parameters": {
        "jsCode": "// Verificaciones de seguridad\nconst summary = $json;\nconst enableSecurity = summary.enableSecurityChecks !== false;\n\nif (!enableSecurity) {\n  return [$input.item];\n}\n\nconst securityChecks = [];\n\n// Verificar encriptación de datos sensibles\nif (summary.outputs && summary.outputs.length > 0) {\n  const hasSensitiveData = summary.outputs.some(v => v.email || v.phone || v.personal_info);\n  if (hasSensitiveData) {\n    securityChecks.push({\n      check: 'data_encryption',\n      status: 'warning',\n      message: 'Datos sensibles detectados. Verificar encriptación.'\n    });\n  } else {\n    securityChecks.push({\n      check: 'data_encryption',\n      status: 'pass',\n      message: 'Sin datos sensibles detectados'\n    });\n  }\n}\n\n// Verificar acceso no autorizado\nconst unauthorizedAccess = summary.errors?.filter(e => \n  e.error?.includes('unauthorized') || \n  e.error?.includes('403') || \n  e.error?.includes('401')\n) || [];\n\nif (unauthorizedAccess.length > 0) {\n  securityChecks.push({\n    check: 'unauthorized_access',\n    status: 'fail',\n    message: `${unauthorizedAccess.length} intentos de acceso no autorizado detectados`\n  });\n} else {\n  securityChecks.push({\n    check: 'unauthorized_access',\n    status: 'pass',\n    message: 'Sin intentos de acceso no autorizado'\n  });\n}\n\n// Verificar rate limiting\nif (summary.rateLimiting) {\n  const rateLimitIssues = Object.values(summary.rateLimiting).filter(r => r.willExceed);\n  if (rateLimitIssues.length > 0) {\n    securityChecks.push({\n      check: 'rate_limiting',\n      status: 'warning',\n      message: 'Posible exceso de rate limits detectado'\n    });\n  } else {\n    securityChecks.push({\n      check: 'rate_limiting',\n      status: 'pass',\n      message: 'Rate limits dentro de límites normales'\n    });\n  }\n}\n\nconst passedChecks = securityChecks.filter(c => c.status === 'pass').length;\nconst failedChecks = securityChecks.filter(c => c.status === 'fail').length;\nconst warnings = securityChecks.filter(c => c.status === 'warning').length;\n\nreturn [{\n  json: {\n    ...summary,\n    securityChecks: securityChecks,\n    securityStatus: {\n      passed: passedChecks,\n      failed: failedChecks,\n      warnings: warnings,\n      total: securityChecks.length,\n      allPassed: failedChecks === 0\n    }\n  }\n}];"
      },
      "id": "security-checks",
      "name": "Security Checks",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5050, 500],
      "notes": "Verificaciones de seguridad"
    },
    {
      "parameters": {
        "jsCode": "// Análisis predictivo avanzado\nconst summary = $json;\nconst enablePredictive = summary.enablePredictiveAnalysis !== false;\n\nif (!enablePredictive) {\n  return [$input.item];\n}\n\nconst executionHistory = $workflow.staticData.executionHistory || [];\n\nif (executionHistory.length < 10) {\n  return [$input.item];\n}\n\n// Predicción de próxima ejecución usando regresión lineal simple\nconst predictNext = (values) => {\n  const n = values.length;\n  const sumX = n * (n + 1) / 2;\n  const sumY = values.reduce((a, b) => a + b, 0);\n  const sumXY = values.reduce((sum, val, idx) => sum + (idx + 1) * val, 0);\n  const sumX2 = n * (n + 1) * (2 * n + 1) / 6;\n  \n  const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n  const intercept = (sumY - slope * sumX) / n;\n  \n  const nextValue = slope * (n + 1) + intercept;\n  return Math.max(0, nextValue);\n};\n\nconst videosProcessed = executionHistory.map(e => e.videosProcessed);\nconst successRates = executionHistory.map(e => e.successRate);\nconst costs = executionHistory.map(e => e.cost);\n\nconst predictions = {\n  nextVideosProcessed: Math.round(predictNext(videosProcessed)),\n  nextSuccessRate: Math.max(0, Math.min(1, predictNext(successRates))),\n  nextCost: Math.max(0, predictNext(costs).toFixed(4)),\n  trend: {\n    videosProcessed: videosProcessed[videosProcessed.length - 1] > videosProcessed[0] ? 'increasing' : 'decreasing',\n    successRate: successRates[successRates.length - 1] > successRates[0] ? 'improving' : 'declining',\n    cost: costs[costs.length - 1] > costs[0] ? 'increasing' : 'decreasing'\n  },\n  confidence: executionHistory.length >= 20 ? 'high' : 'medium'\n};\n\n// Calcular probabilidad de éxito\nconst recentSuccessRate = successRates.slice(-5).reduce((a, b) => a + b, 0) / 5;\nconst predictedSuccess = recentSuccessRate > 0.8 ? 'high' : recentSuccessRate > 0.6 ? 'medium' : 'low';\n\nreturn [{\n  json: {\n    ...summary,\n    predictions: predictions,\n    predictedSuccess: predictedSuccess,\n    predictiveAnalysis: {\n      enabled: true,\n      dataPoints: executionHistory.length,\n      confidence: predictions.confidence\n    }\n  }\n}];"
      },
      "id": "predictive-analysis",
      "name": "Predictive Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5250, 500],
      "notes": "Análisis predictivo avanzado"
    },
    {
      "parameters": {
        "jsCode": "// Generar dashboard de métricas visual\nconst summary = $json;\nconst enableDashboard = summary.enableDashboard !== false;\n\nif (!enableDashboard) {\n  return [$input.item];\n}\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst outputDir = summary.outputDir || './ai_video_outputs';\nconst dashboardFile = path.join(outputDir, `dashboard_${summary.executionId || 'latest'}.json`);\n\n// Compilar todas las métricas para dashboard\nconst dashboard = {\n  executionId: summary.executionId,\n  timestamp: new Date().toISOString(),\n  overview: {\n    videosDiscovered: summary.videos_discovered || 0,\n    videosProcessed: summary.videos_processed || 0,\n    pdfsGenerated: summary.pdfs_generated || 0,\n    successRate: summary.metrics?.successRate || '0%',\n    totalCost: summary.cost?.total || '0',\n    duration: summary.metrics?.durationFormatted || '0s'\n  },\n  trends: summary.trends || {},\n  anomalies: summary.anomalies || [],\n  predictions: summary.predictions || {},\n  performance: summary.performanceMetrics || {},\n  security: summary.securityStatus || {},\n  optimization: summary.optimization || {},\n  alerts: summary.alerts || [],\n  mlPredictions: summary.mlPredictions || {},\n  costBreakdown: summary.cost?.breakdown || {},\n  charts: {\n    videosOverTime: summary.trendAnalysis?.recentAvg || {},\n    costOverTime: summary.cost?.dailyTotal || '0',\n    successRateOverTime: summary.trendAnalysis?.recentAvg?.successRate || 0\n  }\n};\n\ntry {\n  fs.mkdirSync(outputDir, { recursive: true });\n  fs.writeFileSync(dashboardFile, JSON.stringify(dashboard, null, 2), 'utf-8');\n  \n  return [{\n    json: {\n      ...summary,\n      dashboard: {\n        created: true,\n        file: dashboardFile,\n        data: dashboard\n      }\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      ...summary,\n      dashboard: {\n        created: false,\n        error: e.message\n      }\n    }\n  }];\n}"
      },
      "id": "generate-dashboard",
      "name": "Generate Dashboard",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5450, 500],
      "notes": "Genera dashboard de métricas visual"
    },
    {
      "parameters": {
        "jsCode": "// Preparar mensaje de notificación detallado con métricas\nconst summary = $json;\nconst executionId = summary.executionId || 'unknown';\nconst success = summary.pipelineSuccess !== false;\nconst metrics = summary.metrics || {};\n\nlet message = success ? '✅' : '⚠️';\nmessage += ` Pipeline de videos de IA ${success ? 'completado' : 'con errores'}\n\n`;\nmessage += `📊 Resumen:\n`;\nmessage += `• Videos descubiertos: ${summary.videos_discovered || 0}\n`;\nmessage += `• Videos procesados: ${summary.videos_processed || 0}\n`;\nmessage += `• PDFs generados: ${summary.pdfs_generated || 0}\n`;\nmessage += `• Videos filtrados por calidad: ${summary.filteredVideos || 0}\n`;\nmessage += `• Videos priorizados: ${summary.prioritized ? 'Sí' : 'No'}\n`;\nmessage += `• Errores: ${summary.errors?.length || 0}\n`;\n\nif (summary.alerts && summary.alerts.length > 0) {\n  message += `\n⚠️ Alertas (${summary.alerts.length}):\n`;\n  summary.alerts.slice(0, 3).forEach((alert, idx) => {\n    message += `${idx + 1}. [${alert.level.toUpperCase()}] ${alert.message}\n`;\n  });\n  if (summary.alerts.length > 3) {\n    message += `... y ${summary.alerts.length - 3} alertas más\n`;\n  }\n}\n\nif (metrics.durationFormatted) {\n  message += `\n⏱️ Métricas de Rendimiento:\n`;\n  message += `• Duración total: ${metrics.durationFormatted}\n`;\n  message += `• Videos/minuto: ${metrics.videosPerMinute || 0}\n`;\n  message += `• PDFs/minuto: ${metrics.pdfsPerMinute || 0}\n`;\n  message += `• Tasa de éxito: ${metrics.successRate || '0%'}\n`;\n  message += `• Tasa de error: ${metrics.errorRate || '0%'}\n`;\n  message += `• Tiempo promedio/video: ${metrics.avgProcessingTime || '0s'}\n`;\n}\n\nif (summary.outputs && summary.outputs.length > 0) {\n  message += `\n🎬 Videos procesados exitosamente:\n`;\n  summary.outputs.slice(0, 5).forEach((video, idx) => {\n    const likes = video.like_count || 0;\n    message += `${idx + 1}. ${video.title || video.video_id} (👍 ${likes})\n`;\n  });\n  if (summary.outputs.length > 5) {\n    message += `... y ${summary.outputs.length - 5} más\n`;\n  }\n}\n\nif (summary.errors && summary.errors.length > 0) {\n  message += `\n❌ Errores encontrados:\n`;\n  summary.errors.slice(0, 3).forEach((error, idx) => {\n    message += `${idx + 1}. ${error.video_url || error.videoId || 'Unknown'}: ${error.error || error.pipeline_error || 'Error desconocido'}\n`;\n  });\n  if (summary.errors.length > 3) {\n    message += `... y ${summary.errors.length - 3} errores más\n`;\n  }\n}\n\nif (summary.summaryFile) {\n  message += `\n📁 Resumen completo: ${summary.summaryFile}`;\n}\n\nif (summary.metricsFile) {\n  message += `\n📊 Métricas exportadas: ${summary.metricsFile}`;\n}\n\nif (summary.cloudStorageEnabled) {\n  message += `\n☁️ Cloud Storage: ${summary.cloudUploads?.length || 0} archivos listos para upload`;\n}\n\nif (summary.cost) {\n  message += `\n💰 Costos:\n`;\n  message += `• Total esta ejecución: $${summary.cost.total}\n`;\n  message += `• Total hoy: $${summary.cost.dailyTotal}\n`;\n  message += `• Promedio diario: $${summary.cost.avgDaily}\n`;\n}\n\nif (summary.mlPredictions) {\n  message += `\n🤖 Predicciones ML:\n`;\n  message += `• Videos de alta calidad: ${summary.mlPredictions.highQualityCount}\n`;\n  message += `• Score promedio: ${summary.mlPredictions.avgScore}\n`;\n}\n\nif (summary.rateLimiting) {\n  const warnings = Object.values(summary.rateLimiting).filter(r => r.willExceed);\n  if (warnings.length > 0) {\n    message += `\n⚠️ Rate Limits:\n`;\n    warnings.forEach(w => {\n      message += `• ${w.remaining} requests restantes (estimado: ${w.estimated})\n`;\n    });\n  }\n}\n\nif (summary.backup?.created) {\n  message += `\n💾 Backup creado: ${summary.backup.file}`;\n}\n\nif (summary.trends) {\n  message += `\n📈 Tendencias:\n`;\n  Object.entries(summary.trends).forEach(([key, trend]) => {\n    const emoji = trend.direction === 'up' ? '📈' : '📉';\n    message += `${emoji} ${key}: ${trend.change}% ${trend.direction === 'up' ? '↑' : '↓'}\n`;\n  });\n}\n\nif (summary.anomalies && summary.anomalies.length > 0) {\n  message += `\n⚠️ Anomalías detectadas (${summary.anomalies.length}):\n`;\n  summary.anomalies.slice(0, 3).forEach((anomaly, idx) => {\n    message += `${idx + 1}. ${anomaly.metric}: ${anomaly.value} (Z-score: ${anomaly.zScore}, ${anomaly.severity})\n`;\n  });\n}\n\nif (summary.optimization?.hasRecommendations) {\n  message += `\n💡 Recomendaciones de optimización:\n`;\n  summary.optimization.recommendations.slice(0, 3).forEach((rec, idx) => {\n    message += `${idx + 1}. [${rec.priority.toUpperCase()}] ${rec.message}\n`;\n  });\n}\n\nif (summary.performanceMetrics?.hasBottlenecks) {\n  message += `\n🐌 Cuellos de botella detectados:\n`;\n  summary.performanceMetrics.bottlenecks.slice(0, 3).forEach((bottleneck, idx) => {\n    message += `${idx + 1}. ${bottleneck.stage}: ${bottleneck.percentage} del tiempo total\n`;\n  });\n}\n\nif (summary.securityStatus) {\n  message += `\n🔒 Seguridad:\n`;\n  message += `• Verificaciones pasadas: ${summary.securityStatus.passed}/${summary.securityStatus.total}\n`;\n  if (summary.securityStatus.failed > 0) {\n    message += `• ⚠️ Fallos: ${summary.securityStatus.failed}\n`;\n  }\n  if (summary.securityStatus.warnings > 0) {\n    message += `• ⚠️ Advertencias: ${summary.securityStatus.warnings}\n`;\n  }\n}\n\nif (summary.predictions) {\n  message += `\n🔮 Predicciones:\n`;\n  message += `• Próximos videos procesados: ~${summary.predictions.nextVideosProcessed}\n`;\n  message += `• Tasa de éxito esperada: ${(summary.predictions.nextSuccessRate * 100).toFixed(2)}%\n`;\n  message += `• Costo estimado: $${summary.predictions.nextCost}\n`;\n  message += `• Confianza: ${summary.predictions.confidence}\n`;\n}\n\nif (summary.dashboard?.created) {\n  message += `\n📊 Dashboard generado: ${summary.dashboard.file}`;\n}\n\nif (summary.auditLog) {\n  message += `\n📝 Auditoría: Log registrado (compliance: ${summary.auditLog.compliance.gdpr ? 'GDPR' : 'N/A'})`;\n}\n\nif (summary.optimizedContent && summary.optimizedContent.length > 0) {\n  message += `\n📱 Contenido Optimizado para Redes Sociales:\n`;\n  summary.optimizedContent.slice(0, 3).forEach((content, idx) => {\n    message += `${idx + 1}. ${content.title}\\n`;\n    message += `   TikTok: ${content.platforms.tiktok.hashtags.length} hashtags\\n`;\n    if (content.platforms.instagram) {\n      message += `   Instagram: ${content.platforms.instagram.hashtags.length} hashtags\\n`;\n    }\n    if (content.platforms.youtube) {\n      message += `   YouTube: Título y descripción optimizados\\n`;\n    }\n    message += `   Mejor hora: ${content.platforms.tiktok.bestTimeToPost.recommendedTimes[0]}\\n`;\n  });\n  if (summary.optimizedContent.length > 3) {\n    message += `   ... y ${summary.optimizedContent.length - 3} videos más optimizados\\n`;\n  }\n}\n\nif (summary.competitorAnalysis) {\n  message += `\n🏆 Análisis de Competencia:\n`;\n  message += `• Top hashtags: ${Object.keys(summary.competitorAnalysis.topHashtags).slice(0, 3).join(', ')}\\n`;\n  message += `• Tipo de contenido mejor rendimiento: ${summary.competitorAnalysis.competitorInsights.bestPerformingType}\\n`;\n}\n\nif (summary.abTestVariants && summary.abTestVariants.length > 0) {\n  message += `\n🧪 A/B Testing:\n`;\n  message += `• Variantes generadas: ${summary.abTestVariants.length * 2} (A y B por video)\\n`;\n  message += `• Listo para testing de engagement\\n`;\n}\n\nif (summary.scheduledPosts && summary.scheduledPosts.length > 0) {\n  message += `\n📅 Publicaciones Programadas:\n`;\n  message += `• Posts programados: ${summary.scheduledPosts.length}\\n`;\n  if (summary.nextPostTime) {\n    const nextPost = new Date(summary.nextPostTime);\n    message += `• Próxima publicación: ${nextPost.toLocaleString()}\\n`;\n  }\n}\n\nif (summary.engagementAnalysis) {\n  message += `\n📊 Análisis de Engagement:\n`;\n  message += `• Engagement promedio: ${summary.engagementAnalysis.avgEngagementRate}\\n`;\n  message += `• Top performer: ${summary.engagementAnalysis.topPerformers[0]?.title || 'N/A'}\\n`;\n  if (summary.engagementAnalysis.recommendations.length > 0) {\n    message += `• Recomendación: ${summary.engagementAnalysis.recommendations[0].action}\\n`;\n  }\n}\n\nif (summary.sentimentAnalysis) {\n  message += `\n😊 Análisis de Sentimiento:\n`;\n  message += `• Positivo: ${summary.sentimentAnalysis.summary.positive}\\n`;\n  message += `• Neutral: ${summary.sentimentAnalysis.summary.neutral}\\n`;\n  message += `• Score promedio: ${summary.sentimentAnalysis.summary.avgSentiment}\\n`;\n}\n\nif (summary.contentExports && summary.contentExports.length > 0) {\n  message += `\n📤 Exportaciones:\n`;\n  message += `• Archivos exportados: ${summary.contentExports.length}\\n`;\n  message += `• Directorio: ${summary.exportDirectory}\\n`;\n}\n\nif (summary.seoAnalysis) {\n  message += `\n🔍 Análisis SEO:\n`;\n  message += `• Score promedio: ${summary.seoAnalysis.avgSEOScore}/100\\n`;\n  message += `• Top keywords: ${summary.seoAnalysis.topKeywords.slice(0, 3).map(k => k.keyword).join(', ')}\\n`;\n  if (summary.seoAnalysis.recommendations.length > 0) {\n    message += `• Recomendación: ${summary.seoAnalysis.recommendations[0].action}\\n`;\n  }\n}\n\nif (summary.thumbnailSpecs && summary.thumbnailSpecs.length > 0) {\n  message += `\n🖼️ Thumbnails:\n`;\n  message += `• Especificaciones generadas: ${summary.thumbnailSpecs.length}\\n`;\n  message += `• Plataformas: YouTube, Instagram, TikTok\\n`;\n  message += `• Directorio: ${summary.thumbnailDirectory}\\n`;\n}\n\nif (summary.performanceTracking) {\n  message += `\n📊 Performance Tracking:\n`;\n  message += `• Tracking IDs generados: ${summary.performanceTracking.trackingIds?.length || 0}\\n`;\n  message += `• Métricas configuradas: Views, Engagement, CTR\\n`;\n}\n\nif (summary.multiVariants && summary.multiVariants.length > 0) {\n  message += `\n🔄 Variantes Multiples:\n`;\n  message += `• Total variantes: ${summary.totalVariants}\\n`;\n  message += `• Videos con variantes: ${summary.multiVariants.length}\\n`;\n  message += `• Estrategia: Testing A/B por 7 días\\n`;\n}\n\nif (summary.advancedRecommendations) {\n  message += `\n💡 Recomendaciones Avanzadas:\n`;\n  if (summary.advancedRecommendations.priorityActions.length > 0) {\n    message += `• Acciones prioritarias:\\n`;\n    summary.advancedRecommendations.priorityActions.slice(0, 2).forEach((action, idx) => {\n      message += `  ${idx + 1}. ${action}\\n`;\n    });\n  }\n  if (summary.advancedRecommendations.recommendations.length > 0) {\n    message += `• Total recomendaciones: ${summary.advancedRecommendations.recommendations.length}\\n`;\n  }\n}\n\nif (summary.publishingResults) {\n  message += `\n🚀 Publicación Automática:\n`;\n  message += `• Listos para publicar: ${summary.publishingResults.summary.readyToPublish}\\n`;\n  message += `• Pendientes: ${summary.publishingResults.summary.pending}\\n`;\n}\n\nif (summary.realTimeTrendAnalysis) {\n  message += `\n📈 Tendencias en Tiempo Real:\n`;\n  if (summary.realTimeTrendAnalysis.trendingTopics.length > 0) {\n    message += `• Top keywords: ${summary.realTimeTrendAnalysis.trendingTopics.slice(0, 3).map(t => t.keyword).join(', ')}\\n`;\n  }\n  message += `• Tipo más popular: ${summary.realTimeTrendAnalysis.contentTrends.mostPopularType}\\n`;\n}\n\nif (summary.contentGeneration) {\n  message += `\n✨ Generación de Contenido:\n`;\n  message += `• Plantillas creadas: ${summary.contentGeneration.templates.length}\\n`;\n  message += `• Variaciones generadas: ${summary.contentGeneration.generatedContent.length * 3}\\n`;\n}\n\nif (summary.feedbackLoop) {\n  message += `\n🔄 Feedback Loop:\n`;\n  message += `• Tasa de éxito: ${summary.feedbackLoop.feedbackData.successRate}%\\n`;\n  if (summary.feedbackLoop.improvements.length > 0) {\n    message += `• Mejoras identificadas: ${summary.feedbackLoop.improvements.length}\\n`;\n  }\n}\n\nif (summary.realTimeDashboard) {\n  message += `\n📊 Dashboard:\n`;\n  message += `• Dashboard HTML: ${summary.realTimeDashboard.htmlFile}\\n`;\n  message += `• Dashboard JSON: ${summary.realTimeDashboard.jsonFile}\\n`;\n}\n\nif (summary.competitorMonitoring) {\n  message += `\n👁️ Monitoreo de Competencia:\n`;\n  message += `• Longitud óptima de título: ${summary.competitorMonitoring.insights.optimalTitleLength} caracteres\\n`;\n  if (summary.competitorMonitoring.alerts.length > 0) {\n    message += `• Alertas: ${summary.competitorMonitoring.alerts.length}\\n`;\n  }\n}\n\nif (summary.deepVideoAnalysis) {\n  message += `\n🎬 Análisis Profundo de Video:\n`;\n  message += `• Valor de producción promedio: ${summary.deepVideoAnalysis.summary.avgProductionValue.toFixed(2)}/100\\n`;\n  message += `• Score viral promedio: ${summary.deepVideoAnalysis.summary.avgViralScore.toFixed(2)}/100\\n`;\n  if (summary.deepVideoAnalysis.summary.topVideos.length > 0) {\n    message += `• Top video: ${summary.deepVideoAnalysis.summary.topVideos[0].title}\\n`;\n  }\n}\n\nif (summary.mlRecommendations) {\n  message += `\n🤖 Recomendaciones ML:\n`;\n  message += `• Predicciones generadas: ${summary.mlRecommendations.predictions.length}\\n`;\n  if (summary.mlRecommendations.recommendations.length > 0) {\n    message += `• Recomendación: ${summary.mlRecommendations.recommendations[0].action}\\n`;\n  }\n}\n\nif (summary.audienceAnalysis) {\n  message += `\n👥 Análisis de Audiencia:\n`;\n  message += `• Grupo de edad: ${summary.audienceAnalysis.demographics.ageGroup}\\n`;\n  message += `• Nivel técnico: ${summary.audienceAnalysis.demographics.techLevel}\\n`;\n  message += `• Tipos preferidos: ${summary.audienceAnalysis.preferences.preferredContentTypes.join(', ')}\\n`;\n}\n\nif (summary.contentVersioning) {\n  message += `\n📝 Versionado de Contenido:\n`;\n  message += `• Versiones creadas: ${summary.contentVersioning.versions.length}\\n`;\n  message += `• Directorio: ${summary.contentVersioning.history.versionDirectory}\\n`;\n}\n\nif (summary.advancedCostOptimization) {\n  message += `\n💰 Optimización de Costos:\n`;\n  message += `• Ahorro potencial: $${summary.advancedCostOptimization.savings.totalPotential.toFixed(4)} (${summary.advancedCostOptimization.savings.percentage}%)\\n`;\n  message += `• Optimizaciones sugeridas: ${summary.advancedCostOptimization.optimizations.length}\\n`;\n}\n\nif (summary.intelligentAlerts) {\n  message += `\n🚨 Alertas Inteligentes:\n`;\n  message += `• Críticas: ${summary.intelligentAlerts.summary.critical}\\n`;\n  message += `• Advertencias: ${summary.intelligentAlerts.summary.warnings}\\n`;\n  message += `• Informativas: ${summary.intelligentAlerts.summary.info}\\n`;\n  if (summary.intelligentAlerts.critical.length > 0) {\n    message += `• ⚠️ CRÍTICO: ${summary.intelligentAlerts.critical[0].message}\\n`;\n  }\n}\n\nif (summary.roiAnalysis) {\n  message += `\n💵 Análisis de ROI:\n`;\n  message += `• ROI: ${summary.roiAnalysis.roi.percentage}%\\n`;\n  message += `• Valor neto: $${summary.roiAnalysis.roi.netValue}\\n`;\n  message += `• Eficiencia: ${summary.roiAnalysis.roi.efficiency} engagement/\\$\\n`;\n}\n\nif (summary.designIntegration) {\n  message += `\n🎨 Integración de Diseño:\n`;\n  message += `• Especificaciones generadas: ${summary.designIntegration.designSpecs.length}\\n`;\n  message += `• Plantillas disponibles: ${summary.designIntegration.templates.length}\\n`;\n  message += `• Formatos: ${summary.designIntegration.exportFormats.map(f => f.format).join(', ')}\\n`;\n}\n\nif (summary.executiveReport) {\n  message += `\n📋 Reporte Ejecutivo:\n`;\n  message += `• Reporte JSON: ${summary.executiveReport.jsonFile}\\n`;\n  message += `• Reporte Texto: ${summary.executiveReport.textFile}\\n`;\n  message += `• ROI: ${summary.executiveReport.data.executiveSummary.roi}%\\n`;\n}\n\nif (summary.collaboration) {\n  message += `\n👥 Colaboración:\n`;\n  message += `• Recursos compartidos: ${summary.collaboration.summary.totalResources}\\n`;\n  message += `• Aprobaciones pendientes: ${summary.collaboration.summary.pendingApprovals}\\n`;\n  message += `• Miembros del equipo: ${summary.collaboration.summary.teamMembers}\\n`;\n}\n\nif (summary.advancedExports) {\n  message += `\n📤 Exportaciones Avanzadas:\n`;\n  message += `• Total exportaciones: ${summary.advancedExports.summary.totalExports}\\n`;\n  message += `• Formatos: ${summary.advancedExports.summary.formats.join(', ')}\\n`;\n  message += `• Directorio: ${summary.advancedExports.summary.exportDirectory}\\n`;\n}\n\nif (summary.businessMetrics) {\n  message += `\n📊 Métricas de Negocio:\n`;\n  message += `• Videos/día: ${summary.businessMetrics.kpis.contentProductionRate.toFixed(2)}\\n`;\n  message += `• Costo/video: $${summary.businessMetrics.kpis.costPerVideo}\\n`;\n  message += `• Engagement/\\$: ${summary.businessMetrics.kpis.engagementPerDollar}\\n`;\n  if (summary.businessMetrics.growth.viewsGrowth !== 'N/A') {\n    message += `• Crecimiento views: ${summary.businessMetrics.growth.viewsGrowth}%\\n`;\n  }\n  message += `• Valor estimado: $${summary.businessMetrics.value.estimatedValue.totalEstimated}\\n`;\n}\n\nif (summary.aiVideoAnalysis) {\n  message += `\n🤖 Análisis de Video con IA:\n`;\n  message += `• Videos analizados: ${summary.aiVideoAnalysis.analysisResults.length}\\n`;\n  message += `• Categorías detectadas: ${Object.keys(summary.aiVideoAnalysis.summary.categories).join(', ')}\\n`;\n  message += `• Confianza promedio: ${(summary.aiVideoAnalysis.summary.avgConfidence * 100).toFixed(1)}%\\n`;\n}\n\nif (summary.smartContentRecommendations) {\n  message += `\n💡 Recomendaciones Inteligentes:\n`;\n  message += `• Ideas de contenido: ${summary.smartContentRecommendations.contentIdeas.length}\\n`;\n  message += `• Sugerencias de optimización: ${summary.smartContentRecommendations.optimizationSuggestions.length}\\n`;\n  if (summary.smartContentRecommendations.recommendations.length > 0) {\n    message += `• Recomendación principal: ${summary.smartContentRecommendations.recommendations[0].action}\\n`;\n  }\n}\n\nif (summary.multiPlatformIntegration) {\n  message += `\n🌐 Integración Multi-Plataforma:\n`;\n  message += `• Plataformas activas: ${summary.multiPlatformIntegration.summary.activePlatforms}\\n`;\n  message += `• Contenido unificado: ${summary.multiPlatformIntegration.summary.totalUnifiedContent}\\n`;\n  message += `• Plataformas: ${Object.keys(summary.multiPlatformIntegration.platforms).filter(p => summary.multiPlatformIntegration.platforms[p].enabled).join(', ')}\\n`;\n}\n\nif (summary.conversionAnalysis) {\n  message += `\n📈 Análisis de Conversión:\n`;\n  message += `• Views → Likes: ${summary.conversionAnalysis.conversionFunnels.viewsToLikes}%\\n`;\n  message += `• Likes → Shares: ${summary.conversionAnalysis.conversionFunnels.likesToShares}%\\n`;\n  message += `• Tasa promedio: ${summary.conversionAnalysis.summary.avgConversionRate}%\\n`;\n  message += `• Oportunidades: ${summary.conversionAnalysis.summary.optimizationOpportunities}\\n`;\n}\n\nif (summary.advancedABTesting) {\n  message += `\n🧪 A/B Testing Avanzado:\n`;\n  message += `• Tests configurados: ${summary.advancedABTesting.testConfigurations.length}\\n`;\n  message += `• Duración recomendada: ${summary.advancedABTesting.statisticalAnalysis.minDuration}\\n`;\n  message += `• Tamaño de muestra: ${summary.advancedABTesting.statisticalAnalysis.recommendedSampleSize}\\n`;\n}\n\nif (summary.crmIntegration) {\n  message += `\n📞 Integración CRM:\n`;\n  message += `• Leads generados: ${summary.crmIntegration.summary.totalLeads}\\n`;\n  message += `• Campañas creadas: ${summary.crmIntegration.summary.totalCampaigns}\\n`;\n  message += `• Sistemas configurados: ${summary.crmIntegration.summary.crmSystemsConfigured}\\n`;\n}\n\nif (summary.predictiveContent) {\n  message += `\n🔮 Contenido Predictivo:\n`;\n  message += `• Likes esperados (semana): ${summary.predictiveContent.predictions.nextWeek.expectedLikes}\\n`;\n  message += `• Views esperados (semana): ${summary.predictiveContent.predictions.nextWeek.expectedViews}\\n`;\n  message += `• Tendencias: ${summary.predictiveContent.predictions.trends.contentTypeTrend.trending}\\n`;\n  if (summary.predictiveContent.recommendations.length > 0) {\n    message += `• Recomendación: ${summary.predictiveContent.recommendations[0].recommendation}\\n`;\n  }\n}\n\nif (summary.advancedSentiment) {\n  message += `\n😊 Análisis de Sentimiento Avanzado:\n`;\n  message += `• Videos analizados: ${summary.advancedSentiment.sentimentResults.length}\\n`;\n  message += `• Score promedio: ${(summary.advancedSentiment.summary.avgSentimentScore * 100).toFixed(1)}%\\n`;\n  message += `• Emoción dominante: ${summary.advancedSentiment.summary.dominantEmotion}\\n`;\n  message += `• Ratio positivo: ${(summary.advancedSentiment.summary.positiveRatio * 100).toFixed(1)}%\\n`;\n}\n\nif (summary.autoSubtitles) {\n  message += `\n📝 Subtítulos Automáticos:\n`;\n  message += `• Subtítulos generados: ${summary.autoSubtitles.subtitles.length}\\n`;\n  message += `• Idiomas: ${summary.autoSubtitles.summary.totalLanguages}\\n`;\n  message += `• Directorio: ${summary.autoSubtitles.summary.subtitleDirectory}\\n`;\n}\n\nif (summary.competitorDeepAnalysis) {\n  message += `\n🏆 Análisis Profundo de Competencia:\n`;\n  message += `• Videos analizados: ${summary.competitorDeepAnalysis.summary.videosAnalyzed}\\n`;\n  message += `• Longitud óptima de título: ${summary.competitorDeepAnalysis.insights.optimalTitleLength} caracteres\\n`;\n  message += `• Mejor tipo de contenido: ${summary.competitorDeepAnalysis.insights.bestContentType}\\n`;\n  message += `• Recomendaciones: ${summary.competitorDeepAnalysis.summary.recommendationsCount}\\n`;\n}\n\nif (summary.personalizedRecommendations) {\n  message += `\n🎯 Recomendaciones Personalizadas:\n`;\n  message += `• Total recomendaciones: ${summary.personalizedRecommendations.summary.totalRecommendations}\\n`;\n  message += `• Altamente recomendados: ${summary.personalizedRecommendations.summary.highlyRecommended}\\n`;\n  message += `• Sugerencias de contenido: ${summary.personalizedRecommendations.summary.contentSuggestions}\\n`;\n}\n\nif (summary.analyticsIntegration) {\n  message += `\n📊 Integración Analytics:\n`;\n  message += `• Plataformas configuradas: ${summary.analyticsIntegration.summary.platformsConfigured}\\n`;\n  message += `• Métricas trackeadas: ${summary.analyticsIntegration.summary.metricsTracked}\\n`;\n  message += `• Insights generados: ${summary.analyticsIntegration.summary.insightsGenerated}\\n`;\n}\n\nif (summary.proactiveAlerts) {\n  message += `\n🚨 Alertas Proactivas:\n`;\n  message += `• Total alertas: ${summary.proactiveAlerts.summary.totalAlerts}\\n`;\n  message += `• Críticas: ${summary.proactiveAlerts.summary.criticalAlerts}\\n`;\n  message += `• Advertencias: ${summary.proactiveAlerts.summary.warnings}\\n`;\n}\n\nif (summary.voiceToneAnalysis) {\n  message += `\n🎤 Análisis de Voz y Tono:\n`;\n  message += `• Videos analizados: ${summary.voiceToneAnalysis.analysisResults.length}\\n`;\n  message += `• Tono dominante: ${summary.voiceToneAnalysis.summary.dominantTone}\\n`;\n  message += `• Legibilidad promedio: ${(summary.voiceToneAnalysis.summary.avgReadability * 100).toFixed(1)}%\\n`;\n}\n\nif (summary.emergingTrends) {\n  message += `\n📈 Tendencias Emergentes:\n`;\n  message += `• Keywords emergentes: ${summary.emergingTrends.summary.emergingKeywords}\\n`;\n  message += `• Tendencias identificadas: ${summary.emergingTrends.summary.trendsIdentified}\\n`;\n  message += `• Top tendencia: ${summary.emergingTrends.summary.topTrend}\\n`;\n}\n\nif (summary.viralScoring) {\n  message += `\n🔥 Scoring de Viralidad:\n`;\n  message += `• Videos scored: ${summary.viralScoring.summary.totalScored}\\n`;\n  message += `• Score promedio: ${summary.viralScoring.summary.avgViralScore}/100\\n`;\n  message += `• Alto potencial: ${summary.viralScoring.summary.highPotential}\\n`;\n}\n\nif (summary.marketingIntegration) {\n  message += `\n📧 Integración Marketing:\n`;\n  message += `• Plataformas configuradas: ${summary.marketingIntegration.summary.platformsConfigured}\\n`;\n  message += `• Campañas creadas: ${summary.marketingIntegration.summary.campaignsCreated}\\n`;\n  message += `• Automatizaciones activas: ${summary.marketingIntegration.summary.automationsActive}\\n`;\n}\n\nmessage += `\n\n🕐 Ejecución ID: ${executionId}`;\n\nreturn [{\n  json: {\n    ...summary,\n    message: message,\n    notificationPrepared: true\n  }\n}];"
      },
      "id": "prepare-notification",
      "name": "Prepare Notification",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1650, 300],
      "notes": "Prepara mensaje de notificación detallado"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "itemValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-telegram",
              "leftValue": "={{ $env.TELEGRAM_BOT_TOKEN }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-telegram",
      "name": "Check Telegram Available",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1850, 200],
      "notes": "Verifica si Telegram está configurado"
    },
    {
      "parameters": {
        "chatId": "={{ $env.TELEGRAM_CHAT_ID }}",
        "text": "={{ $json.message }}",
        "additionalFields": {
          "parse_mode": "Markdown"
        }
      },
      "id": "send-telegram",
      "name": "Send Telegram Notification",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "position": [2050, 200],
      "credentials": {
        "telegramApi": {
          "id": "telegram-credentials",
          "name": "Telegram Bot API"
        }
      },
      "notes": "Envía notificación a Telegram",
      "continueOnFail": true
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"success\": $json.pipelineSuccess !== false, \"message\": \"Pipeline ejecutado\", \"executionId\": $json.executionId, \"videosProcessed\": $json.videos_processed || 0, \"pdfsGenerated\": $json.pdfs_generated || 0 } }}"
      },
      "id": "webhook-response",
      "name": "Webhook Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1850, 500],
      "notes": "Responde al webhook si fue ejecutado manualmente"
    },
    {
      "parameters": {
        "jsCode": "// Manejar errores y preparar mensaje de error\nconst error = $json.error || 'Error desconocido';\nconst executionId = $json.executionId || 'unknown';\n\nlet errorMessage = `❌ Error en el pipeline de videos de IA\n\n`;\nerrorMessage += `Error: ${error}\n`;\nerrorMessage += `Ejecución ID: ${executionId}\n`;\n\nif ($json.missingScripts) {\n  errorMessage += `\nScripts faltantes: ${$json.missingScripts.join(', ')}\n`;\n}\n\nif ($json.summaryFile) {\n  errorMessage += `\nArchivo de resumen: ${$json.summaryFile}`;\n}\n\nreturn [{\n  json: {\n    ...$input.item.json,\n    error: error,\n    errorMessage: errorMessage,\n    executionId: executionId\n  }\n}];"
      },
      "id": "handle-error",
      "name": "Handle Error",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1650, 600],
      "notes": "Maneja errores y prepara mensaje de error",
      "onError": "continue"
    },
    {
      "parameters": {
        "chatId": "={{ $env.TELEGRAM_CHAT_ID }}",
        "text": "={{ $json.errorMessage }}",
        "additionalFields": {
          "parse_mode": "Markdown"
        }
      },
      "id": "send-error-telegram",
      "name": "Send Error Telegram",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "position": [1850, 600],
      "credentials": {
        "telegramApi": {
          "id": "telegram-credentials",
          "name": "Telegram Bot API"
        }
      },
      "notes": "Envía notificación de error a Telegram",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Registrar analytics del workflow\nconst analytics = $workflow.staticData.analytics || {\n  totalExecutions: 0,\n  successfulExecutions: 0,\n  failedExecutions: 0,\n  totalVideosProcessed: 0,\n  totalPdfsGenerated: 0,\n  lastExecution: null,\n  executionHistory: []\n};\n\nconst execution = {\n  timestamp: new Date().toISOString(),\n  executionId: $json.executionId || 'unknown',\n  success: $json.pipelineSuccess !== false,\n  videosDiscovered: $json.videos_discovered || 0,\n  videosProcessed: $json.videos_processed || 0,\n  pdfsGenerated: $json.pdfs_generated || 0,\n  errors: $json.errors?.length || 0\n};\n\nanalytics.totalExecutions++;\nif (execution.success) {\n  analytics.successfulExecutions++;\n} else {\n  analytics.failedExecutions++;\n}\n\nanalytics.totalVideosProcessed += execution.videosProcessed;\nanalytics.totalPdfsGenerated += execution.pdfsGenerated;\nanalytics.lastExecution = execution;\n\n// Mantener historial de últimas 50 ejecuciones\nanalytics.executionHistory.push(execution);\nif (analytics.executionHistory.length > 50) {\n  analytics.executionHistory.shift();\n}\n\n$workflow.staticData.analytics = analytics;\n\nreturn [{\n  json: {\n    ...$input.item.json,\n    analytics: {\n      totalExecutions: analytics.totalExecutions,\n      successRate: analytics.totalExecutions > 0 ? \n        ((analytics.successfulExecutions / analytics.totalExecutions) * 100).toFixed(2) + '%' : '0%',\n      totalVideosProcessed: analytics.totalVideosProcessed,\n      totalPdfsGenerated: analytics.totalPdfsGenerated\n    }\n  }\n}];"
      },
      "id": "update-analytics",
      "name": "Update Analytics",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2250, 300],
      "notes": "Actualiza analytics del workflow"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "itemValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-email",
              "leftValue": "={{ $json.enableEmail }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-email",
      "name": "Check Email Available",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [2450, 200],
      "notes": "Verifica si email está configurado"
    },
    {
      "parameters": {
        "fromEmail": "={{ $env.EMAIL_FROM || 'noreply@example.com' }}",
        "toEmail": "={{ $env.EMAIL_TO }}",
        "subject": "={{ 'Pipeline de Videos IA - ' + ($json.pipelineSuccess !== false ? 'Completado' : 'Error') + ' - ' + ($json.executionId || 'Unknown') }}",
        "text": "={{ $json.message || 'Pipeline ejecutado' }}",
        "options": {}
      },
      "id": "send-email",
      "name": "Send Email Notification",
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 2,
      "position": [2650, 200],
      "credentials": {
        "smtp": {
          "id": "smtp-credentials",
          "name": "SMTP"
        }
      },
      "notes": "Envía notificación por email",
      "continueOnFail": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "itemValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-webhook",
              "leftValue": "={{ $json.enableWebhooks }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-webhook",
      "name": "Check Webhook Available",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [2450, 400],
      "notes": "Verifica si webhook externo está configurado"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.WEBHOOK_URL }}",
        "authentication": "none",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "event",
              "value": "={{ 'pipeline_completed' }}"
            },
            {
              "name": "executionId",
              "value": "={{ $json.executionId }}"
            },
            {
              "name": "success",
              "value": "={{ $json.pipelineSuccess !== false }}"
            },
            {
              "name": "videosProcessed",
              "value": "={{ $json.videos_processed || 0 }}"
            },
            {
              "name": "pdfsGenerated",
              "value": "={{ $json.pdfs_generated || 0 }}"
            },
            {
              "name": "timestamp",
              "value": "={{ new Date().toISOString() }}"
            }
          ]
        },
        "options": {}
      },
      "id": "send-webhook",
      "name": "Send External Webhook",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [2650, 400],
      "notes": "Envía webhook a sistema externo",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Generar hashtags y contenido optimizado para múltiples plataformas\nconst summary = $json;\nconst executionId = summary.executionId || 'unknown';\n\n// Determinar industria y demografía basado en el contenido\nconst industry = $env.TIKTOK_INDUSTRY || 'automation';\nconst demographic = $env.TIKTOK_DEMOGRAPHIC || 'tech_savvy';\nconst enableMultiPlatform = $env.ENABLE_MULTI_PLATFORM !== 'false';\nconst maxVideosToProcess = parseInt($env.MAX_HASHTAG_VIDEOS || '5');\n\n// Generar contenido optimizado para cada video\nlet optimizedContent = [];\n\nif (summary.outputs && summary.outputs.length > 0) {\n  const videosToProcess = summary.outputs.slice(0, maxVideosToProcess);\n  const { execSync } = require('child_process');\n  \n  for (const video of videosToProcess) {\n    // Determinar tipo de contenido basado en el video\n    let contentType = 'tutorial';\n    const title = (video.title || '').toLowerCase();\n    const description = (video.description || '').toLowerCase();\n    \n    if (title.includes('review') || description.includes('review')) {\n      contentType = 'review';\n    } else if (title.includes('behind') || title.includes('scenes') || description.includes('behind')) {\n      contentType = 'behind_scenes';\n    } else if (title.includes('comparison') || title.includes('vs') || description.includes('vs')) {\n      contentType = 'comparison';\n    } else if (title.includes('tutorial') || title.includes('how to') || description.includes('tutorial')) {\n      contentType = 'tutorial';\n    } else if (title.includes('tip') || title.includes('hack') || description.includes('tip')) {\n      contentType = 'tips';\n    }\n    \n    // Generar hashtags para TikTok\n    let tiktokHashtags = [];\n    let tiktokFormatted = '';\n    \n    try {\n      const command = `cd /Users/adan/IA/scripts && python3 tiktok_hashtag_generator.py --industry ${industry} --demographic ${demographic} --content-type ${contentType} --count 12 --json --save-history`;\n      const result = execSync(command, { encoding: 'utf-8', timeout: 30000 });\n      const hashtagData = JSON.parse(result);\n      \n      tiktokHashtags = hashtagData.main_hashtags || [];\n      tiktokFormatted = hashtagData.formatted_string || '';\n    } catch (e) {\n      // Hashtags por defecto si falla\n      tiktokHashtags = ['#AITok', '#TechTok', '#AutomationTok', '#FYP', '#Viral', '#TechTips', '#AIGenerated', '#TechHacks', '#LearnOnTikTok', '#TechReview'];\n      tiktokFormatted = tiktokHashtags.join(' ');\n    }\n    \n    // Generar contenido optimizado para cada plataforma\n    const optimized = {\n      videoId: video.video_id,\n      title: video.title,\n      originalUrl: video.url,\n      contentType: contentType,\n      platforms: {\n        tiktok: {\n          hashtags: tiktokHashtags,\n          formattedHashtags: tiktokFormatted,\n          caption: generateTikTokCaption(video, contentType),\n          bestTimeToPost: calculateBestTimeToPost('tiktok'),\n          characterCount: tiktokFormatted.length + (video.title?.length || 0)\n        },\n        instagram: enableMultiPlatform ? {\n          hashtags: generateInstagramHashtags(tiktokHashtags, contentType),\n          caption: generateInstagramCaption(video, contentType),\n          bestTimeToPost: calculateBestTimeToPost('instagram'),\n          reelsOptimized: true\n        } : null,\n        youtube: enableMultiPlatform ? {\n          title: generateYouTubeTitle(video.title, contentType),\n          description: generateYouTubeDescription(video, contentType),\n          tags: generateYouTubeTags(video, contentType),\n          bestTimeToPost: calculateBestTimeToPost('youtube')\n        } : null\n      },\n      engagementScore: video.priorityScore || 0,\n      mlPrediction: video.mlPrediction || null\n    };\n    \n    optimizedContent.push(optimized);\n  }\n}\n\n// Funciones auxiliares\nfunction generateTikTokCaption(video, contentType) {\n  const title = video.title || 'Video de IA';\n  const likes = video.like_count || 0;\n  \n  let caption = title;\n  \n  if (contentType === 'tutorial') {\n    caption += '\\n\\n📚 Tutorial completo en el PDF descargable\\n💡 Aprende paso a paso cómo replicar esto';\n  } else if (contentType === 'review') {\n    caption += '\\n\\n🔍 Review completo y análisis detallado\\n📊 Todo lo que necesitas saber';\n  } else if (contentType === 'tips') {\n    caption += '\\n\\n💡 Pro tip que necesitas conocer\\n🚀 Aumenta tu productividad';\n  } else {\n    caption += '\\n\\n✨ Contenido exclusivo de IA\\n📥 Descarga el PDF para más detalles';\n  }\n  \n  caption += `\\n\\n👍 ${likes > 0 ? likes.toLocaleString() : 'Nuevo'} likes`;\n  \n  return caption;\n}\n\nfunction generateInstagramHashtags(tiktokHashtags, contentType) {\n  // Adaptar hashtags de TikTok para Instagram (máximo 30)\n  const instagramHashtags = tiktokHashtags.slice(0, 25);\n  \n  // Agregar hashtags específicos de Instagram\n  const instagramSpecific = ['#Instagram', '#Reels', '#Explore', '#InstaGood', '#Photography'];\n  \n  return [...instagramHashtags, ...instagramSpecific].slice(0, 30);\n}\n\nfunction generateInstagramCaption(video, contentType) {\n  const title = video.title || 'Video de IA';\n  const caption = `${title}\\n\\n📱 Contenido optimizado para Instagram Reels\\n\\n💬 ¿Qué opinas? Comenta abajo 👇\\n\\n🔔 Activa las notificaciones para no perderte nada`;\n  \n  return caption;\n}\n\nfunction generateYouTubeTitle(originalTitle, contentType) {\n  const title = originalTitle || 'Video de IA';\n  \n  // Optimizar título para YouTube (máximo 60 caracteres recomendado)\n  let optimized = title;\n  \n  if (contentType === 'tutorial') {\n    optimized = `Tutorial: ${title}`;\n  } else if (contentType === 'review') {\n    optimized = `Review Completo: ${title}`;\n  }\n  \n  // Asegurar que no exceda 60 caracteres\n  if (optimized.length > 60) {\n    optimized = optimized.substring(0, 57) + '...';\n  }\n  \n  return optimized;\n}\n\nfunction generateYouTubeDescription(video, contentType) {\n  const title = video.title || 'Video de IA';\n  const description = `📹 ${title}\\n\\n`;\n  \n  if (contentType === 'tutorial') {\n    return description + `📚 En este tutorial aprenderás:\\n• Paso a paso completo\\n• Tips y trucos profesionales\\n• Recursos adicionales\\n\\n📥 Descarga el PDF completo en la descripción\\n\\n👍 Si te gustó, dale like y suscríbete\\n🔔 Activa la campanita para más contenido\\n\\n#YouTube #Tutorial #IA #Tech`;\n  } else {\n    return description + `📥 Descarga el PDF completo en la descripción\\n\\n👍 Si te gustó, dale like y suscríbete\\n🔔 Activa la campanita para más contenido\\n\\n#YouTube #IA #Tech`;\n  }\n}\n\nfunction generateYouTubeTags(video, contentType) {\n  const baseTags = ['IA', 'Inteligencia Artificial', 'Tech', 'Tutorial', 'Automation'];\n  \n  if (contentType === 'tutorial') {\n    return [...baseTags, 'Tutorial', 'Aprende', 'Educación', 'Tips'];\n  } else if (contentType === 'review') {\n    return [...baseTags, 'Review', 'Análisis', 'Comparación'];\n  }\n  \n  return baseTags;\n}\n\nfunction calculateBestTimeToPost(platform) {\n  // Horarios óptimos basados en estudios (UTC)\n  const optimalTimes = {\n    tiktok: ['18:00', '19:00', '20:00', '21:00'], // 6-9 PM\n    instagram: ['17:00', '18:00', '19:00', '20:00'], // 5-8 PM\n    youtube: ['14:00', '15:00', '16:00', '17:00'] // 2-5 PM\n  };\n  \n  return {\n    platform: platform,\n    recommendedTimes: optimalTimes[platform] || ['18:00', '19:00'],\n    timezone: 'UTC',\n    note: 'Ajusta según tu audiencia local'\n  };\n}\n\nreturn [{\n  json: {\n    ...summary,\n    optimizedContent: optimizedContent,\n    contentOptimized: optimizedContent.length > 0,\n    platformsEnabled: {\n      tiktok: true,\n      instagram: enableMultiPlatform,\n      youtube: enableMultiPlatform\n    }\n  }\n}];"
      },
      "id": "generate-hashtags",
      "name": "Generate Social Media Content",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1850, 400],
      "notes": "Genera hashtags y contenido optimizado para TikTok, Instagram y YouTube",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Análisis de competencia y tendencias\nconst summary = $json;\nconst enableCompetitor = summary.enableCompetitorAnalysis !== false;\n\nif (!enableCompetitor || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\n// Analizar hashtags y contenido de competencia\nconst competitorAnalysis = {\n  timestamp: new Date().toISOString(),\n  topHashtags: {},\n  trendingTopics: [],\n  competitorInsights: {}\n};\n\n// Extraer hashtags más comunes de videos similares\nif (summary.optimizedContent && summary.optimizedContent.length > 0) {\n  const allHashtags = [];\n  summary.optimizedContent.forEach(content => {\n    if (content.platforms.tiktok) {\n      allHashtags.push(...content.platforms.tiktok.hashtags);\n    }\n  });\n  \n  // Contar frecuencia de hashtags\n  const hashtagCounts = {};\n  allHashtags.forEach(tag => {\n    hashtagCounts[tag] = (hashtagCounts[tag] || 0) + 1;\n  });\n  \n  // Top hashtags\n  const sortedHashtags = Object.entries(hashtagCounts)\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 10);\n  \n  competitorAnalysis.topHashtags = Object.fromEntries(sortedHashtags);\n  competitorAnalysis.trendingTopics = sortedHashtags.slice(0, 5).map(([tag]) => tag);\n}\n\n// Análisis de engagement promedio\nconst avgEngagement = summary.outputs.reduce((sum, v) => {\n  const likes = v.like_count || 0;\n  const views = v.view_count || 0;\n  return sum + (likes + views / 10); // Engagement score\n}, 0) / (summary.outputs.length || 1);\n\ncompetitorAnalysis.competitorInsights = {\n  avgEngagement: avgEngagement.toFixed(2),\n  contentTypes: summary.optimizedContent?.map(c => c.contentType) || [],\n  bestPerformingType: getBestPerformingType(summary.outputs),\n  recommendedHashtags: competitorAnalysis.trendingTopics.slice(0, 5)\n};\n\nfunction getBestPerformingType(videos) {\n  const typePerformance = {};\n  \n  videos.forEach(video => {\n    const type = video.contentType || 'general';\n    const score = (video.like_count || 0) + (video.view_count || 0) / 10;\n    typePerformance[type] = (typePerformance[type] || 0) + score;\n  });\n  \n  return Object.entries(typePerformance)\n    .sort((a, b) => b[1] - a[1])[0]?.[0] || 'general';\n}\n\nreturn [{\n  json: {\n    ...summary,\n    competitorAnalysis: competitorAnalysis\n  }\n}];"
      },
      "id": "competitor-analysis",
      "name": "Competitor Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2050, 400],
      "notes": "Análisis de competencia y tendencias",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// A/B Testing de contenido\nconst summary = $json;\nconst enableAB = summary.enableABTesting !== false;\n\nif (!enableAB || !summary.optimizedContent || summary.optimizedContent.length === 0) {\n  return [$input.item];\n}\n\n// Generar variantes A/B para contenido\nconst abTestVariants = summary.optimizedContent.map((content, idx) => {\n  const baseContent = content;\n  \n  // Variante A: Original\n  const variantA = {\n    variant: 'A',\n    caption: baseContent.platforms.tiktok.caption,\n    hashtags: baseContent.platforms.tiktok.hashtags,\n    title: baseContent.title\n  };\n  \n  // Variante B: Optimizada (más corta, más emojis, diferentes hashtags)\n  const variantB = {\n    variant: 'B',\n    caption: optimizeCaptionForAB(baseContent.platforms.tiktok.caption, 'B'),\n    hashtags: optimizeHashtagsForAB(baseContent.platforms.tiktok.hashtags, 'B'),\n    title: optimizeTitleForAB(baseContent.title, 'B')\n  };\n  \n  return {\n    videoId: content.videoId,\n    variants: {\n      A: variantA,\n      B: variantB\n    },\n    testId: `ab_test_${content.videoId}_${Date.now()}`,\n    recommendedVariant: Math.random() > 0.5 ? 'A' : 'B' // Aleatorio para distribución\n  };\n});\n\nfunction optimizeCaptionForAB(originalCaption, variant) {\n  if (variant === 'B') {\n    // Versión más corta y directa\n    const lines = originalCaption.split('\\n');\n    return lines.slice(0, 2).join('\\n') + '\\n\\n🔥 Nuevo contenido cada semana!';\n  }\n  return originalCaption;\n}\n\nfunction optimizeHashtagsForAB(originalHashtags, variant) {\n  if (variant === 'B') {\n    // Diferentes hashtags trending\n    const trendingAlternatives = ['#FYP', '#Viral', '#Trending', '#Explore', '#Discover'];\n    return [...originalHashtags.slice(0, 7), ...trendingAlternatives.slice(0, 3)];\n  }\n  return originalHashtags;\n}\n\nfunction optimizeTitleForAB(originalTitle, variant) {\n  if (variant === 'B') {\n    // Título más corto y llamativo\n    return originalTitle.length > 40 ? originalTitle.substring(0, 37) + '...' : originalTitle;\n  }\n  return originalTitle;\n}\n\nreturn [{\n  json: {\n    ...summary,\n    abTestVariants: abTestVariants,\n    abTestingEnabled: true\n  }\n}];"
      },
      "id": "ab-testing",
      "name": "A/B Testing",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2250, 400],
      "notes": "Genera variantes A/B para testing de contenido",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Programación automática de publicaciones\nconst summary = $json;\nconst enableScheduling = summary.enableAutoScheduling !== false;\n\nif (!enableScheduling || !summary.optimizedContent || summary.optimizedContent.length === 0) {\n  return [$input.item];\n}\n\nconst scheduledPosts = [];\nconst now = new Date();\n\nsummary.optimizedContent.forEach((content, idx) => {\n  // Calcular fecha de publicación (espaciada cada 2 horas)\n  const publishDate = new Date(now.getTime() + (idx * 2 * 60 * 60 * 1000));\n  \n  // Obtener mejor hora para cada plataforma\n  const tiktokTime = content.platforms.tiktok.bestTimeToPost.recommendedTimes[0];\n  const [hours, minutes] = tiktokTime.split(':');\n  \n  // Ajustar fecha a la mejor hora\n  publishDate.setUTCHours(parseInt(hours), parseInt(minutes), 0, 0);\n  \n  // Si la hora ya pasó hoy, programar para mañana\n  if (publishDate < now) {\n    publishDate.setUTCDate(publishDate.getUTCDate() + 1);\n  }\n  \n  const scheduledPost = {\n    postId: `post_${content.videoId}_${Date.now()}`,\n    videoId: content.videoId,\n    title: content.title,\n    scheduledTime: publishDate.toISOString(),\n    platforms: {\n      tiktok: {\n        enabled: true,\n        scheduledTime: publishDate.toISOString(),\n        content: {\n          caption: content.platforms.tiktok.caption,\n          hashtags: content.platforms.tiktok.formattedHashtags\n        },\n        status: 'scheduled'\n      },\n      instagram: content.platforms.instagram ? {\n        enabled: true,\n        scheduledTime: new Date(publishDate.getTime() + 30 * 60 * 1000).toISOString(), // 30 min después\n        content: {\n          caption: content.platforms.instagram.caption,\n          hashtags: content.platforms.instagram.hashtags.join(' ')\n        },\n        status: 'scheduled'\n      } : null,\n      youtube: content.platforms.youtube ? {\n        enabled: true,\n        scheduledTime: new Date(publishDate.getTime() + 60 * 60 * 1000).toISOString(), // 1 hora después\n        content: {\n          title: content.platforms.youtube.title,\n          description: content.platforms.youtube.description,\n          tags: content.platforms.youtube.tags.join(', ')\n        },\n        status: 'scheduled'\n      } : null\n    },\n    metadata: {\n      contentType: content.contentType,\n      engagementScore: content.engagementScore,\n      mlPrediction: content.mlPrediction\n    }\n  };\n  \n  scheduledPosts.push(scheduledPost);\n});\n\n// Guardar en historial de programación\nconst scheduleHistory = $workflow.staticData.scheduleHistory || [];\nscheduleHistory.push(...scheduledPosts);\n\n// Mantener solo últimos 100 posts programados\nif (scheduleHistory.length > 100) {\n  scheduleHistory.splice(0, scheduleHistory.length - 100);\n}\n\n$workflow.staticData.scheduleHistory = scheduleHistory;\n\nreturn [{\n  json: {\n    ...summary,\n    scheduledPosts: scheduledPosts,\n    postsScheduled: scheduledPosts.length,\n    nextPostTime: scheduledPosts[0]?.scheduledTime || null\n  }\n}];"
      },
      "id": "auto-scheduling",
      "name": "Auto Scheduling",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2450, 400],
      "notes": "Programa publicaciones automáticamente",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Análisis de engagement histórico\nconst summary = $json;\nconst enableEngagement = summary.enableEngagementAnalysis !== false;\n\nif (!enableEngagement) {\n  return [$input.item];\n}\n\n// Analizar engagement de videos procesados\nconst engagementAnalysis = {\n  timestamp: new Date().toISOString(),\n  totalVideos: summary.outputs?.length || 0,\n  totalLikes: 0,\n  totalViews: 0,\n  avgEngagementRate: 0,\n  topPerformers: [],\n  recommendations: []\n};\n\nif (summary.outputs && summary.outputs.length > 0) {\n  summary.outputs.forEach(video => {\n    const likes = video.like_count || 0;\n    const views = video.view_count || 0;\n    \n    engagementAnalysis.totalLikes += likes;\n    engagementAnalysis.totalViews += views;\n  });\n  \n  // Calcular engagement rate promedio\n  const totalEngagement = engagementAnalysis.totalLikes + (engagementAnalysis.totalViews / 10);\n  engagementAnalysis.avgEngagementRate = summary.outputs.length > 0 ? \n    (totalEngagement / summary.outputs.length).toFixed(2) : 0;\n  \n  // Top performers (top 3)\n  engagementAnalysis.topPerformers = summary.outputs\n    .map(v => ({\n      videoId: v.video_id,\n      title: v.title,\n      likes: v.like_count || 0,\n      views: v.view_count || 0,\n      engagementScore: (v.like_count || 0) + ((v.view_count || 0) / 10)\n    }))\n    .sort((a, b) => b.engagementScore - a.engagementScore)\n    .slice(0, 3);\n  \n  // Recomendaciones basadas en top performers\n  if (engagementAnalysis.topPerformers.length > 0) {\n    const topContentType = summary.optimizedContent?.find(\n      c => c.videoId === engagementAnalysis.topPerformers[0].videoId\n    )?.contentType || 'general';\n    \n    engagementAnalysis.recommendations.push({\n      type: 'content_type',\n      message: `El tipo de contenido '${topContentType}' tiene mejor rendimiento`,\n      action: `Priorizar contenido tipo '${topContentType}'`\n    });\n  }\n  \n  // Recomendación de frecuencia\n  const avgLikes = engagementAnalysis.totalLikes / summary.outputs.length;\n  if (avgLikes > 5000) {\n    engagementAnalysis.recommendations.push({\n      type: 'frequency',\n      message: 'Alto engagement detectado',\n      action: 'Considera aumentar frecuencia de publicaciones'\n    });\n  }\n}\n\nreturn [{\n  json: {\n    ...summary,\n    engagementAnalysis: engagementAnalysis\n  }\n}];"
      },
      "id": "engagement-analysis",
      "name": "Engagement Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2650, 400],
      "notes": "Análisis de engagement histórico",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Análisis de sentimiento del contenido\nconst summary = $json;\nconst enableSentiment = summary.enableSentimentAnalysis !== false;\n\nif (!enableSentiment || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\n// Análisis simple de sentimiento basado en palabras clave\nconst sentimentAnalysis = {\n  timestamp: new Date().toISOString(),\n  videosAnalyzed: summary.outputs.length,\n  sentimentScores: []\n};\n\nconst positiveWords = ['excelente', 'increíble', 'genial', 'perfecto', 'mejor', 'top', 'amazing', 'great', 'awesome', 'best'];\nconst negativeWords = ['malo', 'terrible', 'horrible', 'peor', 'bad', 'worst', 'terrible', 'awful'];\nconst neutralWords = ['tutorial', 'review', 'análisis', 'guía', 'tutorial', 'review', 'guide'];\n\nsummary.outputs.forEach(video => {\n  const title = (video.title || '').toLowerCase();\n  const description = (video.description || '').toLowerCase();\n  const text = `${title} ${description}`;\n  \n  let positiveCount = 0;\n  let negativeCount = 0;\n  let neutralCount = 0;\n  \n  positiveWords.forEach(word => {\n    if (text.includes(word)) positiveCount++;\n  });\n  \n  negativeWords.forEach(word => {\n    if (text.includes(word)) negativeCount++;\n  });\n  \n  neutralWords.forEach(word => {\n    if (text.includes(word)) neutralCount++;\n  });\n  \n  // Calcular score de sentimiento (-1 a 1)\n  const total = positiveCount + negativeCount + neutralCount;\n  const sentimentScore = total > 0 ? \n    ((positiveCount - negativeCount) / Math.max(total, 1)).toFixed(2) : 0;\n  \n  let sentiment = 'neutral';\n  if (sentimentScore > 0.3) sentiment = 'positive';\n  else if (sentimentScore < -0.3) sentiment = 'negative';\n  \n  sentimentAnalysis.sentimentScores.push({\n    videoId: video.video_id,\n    title: video.title,\n    sentiment: sentiment,\n    score: parseFloat(sentimentScore),\n    positiveWords: positiveCount,\n    negativeWords: negativeCount\n  });\n});\n\n// Estadísticas generales\nconst positiveCount = sentimentAnalysis.sentimentScores.filter(s => s.sentiment === 'positive').length;\nconst negativeCount = sentimentAnalysis.sentimentScores.filter(s => s.sentiment === 'negative').length;\nconst neutralCount = sentimentAnalysis.sentimentScores.filter(s => s.sentiment === 'neutral').length;\n\nsentimentAnalysis.summary = {\n  positive: positiveCount,\n  negative: negativeCount,\n  neutral: neutralCount,\n  avgSentiment: (sentimentAnalysis.sentimentScores.reduce((sum, s) => sum + parseFloat(s.score), 0) / sentimentAnalysis.sentimentScores.length).toFixed(2)\n};\n\nreturn [{\n  json: {\n    ...summary,\n    sentimentAnalysis: sentimentAnalysis\n  }\n}];"
      },
      "id": "sentiment-analysis",
      "name": "Sentiment Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2850, 400],
      "notes": "Análisis de sentimiento del contenido",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Exportar contenido a formatos específicos de plataformas\nconst summary = $json;\nconst enableExport = summary.enableContentExport !== false;\n\nif (!enableExport || !summary.optimizedContent || summary.optimizedContent.length === 0) {\n  return [$input.item];\n}\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst outputDir = summary.outputDir || './ai_video_outputs';\nconst exportDir = path.join(outputDir, 'social_media_exports');\n\n// Crear directorio de exportación\nfs.mkdirSync(exportDir, { recursive: true });\n\nconst exports = [];\n\nsummary.optimizedContent.forEach((content, idx) => {\n  const videoId = content.videoId || `video_${idx}`;\n  \n  // Exportar para TikTok\n  const tiktokExport = {\n    platform: 'tiktok',\n    videoId: videoId,\n    caption: content.platforms.tiktok.caption,\n    hashtags: content.platforms.tiktok.formattedHashtags,\n    scheduledTime: content.platforms.tiktok.bestTimeToPost.recommendedTimes[0],\n    file: path.join(exportDir, `tiktok_${videoId}.txt`)\n  };\n  \n  const tiktokContent = `${tiktokExport.caption}\\n\\n${tiktokExport.hashtags}\\n\\nProgramado para: ${tiktokExport.scheduledTime} UTC`;\n  fs.writeFileSync(tiktokExport.file, tiktokContent, 'utf-8');\n  exports.push(tiktokExport);\n  \n  // Exportar para Instagram si está habilitado\n  if (content.platforms.instagram) {\n    const instagramExport = {\n      platform: 'instagram',\n      videoId: videoId,\n      caption: content.platforms.instagram.caption,\n      hashtags: content.platforms.instagram.hashtags.join(' '),\n      scheduledTime: content.platforms.instagram.bestTimeToPost.recommendedTimes[0],\n      file: path.join(exportDir, `instagram_${videoId}.txt`)\n    };\n    \n    const instagramContent = `${instagramExport.caption}\\n\\n${instagramExport.hashtags}\\n\\nProgramado para: ${instagramExport.scheduledTime} UTC`;\n    fs.writeFileSync(instagramExport.file, instagramContent, 'utf-8');\n    exports.push(instagramExport);\n  }\n  \n  // Exportar para YouTube si está habilitado\n  if (content.platforms.youtube) {\n    const youtubeExport = {\n      platform: 'youtube',\n      videoId: videoId,\n      title: content.platforms.youtube.title,\n      description: content.platforms.youtube.description,\n      tags: content.platforms.youtube.tags.join(', '),\n      scheduledTime: content.platforms.youtube.bestTimeToPost.recommendedTimes[0],\n      file: path.join(exportDir, `youtube_${videoId}.txt`)\n    };\n    \n    const youtubeContent = `Título: ${youtubeExport.title}\\n\\nDescripción:\\n${youtubeExport.description}\\n\\nTags: ${youtubeExport.tags}\\n\\nProgramado para: ${youtubeExport.scheduledTime} UTC`;\n    fs.writeFileSync(youtubeExport.file, youtubeContent, 'utf-8');\n    exports.push(youtubeExport);\n  }\n  \n  // Exportar JSON completo\n  const jsonExport = {\n    platform: 'json',\n    videoId: videoId,\n    file: path.join(exportDir, `content_${videoId}.json`)\n  };\n  \n  fs.writeFileSync(jsonExport.file, JSON.stringify(content, null, 2), 'utf-8');\n  exports.push(jsonExport);\n});\n\nreturn [{\n  json: {\n    ...summary,\n    contentExports: exports,\n    exportsGenerated: exports.length,\n    exportDirectory: exportDir\n  }\n}];"
      },
      "id": "export-content",
      "name": "Export Content",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3050, 400],
      "notes": "Exporta contenido a formatos específicos de plataformas",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Análisis SEO avanzado\nconst summary = $json;\nconst enableSEO = summary.enableSEOAnalysis !== false;\n\nif (!enableSEO || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\nconst seoAnalysis = {\n  timestamp: new Date().toISOString(),\n  videosAnalyzed: summary.outputs.length,\n  keywordAnalysis: [],\n  seoScores: [],\n  recommendations: []\n};\n\n// Palabras clave comunes en IA/Tech\nconst techKeywords = ['ai', 'artificial intelligence', 'machine learning', 'automation', 'tutorial', 'guide', 'how to', 'tips', 'review', 'comparison'];\nconst spanishKeywords = ['ia', 'inteligencia artificial', 'aprendizaje automático', 'automatización', 'tutorial', 'guía', 'cómo', 'consejos', 'revisión', 'comparación'];\n\nsummary.outputs.forEach(video => {\n  const title = (video.title || '').toLowerCase();\n  const description = (video.description || '').toLowerCase();\n  const text = `${title} ${description}`;\n  \n  // Contar keywords encontradas\n  let keywordCount = 0;\n  const foundKeywords = [];\n  \n  [...techKeywords, ...spanishKeywords].forEach(keyword => {\n    if (text.includes(keyword)) {\n      keywordCount++;\n      foundKeywords.push(keyword);\n    }\n  });\n  \n  // Calcular score SEO (0-100)\n  const titleLength = title.length;\n  const descriptionLength = description.length;\n  \n  let seoScore = 0;\n  \n  // Título optimizado (50-60 caracteres)\n  if (titleLength >= 50 && titleLength <= 60) seoScore += 30;\n  else if (titleLength >= 40 && titleLength <= 70) seoScore += 20;\n  else seoScore += 10;\n  \n  // Descripción optimizada (150-160 caracteres)\n  if (descriptionLength >= 150 && descriptionLength <= 160) seoScore += 30;\n  else if (descriptionLength >= 120 && descriptionLength <= 200) seoScore += 20;\n  else seoScore += 10;\n  \n  // Keywords presentes\n  seoScore += Math.min(keywordCount * 10, 40);\n  \n  seoAnalysis.seoScores.push({\n    videoId: video.video_id,\n    title: video.title,\n    seoScore: seoScore,\n    keywordCount: keywordCount,\n    foundKeywords: foundKeywords.slice(0, 5),\n    titleLength: titleLength,\n    descriptionLength: descriptionLength,\n    recommendations: generateSEORecommendations(titleLength, descriptionLength, keywordCount)\n  });\n  \n  seoAnalysis.keywordAnalysis.push(...foundKeywords);\n});\n\n// Análisis de keywords más comunes\nconst keywordFrequency = {};\nseoAnalysis.keywordAnalysis.forEach(kw => {\n  keywordFrequency[kw] = (keywordFrequency[kw] || 0) + 1;\n});\n\nseoAnalysis.topKeywords = Object.entries(keywordFrequency)\n  .sort((a, b) => b[1] - a[1])\n  .slice(0, 10)\n  .map(([keyword, count]) => ({ keyword, count }));\n\n// Score promedio\nconst avgSEOScore = seoAnalysis.seoScores.reduce((sum, s) => sum + s.seoScore, 0) / seoAnalysis.seoScores.length;\nseoAnalysis.avgSEOScore = avgSEOScore.toFixed(2);\n\n// Recomendaciones generales\nif (avgSEOScore < 60) {\n  seoAnalysis.recommendations.push({\n    priority: 'high',\n    message: 'Score SEO promedio bajo. Considera optimizar títulos y descripciones.',\n    action: 'Agregar más keywords relevantes y optimizar longitud de títulos/descripciones'\n  });\n}\n\nfunction generateSEORecommendations(titleLen, descLen, kwCount) {\n  const recs = [];\n  \n  if (titleLen < 40) {\n    recs.push('Título muy corto. Ideal: 50-60 caracteres');\n  } else if (titleLen > 70) {\n    recs.push('Título muy largo. Ideal: 50-60 caracteres');\n  }\n  \n  if (descLen < 120) {\n    recs.push('Descripción muy corta. Ideal: 150-160 caracteres');\n  } else if (descLen > 200) {\n    recs.push('Descripción muy larga. Ideal: 150-160 caracteres');\n  }\n  \n  if (kwCount < 3) {\n    recs.push('Agregar más keywords relevantes');\n  }\n  \n  return recs;\n}\n\nreturn [{\n  json: {\n    ...summary,\n    seoAnalysis: seoAnalysis\n  }\n}];"
      },
      "id": "seo-analysis",
      "name": "SEO Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3250, 400],
      "notes": "Análisis SEO avanzado de títulos y descripciones",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Generación de thumbnails optimizados\nconst summary = $json;\nconst enableThumbnail = summary.enableThumbnailGeneration !== false;\n\nif (!enableThumbnail || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst outputDir = summary.outputDir || './ai_video_outputs';\nconst thumbnailDir = path.join(outputDir, 'thumbnails');\n\n// Crear directorio de thumbnails\nfs.mkdirSync(thumbnailDir, { recursive: true });\n\nconst thumbnailSpecs = [];\n\nsummary.outputs.forEach((video, idx) => {\n  const videoId = video.video_id || `video_${idx}`;\n  const title = video.title || 'Video de IA';\n  \n  // Generar especificaciones de thumbnail para diferentes plataformas\n  const specs = {\n    videoId: videoId,\n    title: title,\n    thumbnails: {\n      youtube: {\n        dimensions: { width: 1280, height: 720 },\n        aspectRatio: '16:9',\n        recommendedText: extractKeyPhrase(title, 5),\n        colorScheme: 'vibrant',\n        file: path.join(thumbnailDir, `youtube_${videoId}.jpg`),\n        description: 'Thumbnail optimizado para YouTube (1280x720)'\n      },\n      instagram: {\n        dimensions: { width: 1080, height: 1080 },\n        aspectRatio: '1:1',\n        recommendedText: extractKeyPhrase(title, 3),\n        colorScheme: 'bright',\n        file: path.join(thumbnailDir, `instagram_${videoId}.jpg`),\n        description: 'Thumbnail optimizado para Instagram (1080x1080)'\n      },\n      tiktok: {\n        dimensions: { width: 1080, height: 1920 },\n        aspectRatio: '9:16',\n        recommendedText: extractKeyPhrase(title, 4),\n        colorScheme: 'bold',\n        file: path.join(thumbnailDir, `tiktok_${videoId}.jpg`),\n        description: 'Thumbnail optimizado para TikTok (1080x1920)'\n      }\n    },\n    designRecommendations: generateDesignRecommendations(video)\n  };\n  \n  // Guardar especificaciones en JSON\n  const specFile = path.join(thumbnailDir, `specs_${videoId}.json`);\n  fs.writeFileSync(specFile, JSON.stringify(specs, null, 2), 'utf-8');\n  \n  thumbnailSpecs.push(specs);\n});\n\nfunction extractKeyPhrase(text, maxWords) {\n  const words = text.split(' ').filter(w => w.length > 3);\n  return words.slice(0, maxWords).join(' ');\n}\n\nfunction generateDesignRecommendations(video) {\n  const recommendations = [];\n  const contentType = video.contentType || 'general';\n  \n  if (contentType === 'tutorial') {\n    recommendations.push('Usar iconos de paso a paso');\n    recommendations.push('Colores educativos (azul, verde)');\n  } else if (contentType === 'review') {\n    recommendations.push('Mostrar producto/herramienta destacado');\n    recommendations.push('Colores de confianza (azul oscuro, dorado)');\n  } else if (contentType === 'tips') {\n    recommendations.push('Usar emojis o iconos llamativos');\n    recommendations.push('Colores vibrantes (naranja, amarillo)');\n  }\n  \n  recommendations.push('Texto grande y legible');\n  recommendations.push('Contraste alto para mejor visibilidad');\n  \n  return recommendations;\n}\n\nreturn [{\n  json: {\n    ...summary,\n    thumbnailSpecs: thumbnailSpecs,\n    thumbnailsGenerated: thumbnailSpecs.length,\n    thumbnailDirectory: thumbnailDir\n  }\n}];"
      },
      "id": "thumbnail-generation",
      "name": "Thumbnail Generation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3450, 400],
      "notes": "Genera especificaciones de thumbnails optimizados",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Tracking de rendimiento post-publicación\nconst summary = $json;\nconst enableTracking = summary.enablePerformanceTracking !== false;\n\nif (!enableTracking) {\n  return [$input.item];\n}\n\nconst performanceTracking = {\n  timestamp: new Date().toISOString(),\n  trackingEnabled: true,\n  metrics: {\n    scheduledPosts: summary.scheduledPosts?.length || 0,\n    contentVariants: summary.abTestVariants?.length || 0,\n    exportsGenerated: summary.contentExports?.length || 0\n  },\n  trackingSetup: {},\n  recommendations: []\n};\n\n// Configurar tracking para cada plataforma\nif (summary.scheduledPosts && summary.scheduledPosts.length > 0) {\n  performanceTracking.trackingSetup = {\n    tiktok: {\n      metrics: ['views', 'likes', 'shares', 'comments', 'engagement_rate'],\n      trackingPeriod: '7 days',\n      alerts: {\n        lowEngagement: { threshold: 0.02, action: 'Revisar contenido' },\n        highEngagement: { threshold: 0.10, action: 'Replicar estrategia' }\n      }\n    },\n    instagram: {\n      metrics: ['impressions', 'reach', 'likes', 'comments', 'saves', 'engagement_rate'],\n      trackingPeriod: '7 days',\n      alerts: {\n        lowEngagement: { threshold: 0.03, action: 'Optimizar hashtags' },\n        highEngagement: { threshold: 0.08, action: 'Aumentar frecuencia' }\n      }\n    },\n    youtube: {\n      metrics: ['views', 'watch_time', 'likes', 'comments', 'subscribers_gained', 'ctr'],\n      trackingPeriod: '30 days',\n      alerts: {\n        lowCTR: { threshold: 0.02, action: 'Mejorar thumbnail' },\n        highCTR: { threshold: 0.05, action: 'Replicar formato' }\n      }\n    }\n  };\n  \n  // Generar IDs de tracking únicos\n  performanceTracking.trackingIds = summary.scheduledPosts.map(post => ({\n    postId: post.postId,\n    videoId: post.videoId,\n    trackingId: `track_${post.videoId}_${Date.now()}`,\n    platforms: Object.keys(post.platforms || {}),\n    scheduledTime: post.scheduledTime\n  }));\n}\n\n// Recomendaciones de tracking\nperformanceTracking.recommendations.push({\n  type: 'monitoring',\n  message: 'Configurar webhooks para recibir métricas en tiempo real',\n  action: 'Integrar con APIs de plataformas para tracking automático'\n});\n\nperformanceTracking.recommendations.push({\n  type: 'analysis',\n  message: 'Revisar métricas después de 24-48 horas',\n  action: 'Comparar variantes A/B y ajustar estrategia'\n});\n\nreturn [{\n  json: {\n    ...summary,\n    performanceTracking: performanceTracking\n  }\n}];"
      },
      "id": "performance-tracking",
      "name": "Performance Tracking",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3650, 400],
      "notes": "Configura tracking de rendimiento post-publicación",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Generación de múltiples variantes de contenido\nconst summary = $json;\nconst enableMultiVariant = summary.enableMultiVariant !== false;\n\nif (!enableMultiVariant || !summary.optimizedContent || summary.optimizedContent.length === 0) {\n  return [$input.item];\n}\n\nconst multiVariants = [];\n\nsummary.optimizedContent.forEach((content, idx) => {\n  const baseContent = content;\n  \n  // Generar 3 variantes diferentes por video\n  const variants = [\n    {\n      variantId: `${content.videoId}_v1`,\n      name: 'Variante Conservadora',\n      style: 'professional',\n      caption: generateVariantCaption(baseContent.platforms.tiktok.caption, 'conservative'),\n      hashtags: baseContent.platforms.tiktok.hashtags.slice(0, 8),\n      emojiUsage: 'minimal',\n      tone: 'informative'\n    },\n    {\n      variantId: `${content.videoId}_v2`,\n      name: 'Variante Viral',\n      style: 'engaging',\n      caption: generateVariantCaption(baseContent.platforms.tiktok.caption, 'viral'),\n      hashtags: [...baseContent.platforms.tiktok.hashtags.slice(0, 5), '#FYP', '#Viral', '#Trending'],\n      emojiUsage: 'high',\n      tone: 'exciting'\n    },\n    {\n      variantId: `${content.videoId}_v3`,\n      name: 'Variante Balanceada',\n      style: 'balanced',\n      caption: generateVariantCaption(baseContent.platforms.tiktok.caption, 'balanced'),\n      hashtags: baseContent.platforms.tiktok.hashtags,\n      emojiUsage: 'moderate',\n      tone: 'friendly'\n    }\n  ];\n  \n  multiVariants.push({\n    videoId: content.videoId,\n    title: content.title,\n    variants: variants,\n    recommendedVariant: 'v2', // Variante viral por defecto\n    testingStrategy: {\n      testDuration: '7 days',\n      metrics: ['engagement_rate', 'views', 'shares'],\n      successCriteria: 'engagement_rate > 0.05'\n    }\n  });\n});\n\nfunction generateVariantCaption(originalCaption, style) {\n  const lines = originalCaption.split('\\n');\n  \n  if (style === 'conservative') {\n    // Versión más profesional, menos emojis\n    return lines[0] + '\\n\\n' + lines.slice(1).join('\\n').replace(/[🔥💡📚✨]/g, '');\n  } else if (style === 'viral') {\n    // Versión más llamativa con más emojis\n    return lines[0] + '\\n\\n🔥 ' + lines.slice(1).join('\\n') + '\\n\\n💯 ¡No te lo pierdas!';\n  } else {\n    // Balanceada\n    return originalCaption;\n  }\n}\n\nreturn [{\n  json: {\n    ...summary,\n    multiVariants: multiVariants,\n    totalVariants: multiVariants.reduce((sum, mv) => sum + mv.variants.length, 0)\n  }\n}];"
      },
      "id": "multi-variant",
      "name": "Multi-Variant Generation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3850, 400],
      "notes": "Genera múltiples variantes de contenido para testing",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Recomendaciones avanzadas basadas en análisis completo\nconst summary = $json;\nconst enableAdvanced = summary.enableAdvancedRecommendations !== false;\n\nif (!enableAdvanced) {\n  return [$input.item];\n}\n\nconst advancedRecommendations = {\n  timestamp: new Date().toISOString(),\n  recommendations: [],\n  priorityActions: [],\n  longTermStrategy: []\n};\n\n// Analizar todos los datos disponibles\nconst hasCompetitorData = !!summary.competitorAnalysis;\nconst hasSEOData = !!summary.seoAnalysis;\nconst hasEngagementData = !!summary.engagementAnalysis;\nconst hasSentimentData = !!summary.sentimentAnalysis;\nconst hasABTesting = !!summary.abTestVariants;\nconst hasMultiVariants = !!summary.multiVariants;\n\n// Recomendaciones basadas en SEO\nif (hasSEOData && summary.seoAnalysis.avgSEOScore < 60) {\n  advancedRecommendations.recommendations.push({\n    category: 'SEO',\n    priority: 'high',\n    title: 'Optimizar SEO de contenido',\n    description: `Score SEO promedio: ${summary.seoAnalysis.avgSEOScore}. Mejorar títulos y descripciones.`,\n    action: 'Revisar y optimizar títulos (50-60 caracteres) y descripciones (150-160 caracteres)',\n    impact: 'high',\n    effort: 'medium'\n  });\n}\n\n// Recomendaciones basadas en competencia\nif (hasCompetitorData && summary.competitorAnalysis.competitorInsights.bestPerformingType) {\n  advancedRecommendations.recommendations.push({\n    category: 'Content Strategy',\n    priority: 'medium',\n    title: 'Enfocarse en tipo de contenido de alto rendimiento',\n    description: `El tipo '${summary.competitorAnalysis.competitorInsights.bestPerformingType}' tiene mejor rendimiento.`,\n    action: `Priorizar creación de contenido tipo '${summary.competitorAnalysis.competitorInsights.bestPerformingType}'`,\n    impact: 'high',\n    effort: 'low'\n  });\n}\n\n// Recomendaciones basadas en engagement\nif (hasEngagementData && summary.engagementAnalysis.avgEngagementRate > 5000) {\n  advancedRecommendations.recommendations.push({\n    category: 'Publishing',\n    priority: 'high',\n    title: 'Aumentar frecuencia de publicaciones',\n    description: 'Alto engagement detectado. Aprovechar el momentum.',\n    action: 'Aumentar frecuencia de publicaciones de 1x/semana a 2-3x/semana',\n    impact: 'high',\n    effort: 'medium'\n  });\n}\n\n// Recomendaciones basadas en sentimiento\nif (hasSentimentData && summary.sentimentAnalysis.summary.avgSentiment < 0) {\n  advancedRecommendations.recommendations.push({\n    category: 'Content Quality',\n    priority: 'medium',\n    title: 'Mejorar tono del contenido',\n    description: 'Sentimiento promedio negativo detectado.',\n    action: 'Revisar y ajustar tono del contenido hacia más positivo',\n    impact: 'medium',\n    effort: 'low'\n  });\n}\n\n// Recomendaciones de testing\nif (hasABTesting || hasMultiVariants) {\n  advancedRecommendations.recommendations.push({\n    category: 'Testing',\n    priority: 'high',\n    title: 'Implementar testing sistemático',\n    description: 'Variantes A/B y múltiples variantes generadas. Implementar testing.',\n    action: 'Publicar variantes y comparar métricas después de 48-72 horas',\n    impact: 'high',\n    effort: 'low'\n  });\n}\n\n// Recomendaciones de thumbnails\nif (summary.thumbnailSpecs && summary.thumbnailSpecs.length > 0) {\n  advancedRecommendations.recommendations.push({\n    category: 'Visual Content',\n    priority: 'medium',\n    title: 'Crear thumbnails personalizados',\n    description: 'Especificaciones de thumbnails generadas. Crear thumbnails visuales.',\n    action: 'Usar herramientas de diseño (Canva, Figma) con las especificaciones proporcionadas',\n    impact: 'high',\n    effort: 'medium'\n  });\n}\n\n// Priorizar acciones\nadvancedRecommendations.priorityActions = advancedRecommendations.recommendations\n  .filter(r => r.priority === 'high')\n  .slice(0, 3)\n  .map(r => r.action);\n\n// Estrategia a largo plazo\nadvancedRecommendations.longTermStrategy = [\n  'Establecer calendario de contenido basado en análisis de rendimiento',\n  'Implementar ciclo de mejora continua: publicar → medir → optimizar → repetir',\n  'Construir biblioteca de contenido de alto rendimiento para referencia futura',\n  'Desarrollar plantillas basadas en contenido que funciona mejor'\n];\n\nreturn [{\n  json: {\n    ...summary,\n    advancedRecommendations: advancedRecommendations\n  }\n}];"
      },
      "id": "advanced-recommendations",
      "name": "Advanced Recommendations",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4050, 400],
      "notes": "Genera recomendaciones avanzadas basadas en análisis completo",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Publicación automática en redes sociales\nconst summary = $json;\nconst enablePublishing = summary.enableAutoPublishing !== false;\n\nif (!enablePublishing || !summary.scheduledPosts || summary.scheduledPosts.length === 0) {\n  return [$input.item];\n}\n\nconst publishingResults = {\n  timestamp: new Date().toISOString(),\n  published: [],\n  failed: [],\n  pending: []\n};\n\nconst now = new Date();\n\nsummary.scheduledPosts.forEach(post => {\n  const scheduledTime = new Date(post.scheduledTime);\n  \n  // Verificar si es hora de publicar (con margen de 5 minutos)\n  const timeDiff = scheduledTime.getTime() - now.getTime();\n  const fiveMinutes = 5 * 60 * 1000;\n  \n  if (timeDiff <= fiveMinutes && timeDiff >= -fiveMinutes) {\n    // Es hora de publicar\n    const publishResult = {\n      postId: post.postId,\n      videoId: post.videoId,\n      platform: 'tiktok',\n      status: 'ready_to_publish',\n      scheduledTime: post.scheduledTime,\n      actualTime: now.toISOString(),\n      content: post.platforms.tiktok.content,\n      apiEndpoint: 'tiktok_api_endpoint', // Configurar según API real\n      note: 'Requiere integración con API de TikTok para publicación real'\n    };\n    \n    publishingResults.published.push(publishResult);\n  } else if (timeDiff > 0) {\n    // Aún no es hora\n    publishingResults.pending.push({\n      postId: post.postId,\n      scheduledTime: post.scheduledTime,\n      timeUntilPublish: Math.round(timeDiff / 1000 / 60) + ' minutos'\n    });\n  }\n});\n\npublishingResults.summary = {\n  readyToPublish: publishingResults.published.length,\n  pending: publishingResults.pending.length,\n  failed: publishingResults.failed.length\n};\n\nreturn [{\n  json: {\n    ...summary,\n    publishingResults: publishingResults\n  }\n}];"
      },
      "id": "auto-publishing",
      "name": "Auto Publishing",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4250, 400],
      "notes": "Publicación automática en redes sociales",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Análisis de tendencias en tiempo real\nconst summary = $json;\nconst enableTrends = summary.enableRealTimeTrendAnalysis !== false;\n\nif (!enableTrends || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\nconst trendAnalysis = {\n  timestamp: new Date().toISOString(),\n  trendingTopics: [],\n  emergingKeywords: [],\n  contentTrends: {},\n  recommendations: []\n};\n\n// Analizar palabras clave emergentes\nconst keywordFrequency = {};\nconst recentKeywords = [];\n\nsummary.outputs.forEach(video => {\n  const title = (video.title || '').toLowerCase();\n  const description = (video.description || '').toLowerCase();\n  const words = `${title} ${description}`.split(/\\s+/).filter(w => w.length > 4);\n  \n  words.forEach(word => {\n    keywordFrequency[word] = (keywordFrequency[word] || 0) + 1;\n    recentKeywords.push(word);\n  });\n});\n\n// Identificar keywords trending (aparecen en múltiples videos)\nconst trendingKeywords = Object.entries(keywordFrequency)\n  .filter(([word, count]) => count >= 2)\n  .sort((a, b) => b[1] - a[1])\n  .slice(0, 10)\n  .map(([word, count]) => ({ keyword: word, frequency: count, trend: 'rising' }));\n\ntrendAnalysis.trendingTopics = trendingKeywords;\n\n// Identificar keywords emergentes (nuevas)\nconst allKeywords = Object.keys(keywordFrequency);\ntrendAnalysis.emergingKeywords = allKeywords\n  .filter(kw => !['tutorial', 'video', 'guide', 'review'].includes(kw))\n  .slice(0, 5)\n  .map(kw => ({ keyword: kw, frequency: keywordFrequency[kw], trend: 'emerging' }));\n\n// Analizar tendencias de contenido\nconst contentTypeTrends = {};\nsummary.outputs.forEach(video => {\n  const type = video.contentType || 'general';\n  contentTypeTrends[type] = (contentTypeTrends[type] || 0) + 1;\n});\n\ntrendAnalysis.contentTrends = {\n  mostPopularType: Object.entries(contentTypeTrends).sort((a, b) => b[1] - a[1])[0]?.[0] || 'general',\n  distribution: contentTypeTrends\n};\n\n// Recomendaciones basadas en tendencias\nif (trendingKeywords.length > 0) {\n  trendAnalysis.recommendations.push({\n    type: 'keyword',\n    priority: 'high',\n    message: `Keywords trending detectadas: ${trendingKeywords.slice(0, 3).map(k => k.keyword).join(', ')}`,\n    action: 'Incluir estas keywords en próximos contenidos'\n  });\n}\n\nif (trendAnalysis.contentTrends.mostPopularType) {\n  trendAnalysis.recommendations.push({\n    type: 'content',\n    priority: 'medium',\n    message: `Tipo de contenido más popular: ${trendAnalysis.contentTrends.mostPopularType}`,\n    action: `Priorizar creación de contenido tipo '${trendAnalysis.contentTrends.mostPopularType}'`\n  });\n}\n\nreturn [{\n  json: {\n    ...summary,\n    realTimeTrendAnalysis: trendAnalysis\n  }\n}];"
      },
      "id": "realtime-trend-analysis",
      "name": "Real-Time Trend Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4450, 400],
      "notes": "Análisis de tendencias en tiempo real",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Generación automática de contenido mejorado\nconst summary = $json;\nconst enableGen = summary.enableContentGeneration !== false;\n\nif (!enableGen || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\nconst contentGeneration = {\n  timestamp: new Date().toISOString(),\n  generatedContent: [],\n  templates: []\n};\n\n// Generar plantillas de contenido basadas en videos exitosos\nconst topPerformers = summary.outputs\n  .sort((a, b) => ((b.like_count || 0) + (b.view_count || 0) / 10) - ((a.like_count || 0) + (a.view_count || 0) / 10))\n  .slice(0, 3);\n\ntopPerformers.forEach((video, idx) => {\n  const template = {\n    templateId: `template_${idx + 1}`,\n    basedOn: video.video_id,\n    title: video.title,\n    structure: {\n      hook: extractHook(video.title),\n      mainContent: extractMainContent(video.description || ''),\n      callToAction: generateCTA(video.contentType || 'general')\n    },\n    contentType: video.contentType || 'general',\n    successMetrics: {\n      likes: video.like_count || 0,\n      views: video.view_count || 0\n    }\n  };\n  \n  contentGeneration.templates.push(template);\n});\n\n// Generar contenido nuevo basado en plantillas\nsummary.outputs.slice(0, 3).forEach((video, idx) => {\n  const generated = {\n    contentId: `gen_${video.video_id}_${Date.now()}`,\n    baseVideo: video.video_id,\n    variations: [\n      generateContentVariation(video, 'short'),\n      generateContentVariation(video, 'long'),\n      generateContentVariation(video, 'viral')\n    ],\n    recommendedPlatform: determineBestPlatform(video),\n    estimatedEngagement: estimateEngagement(video)\n  };\n  \n  contentGeneration.generatedContent.push(generated);\n});\n\nfunction extractHook(title) {\n  const words = title.split(' ').slice(0, 5);\n  return words.join(' ') + '...';\n}\n\nfunction extractMainContent(description) {\n  if (!description) return 'Contenido educativo sobre IA y automatización';\n  const sentences = description.split('.').slice(0, 2);\n  return sentences.join('. ');\n}\n\nfunction generateCTA(contentType) {\n  const ctas = {\n    tutorial: '📥 Descarga el PDF completo para aprender paso a paso',\n    review: '💬 ¿Qué opinas? Déjame saber en los comentarios',\n    tips: '👍 Si te gustó, comparte con tus amigos',\n    default: '🔔 Suscríbete para más contenido como este'\n  };\n  return ctas[contentType] || ctas.default;\n}\n\nfunction generateContentVariation(video, style) {\n  const title = video.title || 'Video de IA';\n  \n  if (style === 'short') {\n    return {\n      style: 'short',\n      title: title.length > 40 ? title.substring(0, 37) + '...' : title,\n      description: 'Contenido breve y directo',\n      length: '30-60 segundos'\n    };\n  } else if (style === 'long') {\n    return {\n      style: 'long',\n      title: `Guía Completa: ${title}`,\n      description: 'Contenido detallado y educativo',\n      length: '5-10 minutos'\n    };\n  } else {\n    return {\n      style: 'viral',\n      title: `🔥 ${title} - No te lo pierdas!`,\n      description: 'Contenido optimizado para viralidad',\n      length: '15-30 segundos'\n    };\n  }\n}\n\nfunction determineBestPlatform(video) {\n  const likes = video.like_count || 0;\n  if (likes > 10000) return 'youtube';\n  if (likes > 5000) return 'instagram';\n  return 'tiktok';\n}\n\nfunction estimateEngagement(video) {\n  const baseEngagement = (video.like_count || 0) + ((video.view_count || 0) / 10);\n  return {\n    estimatedLikes: Math.round(baseEngagement * 0.8),\n    estimatedViews: Math.round((video.view_count || 0) * 0.7),\n    confidence: baseEngagement > 5000 ? 'high' : 'medium'\n  };\n}\n\nreturn [{\n  json: {\n    ...summary,\n    contentGeneration: contentGeneration\n  }\n}];"
      },
      "id": "content-generation",
      "name": "Content Generation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4650, 400],
      "notes": "Generación automática de contenido mejorado",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Sistema de feedback loop\nconst summary = $json;\nconst enableFeedback = summary.enableFeedbackLoop !== false;\n\nif (!enableFeedback) {\n  return [$input.item];\n}\n\nconst feedbackLoop = {\n  timestamp: new Date().toISOString(),\n  feedbackData: [],\n  improvements: [],\n  nextIteration: {}\n};\n\n// Analizar métricas de rendimiento para feedback\nconst metrics = {\n  totalVideos: summary.outputs?.length || 0,\n  avgLikes: 0,\n  avgViews: 0,\n  successRate: 0,\n  errorRate: 0\n};\n\nif (summary.outputs && summary.outputs.length > 0) {\n  const totalLikes = summary.outputs.reduce((sum, v) => sum + (v.like_count || 0), 0);\n  const totalViews = summary.outputs.reduce((sum, v) => sum + (v.view_count || 0), 0);\n  \n  metrics.avgLikes = Math.round(totalLikes / summary.outputs.length);\n  metrics.avgViews = Math.round(totalViews / summary.outputs.length);\n  \n  const successful = summary.outputs.filter(v => (v.like_count || 0) > 1000).length;\n  metrics.successRate = ((successful / summary.outputs.length) * 100).toFixed(2);\n  metrics.errorRate = ((summary.errors?.length || 0) / summary.outputs.length * 100).toFixed(2);\n}\n\nfeedbackLoop.feedbackData = metrics;\n\n// Identificar mejoras basadas en métricas\nif (metrics.avgLikes < 2000) {\n  feedbackLoop.improvements.push({\n    area: 'content_quality',\n    issue: 'Engagement promedio bajo',\n    recommendation: 'Mejorar calidad de contenido y optimizar títulos',\n    priority: 'high'\n  });\n}\n\nif (parseFloat(metrics.errorRate) > 10) {\n  feedbackLoop.improvements.push({\n    area: 'reliability',\n    issue: 'Tasa de error alta',\n    recommendation: 'Revisar y mejorar manejo de errores',\n    priority: 'high'\n  });\n}\n\nif (summary.seoAnalysis && parseFloat(summary.seoAnalysis.avgSEOScore) < 60) {\n  feedbackLoop.improvements.push({\n    area: 'seo',\n    issue: 'Score SEO bajo',\n    recommendation: 'Optimizar títulos y descripciones para SEO',\n    priority: 'medium'\n  });\n}\n\n// Configurar próxima iteración\nfeedbackLoop.nextIteration = {\n  focusAreas: feedbackLoop.improvements.map(i => i.area),\n  adjustments: {\n    minVideoQuality: metrics.avgLikes > 5000 ? Math.round(metrics.avgLikes * 0.8) : 1000,\n    contentTypes: summary.contentGeneration?.templates.map(t => t.contentType) || [],\n    keywords: summary.realTimeTrendAnalysis?.trendingTopics.slice(0, 5).map(t => t.keyword) || []\n  },\n  expectedImprovement: '10-15% en engagement y reducción de errores'\n};\n\nreturn [{\n  json: {\n    ...summary,\n    feedbackLoop: feedbackLoop\n  }\n}];"
      },
      "id": "feedback-loop",
      "name": "Feedback Loop",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4850, 400],
      "notes": "Sistema de feedback loop para mejora continua",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Dashboard en tiempo real\nconst summary = $json;\nconst enableDashboard = summary.enableRealTimeDashboard !== false;\n\nif (!enableDashboard) {\n  return [$input.item];\n}\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst outputDir = summary.outputDir || './ai_video_outputs';\nconst dashboardDir = path.join(outputDir, 'dashboard');\n\nfs.mkdirSync(dashboardDir, { recursive: true });\n\nconst dashboard = {\n  timestamp: new Date().toISOString(),\n  executionId: summary.executionId,\n  overview: {\n    totalVideos: summary.outputs?.length || 0,\n    pdfsGenerated: summary.pdfs_generated || 0,\n    successRate: summary.metrics?.successRate || '0%',\n    duration: summary.metrics?.durationFormatted || '0s'\n  },\n  performance: {\n    videosPerMinute: summary.metrics?.videosPerMinute || 0,\n    avgProcessingTime: summary.metrics?.avgProcessingTime || '0s',\n    errorRate: summary.metrics?.errorRate || '0%'\n  },\n  content: {\n    optimizedContent: summary.optimizedContent?.length || 0,\n    scheduledPosts: summary.scheduledPosts?.length || 0,\n    variantsGenerated: summary.totalVariants || 0,\n    thumbnailsGenerated: summary.thumbnailSpecs?.length || 0\n  },\n  analytics: {\n    seoScore: summary.seoAnalysis?.avgSEOScore || 'N/A',\n    engagementRate: summary.engagementAnalysis?.avgEngagementRate || 'N/A',\n    sentimentScore: summary.sentimentAnalysis?.summary.avgSentiment || 'N/A'\n  },\n  trends: summary.realTimeTrendAnalysis || null,\n  recommendations: summary.advancedRecommendations?.priorityActions || [],\n  nextActions: summary.feedbackLoop?.nextIteration || null\n};\n\n// Guardar dashboard como JSON\nconst dashboardFile = path.join(dashboardDir, `dashboard_${summary.executionId}.json`);\nfs.writeFileSync(dashboardFile, JSON.stringify(dashboard, null, 2), 'utf-8');\n\n// Generar resumen HTML simple\nconst htmlDashboard = `<!DOCTYPE html>\n<html>\n<head>\n  <title>AI Video Pipeline Dashboard</title>\n  <style>\n    body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }\n    .container { max-width: 1200px; margin: 0 auto; }\n    .card { background: white; padding: 20px; margin: 10px 0; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n    h1 { color: #333; }\n    h2 { color: #666; border-bottom: 2px solid #4CAF50; padding-bottom: 10px; }\n    .metric { display: inline-block; margin: 10px 20px; text-align: center; }\n    .metric-value { font-size: 2em; font-weight: bold; color: #4CAF50; }\n    .metric-label { color: #666; font-size: 0.9em; }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <h1>🚀 AI Video Pipeline Dashboard</h1>\n    <div class=\"card\">\n      <h2>📊 Overview</h2>\n      <div class=\"metric\"><div class=\"metric-value\">${dashboard.overview.totalVideos}</div><div class=\"metric-label\">Videos</div></div>\n      <div class=\"metric\"><div class=\"metric-value\">${dashboard.overview.pdfsGenerated}</div><div class=\"metric-label\">PDFs</div></div>\n      <div class=\"metric\"><div class=\"metric-value\">${dashboard.overview.successRate}</div><div class=\"metric-label\">Success Rate</div></div>\n    </div>\n    <div class=\"card\">\n      <h2>⚡ Performance</h2>\n      <div class=\"metric\"><div class=\"metric-value\">${dashboard.performance.videosPerMinute}</div><div class=\"metric-label\">Videos/Min</div></div>\n      <div class=\"metric\"><div class=\"metric-value\">${dashboard.performance.avgProcessingTime}</div><div class=\"metric-label\">Avg Time</div></div>\n    </div>\n    <div class=\"card\">\n      <h2>📱 Content</h2>\n      <div class=\"metric\"><div class=\"metric-value\">${dashboard.content.optimizedContent}</div><div class=\"metric-label\">Optimized</div></div>\n      <div class=\"metric\"><div class=\"metric-value\">${dashboard.content.scheduledPosts}</div><div class=\"metric-label\">Scheduled</div></div>\n      <div class=\"metric\"><div class=\"metric-value\">${dashboard.content.variantsGenerated}</div><div class=\"metric-label\">Variants</div></div>\n    </div>\n    <div class=\"card\">\n      <h2>📈 Analytics</h2>\n      <div class=\"metric\"><div class=\"metric-value\">${dashboard.analytics.seoScore}</div><div class=\"metric-label\">SEO Score</div></div>\n      <div class=\"metric\"><div class=\"metric-value\">${dashboard.analytics.engagementRate}</div><div class=\"metric-label\">Engagement</div></div>\n    </div>\n    <p><small>Last updated: ${dashboard.timestamp}</small></p>\n  </div>\n</body>\n</html>`;\n\nconst htmlFile = path.join(dashboardDir, `dashboard_${summary.executionId}.html`);\nfs.writeFileSync(htmlFile, htmlDashboard, 'utf-8');\n\nreturn [{\n  json: {\n    ...summary,\n    realTimeDashboard: {\n      created: true,\n      jsonFile: dashboardFile,\n      htmlFile: htmlFile,\n      data: dashboard\n    }\n  }\n}];"
      },
      "id": "realtime-dashboard",
      "name": "Real-Time Dashboard",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5050, 400],
      "notes": "Genera dashboard en tiempo real",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Monitoreo avanzado de competidores\nconst summary = $json;\nconst enableMonitoring = summary.enableCompetitorMonitoring !== false;\n\nif (!enableMonitoring || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\nconst competitorMonitoring = {\n  timestamp: new Date().toISOString(),\n  competitors: [],\n  insights: {},\n  alerts: []\n};\n\n// Analizar patrones de contenido de competencia\nconst contentPatterns = {\n  titleLengths: [],\n  commonKeywords: {},\n  postingTimes: [],\n  engagementPatterns: {}\n};\n\nsummary.outputs.forEach(video => {\n  // Analizar longitud de títulos\n  contentPatterns.titleLengths.push((video.title || '').length);\n  \n  // Analizar keywords\n  const title = (video.title || '').toLowerCase();\n  const words = title.split(/\\s+/).filter(w => w.length > 3);\n  words.forEach(word => {\n    contentPatterns.commonKeywords[word] = (contentPatterns.commonKeywords[word] || 0) + 1;\n  });\n  \n  // Analizar engagement\n  const engagement = (video.like_count || 0) + ((video.view_count || 0) / 10);\n  const contentType = video.contentType || 'general';\n  contentPatterns.engagementPatterns[contentType] = \n    (contentPatterns.engagementPatterns[contentType] || 0) + engagement;\n});\n\n// Identificar mejores prácticas\nconst avgTitleLength = contentPatterns.titleLengths.reduce((a, b) => a + b, 0) / contentPatterns.titleLengths.length;\nconst topKeywords = Object.entries(contentPatterns.commonKeywords)\n  .sort((a, b) => b[1] - a[1])\n  .slice(0, 5)\n  .map(([keyword, count]) => ({ keyword, frequency: count }));\n\ncompetitorMonitoring.insights = {\n  optimalTitleLength: Math.round(avgTitleLength),\n  topKeywords: topKeywords,\n  bestPerformingContentType: Object.entries(contentPatterns.engagementPatterns)\n    .sort((a, b) => b[1] - a[1])[0]?.[0] || 'general',\n  engagementBenchmarks: {\n    high: Object.values(contentPatterns.engagementPatterns).reduce((a, b) => Math.max(a, b), 0),\n    average: Object.values(contentPatterns.engagementPatterns).reduce((a, b) => a + b, 0) / Object.keys(contentPatterns.engagementPatterns).length\n  }\n};\n\n// Generar alertas si detectamos cambios significativos\nif (avgTitleLength < 40 || avgTitleLength > 70) {\n  competitorMonitoring.alerts.push({\n    type: 'title_optimization',\n    severity: 'medium',\n    message: `Longitud promedio de títulos fuera del rango óptimo (${Math.round(avgTitleLength)} caracteres)`,\n    recommendation: 'Ajustar longitud de títulos a 50-60 caracteres'\n  });\n}\n\n// Comparar con nuestros propios estándares\nif (summary.seoAnalysis && parseFloat(summary.seoAnalysis.avgSEOScore) < 60) {\n  competitorMonitoring.alerts.push({\n    type: 'seo_gap',\n    severity: 'high',\n    message: 'Score SEO por debajo del estándar de competencia',\n    recommendation: 'Implementar mejoras SEO inmediatas'\n  });\n}\n\ncompetitorMonitoring.competitors = [{\n  name: 'Market Average',\n  metrics: {\n    avgTitleLength: Math.round(avgTitleLength),\n    topKeywords: topKeywords.slice(0, 3),\n    avgEngagement: competitorMonitoring.insights.engagementBenchmarks.average\n  }\n}];\n\nreturn [{\n  json: {\n    ...summary,\n    competitorMonitoring: competitorMonitoring\n  }\n}];"
      },
      "id": "competitor-monitoring",
      "name": "Competitor Monitoring",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5250, 400],
      "notes": "Monitoreo avanzado de competidores",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Análisis profundo de video\nconst summary = $json;\nconst enableDeep = summary.enableDeepVideoAnalysis !== false;\n\nif (!enableDeep || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\nconst deepAnalysis = {\n  timestamp: new Date().toISOString(),\n  videosAnalyzed: summary.outputs.length,\n  analysisResults: []\n};\n\nsummary.outputs.forEach(video => {\n  const analysis = {\n    videoId: video.video_id,\n    title: video.title,\n    metadata: {\n      duration: video.duration || 'unknown',\n      resolution: video.resolution || 'unknown',\n      frameRate: video.frame_rate || 'unknown'\n    },\n    contentAnalysis: {\n      sceneComplexity: estimateSceneComplexity(video),\n      visualElements: detectVisualElements(video.title || ''),\n      audioQuality: estimateAudioQuality(video),\n      editingStyle: detectEditingStyle(video)\n    },\n    qualityMetrics: {\n      productionValue: calculateProductionValue(video),\n      engagementPotential: calculateEngagementPotential(video),\n      viralScore: calculateViralScore(video)\n    },\n    recommendations: generateDeepAnalysisRecommendations(video)\n  };\n  \n  deepAnalysis.analysisResults.push(analysis);\n});\n\n// Estadísticas agregadas\ndeepAnalysis.summary = {\n  avgProductionValue: deepAnalysis.analysisResults.reduce((sum, a) => sum + a.qualityMetrics.productionValue, 0) / deepAnalysis.analysisResults.length,\n  avgViralScore: deepAnalysis.analysisResults.reduce((sum, a) => sum + a.qualityMetrics.viralScore, 0) / deepAnalysis.analysisResults.length,\n  topVideos: deepAnalysis.analysisResults\n    .sort((a, b) => b.qualityMetrics.viralScore - a.qualityMetrics.viralScore)\n    .slice(0, 3)\n    .map(a => ({ videoId: a.videoId, title: a.title, viralScore: a.qualityMetrics.viralScore }))\n};\n\nfunction estimateSceneComplexity(video) {\n  const title = (video.title || '').toLowerCase();\n  if (title.includes('tutorial') || title.includes('step')) return 'medium';\n  if (title.includes('review') || title.includes('comparison')) return 'high';\n  return 'low';\n}\n\nfunction detectVisualElements(title) {\n  const elements = [];\n  const lowerTitle = title.toLowerCase();\n  if (lowerTitle.includes('screen') || lowerTitle.includes('demo')) elements.push('screen_recording');\n  if (lowerTitle.includes('face') || lowerTitle.includes('person')) elements.push('talking_head');\n  if (lowerTitle.includes('animation') || lowerTitle.includes('graphic')) elements.push('graphics');\n  return elements.length > 0 ? elements : ['mixed'];\n}\n\nfunction estimateAudioQuality(video) {\n  // Basado en engagement - videos con más likes probablemente tienen mejor audio\n  const likes = video.like_count || 0;\n  if (likes > 5000) return 'high';\n  if (likes > 1000) return 'medium';\n  return 'unknown';\n}\n\nfunction detectEditingStyle(video) {\n  const title = (video.title || '').toLowerCase();\n  if (title.includes('quick') || title.includes('fast')) return 'fast_paced';\n  if (title.includes('detailed') || title.includes('complete')) return 'detailed';\n  return 'standard';\n}\n\nfunction calculateProductionValue(video) {\n  let score = 50; // Base\n  const likes = video.like_count || 0;\n  const views = video.view_count || 0;\n  \n  // Engagement indica producción de calidad\n  if (likes > 5000) score += 30;\n  else if (likes > 1000) score += 15;\n  \n  // Views también indican calidad\n  if (views > 100000) score += 20;\n  else if (views > 10000) score += 10;\n  \n  return Math.min(score, 100);\n}\n\nfunction calculateEngagementPotential(video) {\n  const likes = video.like_count || 0;\n  const views = video.view_count || 0;\n  const engagementRate = views > 0 ? (likes / views) : 0;\n  \n  return Math.min(Math.round(engagementRate * 1000), 100);\n}\n\nfunction calculateViralScore(video) {\n  const likes = video.like_count || 0;\n  const views = video.view_count || 0;\n  const title = (video.title || '').toLowerCase();\n  \n  let score = 0;\n  \n  // Engagement\n  score += Math.min(likes / 100, 40);\n  \n  // Viral keywords\n  const viralKeywords = ['viral', 'trending', 'shocking', 'amazing', 'incredible'];\n  if (viralKeywords.some(kw => title.includes(kw))) score += 20;\n  \n  // View-to-like ratio\n  if (views > 0) {\n    const ratio = likes / views;\n    if (ratio > 0.05) score += 20;\n    else if (ratio > 0.02) score += 10;\n  }\n  \n  return Math.min(score, 100);\n}\n\nfunction generateDeepAnalysisRecommendations(video) {\n  const recommendations = [];\n  const viralScore = calculateViralScore(video);\n  \n  if (viralScore < 50) {\n    recommendations.push('Mejorar hook inicial para aumentar retención');\n    recommendations.push('Agregar elementos visuales más llamativos');\n  }\n  \n  if (video.like_count < 1000) {\n    recommendations.push('Optimizar título para mejor descubrimiento');\n    recommendations.push('Mejorar calidad de audio y video');\n  }\n  \n  return recommendations;\n}\n\nreturn [{\n  json: {\n    ...summary,\n    deepVideoAnalysis: deepAnalysis\n  }\n}];"
      },
      "id": "deep-video-analysis",
      "name": "Deep Video Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5450, 400],
      "notes": "Análisis profundo de videos con métricas avanzadas",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Recomendaciones basadas en ML\nconst summary = $json;\nconst enableML = summary.enableMLRecommendations !== false;\n\nif (!enableML || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\nconst mlRecommendations = {\n  timestamp: new Date().toISOString(),\n  modelVersion: '1.0',\n  predictions: [],\n  recommendations: []\n};\n\n// Modelo simple de ML basado en patrones históricos\nsummary.outputs.forEach(video => {\n  const features = extractFeatures(video);\n  const prediction = predictSuccess(features);\n  \n  mlRecommendations.predictions.push({\n    videoId: video.video_id,\n    title: video.title,\n    features: features,\n    predictedEngagement: prediction.engagement,\n    predictedViews: prediction.views,\n    confidence: prediction.confidence,\n    recommendations: generateMLRecommendations(features, prediction)\n  });\n});\n\n// Recomendaciones agregadas\nconst avgPredictedEngagement = mlRecommendations.predictions.reduce((sum, p) => sum + p.predictedEngagement, 0) / mlRecommendations.predictions.length;\nconst topPredictions = mlRecommendations.predictions\n  .sort((a, b) => b.predictedEngagement - a.predictedEngagement)\n  .slice(0, 3);\n\nmlRecommendations.recommendations = [\n  {\n    type: 'content_strategy',\n    priority: 'high',\n    message: `Videos con mayor potencial: ${topPredictions.map(p => p.title).join(', ')}`,\n    action: 'Priorizar estos videos para publicación'\n  },\n  {\n    type: 'optimization',\n    priority: 'medium',\n    message: `Engagement promedio predicho: ${avgPredictedEngagement.toFixed(2)}`,\n    action: avgPredictedEngagement < 50 ? 'Mejorar calidad de contenido' : 'Mantener estándares actuales'\n  }\n];\n\nfunction extractFeatures(video) {\n  return {\n    titleLength: (video.title || '').length,\n    hasNumbers: /\\d/.test(video.title || ''),\n    hasEmojis: /[\\u{1F300}-\\u{1F9FF}]/u.test(video.title || ''),\n    likeCount: video.like_count || 0,\n    viewCount: video.view_count || 0,\n    contentType: video.contentType || 'general',\n    keywordDensity: calculateKeywordDensity(video.title || '')\n  };\n}\n\nfunction calculateKeywordDensity(title) {\n  const keywords = ['ai', 'tutorial', 'review', 'tips', 'guide'];\n  const words = title.toLowerCase().split(/\\s+/);\n  const matches = words.filter(w => keywords.some(kw => w.includes(kw))).length;\n  return words.length > 0 ? matches / words.length : 0;\n}\n\nfunction predictSuccess(features) {\n  let engagementScore = 50;\n  let viewsScore = 10000;\n  \n  // Título optimizado (50-60 caracteres)\n  if (features.titleLength >= 50 && features.titleLength <= 60) engagementScore += 15;\n  \n  // Números en título aumentan engagement\n  if (features.hasNumbers) engagementScore += 10;\n  \n  // Keywords relevantes\n  if (features.keywordDensity > 0.1) engagementScore += 15;\n  \n  // Tipo de contenido\n  if (features.contentType === 'tutorial') engagementScore += 10;\n  \n  // Basado en datos históricos\n  if (features.likeCount > 0) {\n    viewsScore = features.likeCount * 20; // Ratio estimado\n    engagementScore = Math.min(features.likeCount / 100, 100);\n  }\n  \n  const confidence = features.likeCount > 0 ? 'high' : 'medium';\n  \n  return {\n    engagement: Math.min(engagementScore, 100),\n    views: Math.round(viewsScore),\n    confidence: confidence\n  };\n}\n\nfunction generateMLRecommendations(features, prediction) {\n  const recommendations = [];\n  \n  if (prediction.engagement < 50) {\n    recommendations.push('Optimizar título para mejor engagement');\n  }\n  \n  if (features.titleLength < 40) {\n    recommendations.push('Aumentar longitud del título a 50-60 caracteres');\n  }\n  \n  if (!features.hasNumbers && prediction.engagement < 60) {\n    recommendations.push('Considerar agregar números al título');\n  }\n  \n  return recommendations;\n}\n\nreturn [{\n  json: {\n    ...summary,\n    mlRecommendations: mlRecommendations\n  }\n}];"
      },
      "id": "ml-recommendations",
      "name": "ML Recommendations",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5650, 400],
      "notes": "Recomendaciones basadas en Machine Learning",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Análisis de audiencia\nconst summary = $json;\nconst enableAudience = summary.enableAudienceAnalysis !== false;\n\nif (!enableAudience || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\nconst audienceAnalysis = {\n  timestamp: new Date().toISOString(),\n  demographics: {},\n  preferences: {},\n  engagementPatterns: {},\n  recommendations: []\n};\n\n// Analizar preferencias de audiencia basadas en contenido exitoso\nconst topVideos = summary.outputs\n  .sort((a, b) => ((b.like_count || 0) + (b.view_count || 0) / 10) - ((a.like_count || 0) + (a.view_count || 0) / 10))\n  .slice(0, 5);\n\n// Demografía inferida\naudienceAnalysis.demographics = {\n  ageGroup: inferAgeGroup(topVideos),\n  interests: inferInterests(topVideos),\n  techLevel: inferTechLevel(topVideos),\n  language: inferLanguage(summary.outputs)\n};\n\n// Preferencias de contenido\naudienceAnalysis.preferences = {\n  preferredContentTypes: getPreferredContentTypes(summary.outputs),\n  preferredLength: inferPreferredLength(summary.outputs),\n  preferredTopics: getPreferredTopics(summary.outputs),\n  engagementPeak: inferEngagementPeak(summary.outputs)\n};\n\n// Patrones de engagement\naudienceAnalysis.engagementPatterns = {\n  avgEngagementRate: calculateAvgEngagementRate(summary.outputs),\n  peakEngagementTime: inferPeakTime(summary.outputs),\n  contentConsumptionPattern: inferConsumptionPattern(summary.outputs)\n};\n\n// Recomendaciones\naudienceAnalysis.recommendations = generateAudienceRecommendations(audienceAnalysis);\n\nfunction inferAgeGroup(videos) {\n  const titles = videos.map(v => (v.title || '').toLowerCase()).join(' ');\n  if (titles.includes('beginner') || titles.includes('basic')) return '18-25';\n  if (titles.includes('advanced') || titles.includes('expert')) return '25-35';\n  return '18-35';\n}\n\nfunction inferInterests(videos) {\n  const interests = [];\n  const titles = videos.map(v => (v.title || '').toLowerCase()).join(' ');\n  \n  if (titles.includes('ai') || titles.includes('artificial')) interests.push('AI/ML');\n  if (titles.includes('automation')) interests.push('Automation');\n  if (titles.includes('tutorial') || titles.includes('learn')) interests.push('Education');\n  if (titles.includes('review') || titles.includes('comparison')) interests.push('Product Reviews');\n  \n  return interests.length > 0 ? interests : ['Technology', 'Education'];\n}\n\nfunction inferTechLevel(videos) {\n  const titles = videos.map(v => (v.title || '').toLowerCase()).join(' ');\n  if (titles.includes('beginner') || titles.includes('introduction')) return 'beginner';\n  if (titles.includes('advanced') || titles.includes('expert')) return 'advanced';\n  return 'intermediate';\n}\n\nfunction inferLanguage(videos) {\n  const languages = summary.languages || ['en'];\n  return languages[0] || 'en';\n}\n\nfunction getPreferredContentTypes(videos) {\n  const typeCounts = {};\n  videos.forEach(v => {\n    const type = v.contentType || 'general';\n    typeCounts[type] = (typeCounts[type] || 0) + 1;\n  });\n  \n  return Object.entries(typeCounts)\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 3)\n    .map(([type]) => type);\n}\n\nfunction inferPreferredLength(videos) {\n  // Basado en engagement - videos más cortos suelen tener mejor engagement\n  const avgLikes = videos.reduce((sum, v) => sum + (v.like_count || 0), 0) / videos.length;\n  if (avgLikes > 5000) return 'short (30-60s)';\n  if (avgLikes > 2000) return 'medium (2-5min)';\n  return 'long (5-10min)';\n}\n\nfunction getPreferredTopics(videos) {\n  const topics = {};\n  videos.forEach(v => {\n    const title = (v.title || '').toLowerCase();\n    const words = title.split(/\\s+/).filter(w => w.length > 4);\n    words.forEach(word => {\n      topics[word] = (topics[word] || 0) + 1;\n    });\n  });\n  \n  return Object.entries(topics)\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 5)\n    .map(([topic]) => topic);\n}\n\nfunction inferEngagementPeak(videos) {\n  // Horarios óptimos basados en engagement\n  return ['18:00-20:00', '12:00-14:00'];\n}\n\nfunction calculateAvgEngagementRate(videos) {\n  const totalLikes = videos.reduce((sum, v) => sum + (v.like_count || 0), 0);\n  const totalViews = videos.reduce((sum, v) => sum + (v.view_count || 0), 0);\n  \n  return totalViews > 0 ? ((totalLikes / totalViews) * 100).toFixed(2) : '0.00';\n}\n\nfunction inferPeakTime(videos) {\n  return '18:00-20:00 UTC';\n}\n\nfunction inferConsumptionPattern(videos) {\n  const avgLikes = videos.reduce((sum, v) => sum + (v.like_count || 0), 0) / videos.length;\n  if (avgLikes > 5000) return 'high_consumption';\n  if (avgLikes > 2000) return 'moderate_consumption';\n  return 'low_consumption';\n}\n\nfunction generateAudienceRecommendations(analysis) {\n  const recommendations = [];\n  \n  recommendations.push({\n    type: 'content_strategy',\n    message: `Crear más contenido tipo: ${analysis.preferences.preferredContentTypes.join(', ')}`,\n    action: 'Enfocarse en tipos de contenido preferidos por la audiencia'\n  });\n  \n  recommendations.push({\n    type: 'publishing',\n    message: `Publicar en horarios pico: ${analysis.preferences.engagementPeak.join(', ')}`,\n    action: 'Optimizar horarios de publicación'\n  });\n  \n  return recommendations;\n}\n\nreturn [{\n  json: {\n    ...summary,\n    audienceAnalysis: audienceAnalysis\n  }\n}];"
      },
      "id": "audience-analysis",
      "name": "Audience Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5850, 400],
      "notes": "Análisis de audiencia y demografía",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Versionado de contenido\nconst summary = $json;\nconst enableVersioning = summary.enableContentVersioning !== false;\n\nif (!enableVersioning || !summary.optimizedContent || summary.optimizedContent.length === 0) {\n  return [$input.item];\n}\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst outputDir = summary.outputDir || './ai_video_outputs';\nconst versionDir = path.join(outputDir, 'versions');\n\nfs.mkdirSync(versionDir, { recursive: true });\n\nconst versioning = {\n  timestamp: new Date().toISOString(),\n  executionId: summary.executionId,\n  versions: []\n};\n\nsummary.optimizedContent.forEach((content, idx) => {\n  const version = {\n    contentId: content.videoId,\n    version: '1.0.0',\n    timestamp: new Date().toISOString(),\n    changes: ['Initial version'],\n    platforms: Object.keys(content.platforms || {}),\n    variants: summary.multiVariants?.find(mv => mv.videoId === content.videoId)?.variants.length || 0,\n    file: path.join(versionDir, `${content.videoId}_v1.0.0.json`)\n  };\n  \n  // Guardar versión\n  fs.writeFileSync(version.file, JSON.stringify({\n    ...content,\n    version: version.version,\n    timestamp: version.timestamp\n  }, null, 2), 'utf-8');\n  \n  versioning.versions.push(version);\n});\n\n// Historial de versiones\nversioning.history = {\n  totalVersions: versioning.versions.length,\n  lastUpdate: new Date().toISOString(),\n  versionDirectory: versionDir\n};\n\nreturn [{\n  json: {\n    ...summary,\n    contentVersioning: versioning\n  }\n}];"
      },
      "id": "content-versioning",
      "name": "Content Versioning",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [6050, 400],
      "notes": "Sistema de versionado de contenido",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Optimización avanzada de costos\nconst summary = $json;\nconst enableCostOpt = summary.enableAdvancedCostOptimization !== false;\n\nif (!enableCostOpt) {\n  return [$input.item];\n}\n\nconst costOptimization = {\n  timestamp: new Date().toISOString(),\n  currentCosts: summary.cost || { total: 0, dailyTotal: 0 },\n  optimizations: [],\n  savings: {},\n  recommendations: []\n};\n\n// Analizar costos por operación\nconst costBreakdown = {\n  transcription: summary.outputs?.length * 0.006 || 0, // $0.006 por minuto\n  translation: summary.outputs?.length * 0.0001 || 0, // $0.0001 por 1K tokens\n  pdfGeneration: summary.pdfs_generated * 0.001 || 0,\n  apiCalls: (summary.outputs?.length || 0) * 0.0001\n};\n\ncostOptimization.costBreakdown = costBreakdown;\nconst totalEstimated = Object.values(costBreakdown).reduce((a, b) => a + b, 0);\n\n// Optimizaciones sugeridas\nif (costBreakdown.transcription > 0.1) {\n  costOptimization.optimizations.push({\n    area: 'transcription',\n    currentCost: costBreakdown.transcription,\n    optimization: 'Usar cache para videos ya transcritos',\n    potentialSavings: costBreakdown.transcription * 0.3,\n    priority: 'high'\n  });\n}\n\nif (summary.outputs && summary.outputs.length > 10) {\n  costOptimization.optimizations.push({\n    area: 'batch_processing',\n    currentCost: totalEstimated,\n    optimization: 'Procesar en lotes más grandes',\n    potentialSavings: totalEstimated * 0.15,\n    priority: 'medium'\n  });\n}\n\n// Calcular ahorros potenciales\ncostOptimization.savings = {\n  totalPotential: costOptimization.optimizations.reduce((sum, opt) => sum + opt.potentialSavings, 0),\n  percentage: totalEstimated > 0 ? ((costOptimization.optimizations.reduce((sum, opt) => sum + opt.potentialSavings, 0) / totalEstimated) * 100).toFixed(2) : '0.00'\n};\n\n// Recomendaciones\ncostOptimization.recommendations = [\n  {\n    type: 'immediate',\n    message: `Ahorro potencial: $${costOptimization.savings.totalPotential.toFixed(4)} (${costOptimization.savings.percentage}%)`,\n    action: 'Implementar optimizaciones sugeridas'\n  },\n  {\n    type: 'long_term',\n    message: 'Considerar usar modelos más económicos para contenido de baja prioridad',\n    action: 'Implementar sistema de priorización de costos'\n  }\n];\n\nreturn [{\n  json: {\n    ...summary,\n    advancedCostOptimization: costOptimization\n  }\n}];"
      },
      "id": "advanced-cost-optimization",
      "name": "Advanced Cost Optimization",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [6250, 400],
      "notes": "Optimización avanzada de costos",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Sistema de alertas inteligentes\nconst summary = $json;\nconst enableAlerts = summary.enableIntelligentAlerts !== false;\n\nif (!enableAlerts) {\n  return [$input.item];\n}\n\nconst intelligentAlerts = {\n  timestamp: new Date().toISOString(),\n  alerts: [],\n  critical: [],\n  warnings: [],\n  info: []\n};\n\n// Alertas críticas\nif (summary.errors && summary.errors.length > summary.outputs.length * 0.3) {\n  intelligentAlerts.critical.push({\n    type: 'error_rate',\n    severity: 'critical',\n    message: `Tasa de error alta: ${summary.errors.length} errores de ${summary.outputs.length} videos`,\n    action: 'Revisar configuración y APIs inmediatamente',\n    threshold: '30%'\n  });\n}\n\nif (summary.cost && parseFloat(summary.cost.dailyTotal) > 10) {\n  intelligentAlerts.critical.push({\n    type: 'cost_threshold',\n    severity: 'critical',\n    message: `Costo diario excedido: $${summary.cost.dailyTotal}`,\n    action: 'Revisar y optimizar uso de APIs',\n    threshold: '$10'\n  });\n}\n\n// Alertas de advertencia\nif (summary.metrics && parseFloat(summary.metrics.successRate) < 70) {\n  intelligentAlerts.warnings.push({\n    type: 'success_rate',\n    severity: 'warning',\n    message: `Tasa de éxito baja: ${summary.metrics.successRate}`,\n    action: 'Revisar calidad de videos y configuración',\n    threshold: '70%'\n  });\n}\n\nif (summary.seoAnalysis && parseFloat(summary.seoAnalysis.avgSEOScore) < 50) {\n  intelligentAlerts.warnings.push({\n    type: 'seo_score',\n    severity: 'warning',\n    message: `Score SEO bajo: ${summary.seoAnalysis.avgSEOScore}`,\n    action: 'Optimizar títulos y descripciones',\n    threshold: '50'\n  });\n}\n\nif (summary.engagementAnalysis && parseFloat(summary.engagementAnalysis.avgEngagementRate) < 1000) {\n  intelligentAlerts.warnings.push({\n    type: 'engagement',\n    severity: 'warning',\n    message: `Engagement promedio bajo: ${summary.engagementAnalysis.avgEngagementRate}`,\n    action: 'Mejorar calidad de contenido',\n    threshold: '1000'\n  });\n}\n\n// Alertas informativas\nif (summary.outputs && summary.outputs.length > 0) {\n  intelligentAlerts.info.push({\n    type: 'success',\n    severity: 'info',\n    message: `Pipeline completado exitosamente: ${summary.outputs.length} videos procesados`,\n    action: 'Revisar resultados y métricas'\n  });\n}\n\nif (summary.scheduledPosts && summary.scheduledPosts.length > 0) {\n  intelligentAlerts.info.push({\n    type: 'scheduling',\n    severity: 'info',\n    message: `${summary.scheduledPosts.length} posts programados para publicación`,\n    action: 'Monitorear publicación automática'\n  });\n}\n\n// Consolidar todas las alertas\nintelligentAlerts.alerts = [\n  ...intelligentAlerts.critical,\n  ...intelligentAlerts.warnings,\n  ...intelligentAlerts.info\n];\n\nintelligentAlerts.summary = {\n  total: intelligentAlerts.alerts.length,\n  critical: intelligentAlerts.critical.length,\n  warnings: intelligentAlerts.warnings.length,\n  info: intelligentAlerts.info.length\n};\n\nreturn [{\n  json: {\n    ...summary,\n    intelligentAlerts: intelligentAlerts\n  }\n}];"
      },
      "id": "intelligent-alerts",
      "name": "Intelligent Alerts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [6450, 400],
      "notes": "Sistema de alertas inteligentes",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Análisis de ROI (Return on Investment)\nconst summary = $json;\nconst enableROI = summary.enableROIAnalysis !== false;\n\nif (!enableROI) {\n  return [$input.item];\n}\n\nconst roiAnalysis = {\n  timestamp: new Date().toISOString(),\n  investment: {},\n  returns: {},\n  roi: {},\n  recommendations: []\n};\n\n// Calcular inversión total\nconst totalCost = summary.cost?.total || summary.advancedCostOptimization?.costBreakdown ? \n  Object.values(summary.advancedCostOptimization.costBreakdown).reduce((a, b) => a + b, 0) : 0;\n\nroiAnalysis.investment = {\n  totalCost: totalCost,\n  timeInvested: summary.metrics?.durationFormatted || '0s',\n  resourcesUsed: {\n    videosProcessed: summary.outputs?.length || 0,\n    pdfsGenerated: summary.pdfs_generated || 0,\n    apiCalls: (summary.outputs?.length || 0) * 3\n  }\n};\n\n// Calcular retornos estimados\nconst totalViews = summary.outputs?.reduce((sum, v) => sum + (v.view_count || 0), 0) || 0;\nconst totalLikes = summary.outputs?.reduce((sum, v) => sum + (v.like_count || 0), 0) || 0;\nconst totalEngagement = totalLikes + (totalViews / 10);\n\n// Valor estimado por engagement (ejemplo: $0.01 por like)\nconst estimatedValue = totalEngagement * 0.01;\n\nroiAnalysis.returns = {\n  totalViews: totalViews,\n  totalLikes: totalLikes,\n  totalEngagement: totalEngagement,\n  estimatedValue: estimatedValue,\n  contentAssets: {\n    pdfs: summary.pdfs_generated || 0,\n    optimizedContent: summary.optimizedContent?.length || 0,\n    scheduledPosts: summary.scheduledPosts?.length || 0\n  }\n};\n\n// Calcular ROI\nif (totalCost > 0) {\n  const roiValue = ((estimatedValue - totalCost) / totalCost) * 100;\n  roiAnalysis.roi = {\n    percentage: roiValue.toFixed(2),\n    netValue: (estimatedValue - totalCost).toFixed(4),\n    breakEvenPoint: totalCost > estimatedValue ? 'No alcanzado' : 'Alcanzado',\n    efficiency: totalCost > 0 ? (totalEngagement / totalCost).toFixed(2) : '0'\n  };\n} else {\n  roiAnalysis.roi = {\n    percentage: 'N/A',\n    netValue: estimatedValue.toFixed(4),\n    breakEvenPoint: 'N/A',\n    efficiency: 'N/A'\n  };\n}\n\n// Recomendaciones\nif (parseFloat(roiAnalysis.roi.percentage) < 0) {\n  roiAnalysis.recommendations.push({\n    priority: 'high',\n    message: 'ROI negativo detectado',\n    action: 'Optimizar costos y mejorar calidad de contenido'\n  });\n} else if (parseFloat(roiAnalysis.roi.percentage) > 100) {\n  roiAnalysis.recommendations.push({\n    priority: 'low',\n    message: 'ROI excelente',\n    action: 'Considerar aumentar inversión para escalar'\n  });\n}\n\nreturn [{\n  json: {\n    ...summary,\n    roiAnalysis: roiAnalysis\n  }\n}];"
      },
      "id": "roi-analysis",
      "name": "ROI Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [6650, 400],
      "notes": "Análisis de ROI y retorno de inversión",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Integración con herramientas de diseño\nconst summary = $json;\nconst enableDesign = summary.enableDesignIntegration !== false;\n\nif (!enableDesign || !summary.thumbnailSpecs || summary.thumbnailSpecs.length === 0) {\n  return [$input.item];\n}\n\nconst designIntegration = {\n  timestamp: new Date().toISOString(),\n  designSpecs: [],\n  templates: [],\n  exportFormats: []\n};\n\n// Generar especificaciones para herramientas de diseño\nsummary.thumbnailSpecs.forEach(spec => {\n  const designSpec = {\n    videoId: spec.videoId,\n    title: spec.title,\n    platforms: Object.keys(spec.thumbnails || {}),\n    canvaTemplate: {\n      dimensions: spec.thumbnails.youtube?.dimensions || { width: 1280, height: 720 },\n      textElements: [\n        { text: spec.thumbnails.youtube?.recommendedText || spec.title, type: 'heading', size: 48 },\n        { text: 'Click para ver más', type: 'subheading', size: 24 }\n      ],\n      colorScheme: spec.thumbnails.youtube?.colorScheme || 'vibrant',\n      templateUrl: `canva://template/${spec.videoId}`\n    },\n    figmaSpecs: {\n      frameSize: spec.thumbnails.youtube?.dimensions || { width: 1280, height: 720 },\n      layers: [\n        { name: 'Background', type: 'rectangle', color: '#1a1a1a' },\n        { name: 'Title Text', type: 'text', content: spec.title, fontSize: 48 }\n      ],\n      exportSettings: ['PNG', 'JPG', 'SVG']\n    },\n    adobeExpress: {\n      templateId: `template_${spec.videoId}`,\n      customizations: {\n        text: spec.title,\n        colors: ['#FF6B6B', '#4ECDC4', '#45B7D1'],\n        fonts: ['Montserrat', 'Roboto']\n      }\n    }\n  };\n  \n  designIntegration.designSpecs.push(designSpec);\n});\n\n// Plantillas predefinidas\ndesignIntegration.templates = [\n  {\n    name: 'Tutorial Style',\n    description: 'Plantilla optimizada para contenido educativo',\n    colors: ['#2C3E50', '#3498DB', '#E74C3C'],\n    fonts: ['Roboto', 'Open Sans']\n  },\n  {\n    name: 'Viral Style',\n    description: 'Plantilla optimizada para contenido viral',\n    colors: ['#FF6B6B', '#FFE66D', '#4ECDC4'],\n    fonts: ['Montserrat', 'Poppins']\n  },\n  {\n    name: 'Professional Style',\n    description: 'Plantilla para contenido profesional',\n    colors: ['#1a1a1a', '#ffffff', '#007bff'],\n    fonts: ['Inter', 'Helvetica']\n  }\n];\n\n// Formatos de exportación\ndesignIntegration.exportFormats = [\n  { format: 'PNG', resolution: 'high', useCase: 'Social Media' },\n  { format: 'JPG', resolution: 'medium', useCase: 'Web' },\n  { format: 'SVG', resolution: 'vector', useCase: 'Scalable Graphics' },\n  { format: 'PDF', resolution: 'print', useCase: 'Print Materials' }\n];\n\nreturn [{\n  json: {\n    ...summary,\n    designIntegration: designIntegration\n  }\n}];"
      },
      "id": "design-integration",
      "name": "Design Integration",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [6850, 400],
      "notes": "Integración con herramientas de diseño (Canva, Figma, Adobe Express)",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Reportes ejecutivos\nconst summary = $json;\nconst enableReports = summary.enableExecutiveReports !== false;\n\nif (!enableReports) {\n  return [$input.item];\n}\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst outputDir = summary.outputDir || './ai_video_outputs';\nconst reportsDir = path.join(outputDir, 'executive_reports');\n\nfs.mkdirSync(reportsDir, { recursive: true });\n\nconst executiveReport = {\n  timestamp: new Date().toISOString(),\n  period: `${summary.daysBack || 7} days`, \n  executiveSummary: {\n    totalVideosProcessed: summary.outputs?.length || 0,\n    totalPDFsGenerated: summary.pdfs_generated || 0,\n    successRate: summary.metrics?.successRate || '0%',\n    totalCost: summary.cost?.total || '0',\n    roi: summary.roiAnalysis?.roi.percentage || 'N/A'\n  },\n  keyMetrics: {\n    performance: {\n      avgProcessingTime: summary.metrics?.avgProcessingTime || '0s',\n      videosPerMinute: summary.metrics?.videosPerMinute || 0,\n      errorRate: summary.metrics?.errorRate || '0%'\n    },\n    engagement: {\n      totalViews: summary.outputs?.reduce((sum, v) => sum + (v.view_count || 0), 0) || 0,\n      totalLikes: summary.outputs?.reduce((sum, v) => sum + (v.like_count || 0), 0) || 0,\n      avgEngagementRate: summary.engagementAnalysis?.avgEngagementRate || '0'\n    },\n    content: {\n      optimizedContent: summary.optimizedContent?.length || 0,\n      scheduledPosts: summary.scheduledPosts?.length || 0,\n      seoScore: summary.seoAnalysis?.avgSEOScore || 'N/A'\n    }\n  },\n  strategicInsights: {\n    topPerformingContent: summary.engagementAnalysis?.topPerformers || [],\n    trendingTopics: summary.realTimeTrendAnalysis?.trendingTopics.slice(0, 5) || [],\n    audienceInsights: summary.audienceAnalysis?.demographics || {},\n    recommendations: summary.advancedRecommendations?.priorityActions || []\n  },\n  financialOverview: {\n    costs: summary.advancedCostOptimization?.costBreakdown || {},\n    savings: summary.advancedCostOptimization?.savings || {},\n    roi: summary.roiAnalysis?.roi || {}\n  },\n  nextSteps: summary.feedbackLoop?.nextIteration || {}\n};\n\n// Guardar reporte JSON\nconst reportFile = path.join(reportsDir, `executive_report_${summary.executionId}.json`);\nfs.writeFileSync(reportFile, JSON.stringify(executiveReport, null, 2), 'utf-8');\n\n// Generar reporte ejecutivo en texto\nconst textReport = `REPORTE EJECUTIVO - AI VIDEO PIPELINE\n==========================================\n\nPERÍODO: ${executiveReport.period}\nFECHA: ${executiveReport.timestamp}\n\nRESUMEN EJECUTIVO\n------------------\n• Videos procesados: ${executiveReport.executiveSummary.totalVideosProcessed}\n• PDFs generados: ${executiveReport.executiveSummary.totalPDFsGenerated}\n• Tasa de éxito: ${executiveReport.executiveSummary.successRate}\n• Costo total: $${executiveReport.executiveSummary.totalCost}\n• ROI: ${executiveReport.executiveSummary.roi}%\n\nMÉTRICAS CLAVE\n---------------\nRendimiento:\n  • Tiempo promedio/video: ${executiveReport.keyMetrics.performance.avgProcessingTime}\n  • Videos/minuto: ${executiveReport.keyMetrics.performance.videosPerMinute}\n  • Tasa de error: ${executiveReport.keyMetrics.performance.errorRate}\n\nEngagement:\n  • Total views: ${executiveReport.keyMetrics.engagement.totalViews.toLocaleString()}\n  • Total likes: ${executiveReport.keyMetrics.engagement.totalLikes.toLocaleString()}\n  • Engagement promedio: ${executiveReport.keyMetrics.engagement.avgEngagementRate}\n\nContenido:\n  • Contenido optimizado: ${executiveReport.keyMetrics.content.optimizedContent}\n  • Posts programados: ${executiveReport.keyMetrics.content.scheduledPosts}\n  • Score SEO: ${executiveReport.keyMetrics.content.seoScore}\n\nINSIGHTS ESTRATÉGICOS\n---------------------\nTop Contenido:\n${executiveReport.strategicInsights.topPerformingContent.slice(0, 3).map((t, i) => `  ${i + 1}. ${t.title || t.videoId}`).join('\\n')}\n\nTendencias:\n${executiveReport.strategicInsights.trendingTopics.map(t => `  • ${t.keyword}`).join('\\n')}\n\nRECOMENDACIONES PRIORITARIAS\n------------------------------\n${executiveReport.strategicInsights.recommendations.slice(0, 3).map((r, i) => `  ${i + 1}. ${r}`).join('\\n')}\n\nOVERVIEW FINANCIERO\n-------------------\nCostos:\n  • Transcripción: $${executiveReport.financialOverview.costs.transcription?.toFixed(4) || '0'}\n  • Traducción: $${executiveReport.financialOverview.costs.translation?.toFixed(4) || '0'}\n  • Generación PDF: $${executiveReport.financialOverview.costs.pdfGeneration?.toFixed(4) || '0'}\n\nAhorros Potenciales: $${executiveReport.financialOverview.savings.totalPotential?.toFixed(4) || '0'} (${executiveReport.financialOverview.savings.percentage || '0'}%)\n\nPRÓXIMOS PASOS\n---------------\n${executiveReport.nextSteps.focusAreas ? executiveReport.nextSteps.focusAreas.map(a => `  • ${a}`).join('\\n') : '  • Continuar monitoreo y optimización'}\n`;\n\nconst textReportFile = path.join(reportsDir, `executive_report_${summary.executionId}.txt`);\nfs.writeFileSync(textReportFile, textReport, 'utf-8');\n\nreturn [{\n  json: {\n    ...summary,\n    executiveReport: {\n      created: true,\n      jsonFile: reportFile,\n      textFile: textReportFile,\n      data: executiveReport\n    }\n  }\n}];"
      },
      "id": "executive-reports",
      "name": "Executive Reports",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [7050, 400],
      "notes": "Genera reportes ejecutivos completos",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Sistema de colaboración\nconst summary = $json;\nconst enableCollab = summary.enableCollaboration !== false;\n\nif (!enableCollab) {\n  return [$input.item];\n}\n\nconst collaboration = {\n  timestamp: new Date().toISOString(),\n  sharedResources: [],\n  teamAccess: {},\n  comments: [],\n  approvals: []\n};\n\n// Recursos compartidos\nif (summary.optimizedContent && summary.optimizedContent.length > 0) {\n  summary.optimizedContent.forEach(content => {\n    collaboration.sharedResources.push({\n      resourceId: content.videoId,\n      type: 'content',\n      title: content.title,\n      platforms: Object.keys(content.platforms || {}),\n      shareUrl: `https://collab.example.com/content/${content.videoId}`,\n      permissions: ['view', 'edit', 'comment'],\n      sharedWith: ['team@example.com']\n    });\n  });\n}\n\nif (summary.contentExports && summary.contentExports.length > 0) {\n  summary.contentExports.forEach(export => {\n    collaboration.sharedResources.push({\n      resourceId: export.videoId,\n      type: 'export',\n      platform: export.platform,\n      file: export.file,\n      shareUrl: `https://collab.example.com/exports/${export.videoId}`,\n      permissions: ['view', 'download'],\n      sharedWith: ['team@example.com']\n    });\n  });\n}\n\n// Acceso del equipo\ncollaboration.teamAccess = {\n  roles: ['admin', 'editor', 'viewer'],\n  members: [\n    { email: 'admin@example.com', role: 'admin', permissions: ['all'] },\n    { email: 'editor@example.com', role: 'editor', permissions: ['view', 'edit', 'comment'] },\n    { email: 'viewer@example.com', role: 'viewer', permissions: ['view'] }\n  ],\n  sharedFolders: [\n    { name: 'Content Library', path: summary.outputDir, access: 'team' },\n    { name: 'Exports', path: summary.exportDirectory, access: 'team' }\n  ]\n};\n\n// Comentarios y aprobaciones\nif (summary.scheduledPosts && summary.scheduledPosts.length > 0) {\n  summary.scheduledPosts.forEach(post => {\n    collaboration.approvals.push({\n      resourceId: post.postId,\n      type: 'scheduled_post',\n      status: 'pending',\n      requiresApproval: true,\n      approvers: ['admin@example.com'],\n      deadline: post.scheduledTime\n    });\n  });\n}\n\ncollaboration.summary = {\n  totalResources: collaboration.sharedResources.length,\n  pendingApprovals: collaboration.approvals.filter(a => a.status === 'pending').length,\n  teamMembers: collaboration.teamAccess.members.length\n};\n\nreturn [{\n  json: {\n    ...summary,\n    collaboration: collaboration\n  }\n}];"
      },
      "id": "collaboration",
      "name": "Collaboration",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [7250, 400],
      "notes": "Sistema de colaboración y trabajo en equipo",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Exportación avanzada a múltiples formatos\nconst summary = $json;\nconst enableExport = summary.enableAdvancedExport !== false;\n\nif (!enableExport || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst outputDir = summary.outputDir || './ai_video_outputs';\nconst exportDir = path.join(outputDir, 'advanced_exports');\n\nfs.mkdirSync(exportDir, { recursive: true });\n\nconst advancedExports = {\n  timestamp: new Date().toISOString(),\n  exports: []\n};\n\nsummary.outputs.forEach((video, idx) => {\n  const videoId = video.video_id || `video_${idx}`;\n  \n  // Exportar a CSV\n  const csvData = `Video ID,Title,Likes,Views,URL\\n${videoId},\"${video.title || ''}\",${video.like_count || 0},${video.view_count || 0},\"${video.url || ''}\"\\n`;\n  const csvFile = path.join(exportDir, `${videoId}.csv`);\n  fs.writeFileSync(csvFile, csvData, 'utf-8');\n  advancedExports.exports.push({ format: 'CSV', file: csvFile, videoId });\n  \n  // Exportar a XML\n  const xmlData = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<video>\\n  <id>${videoId}</id>\\n  <title>${video.title || ''}</title>\\n  <likes>${video.like_count || 0}</likes>\\n  <views>${video.view_count || 0}</views>\\n  <url>${video.url || ''}</url>\\n</video>\\n`;\n  const xmlFile = path.join(exportDir, `${videoId}.xml`);\n  fs.writeFileSync(xmlFile, xmlData, 'utf-8');\n  advancedExports.exports.push({ format: 'XML', file: xmlFile, videoId });\n  \n  // Exportar a Markdown\n  const mdData = `# ${video.title || 'Video'}\\n\\n**Video ID:** ${videoId}\\n\\n**Métricas:**\\n- Likes: ${video.like_count || 0}\\n- Views: ${video.view_count || 0}\\n\\n**URL:** ${video.url || 'N/A'}\\n`;\n  const mdFile = path.join(exportDir, `${videoId}.md`);\n  fs.writeFileSync(mdFile, mdData, 'utf-8');\n  advancedExports.exports.push({ format: 'Markdown', file: mdFile, videoId });\n});\n\n// Exportar resumen consolidado\nconst consolidatedData = {\n  executionId: summary.executionId,\n  timestamp: summary.startedAt,\n  summary: {\n    totalVideos: summary.outputs.length,\n    totalLikes: summary.outputs.reduce((sum, v) => sum + (v.like_count || 0), 0),\n    totalViews: summary.outputs.reduce((sum, v) => sum + (v.view_count || 0), 0)\n  },\n  videos: summary.outputs.map(v => ({\n    id: v.video_id,\n    title: v.title,\n    likes: v.like_count || 0,\n    views: v.view_count || 0\n  }))\n};\n\nconst consolidatedFile = path.join(exportDir, `consolidated_${summary.executionId}.json`);\nfs.writeFileSync(consolidatedFile, JSON.stringify(consolidatedData, null, 2), 'utf-8');\nadvancedExports.exports.push({ format: 'JSON Consolidated', file: consolidatedFile });\n\nadvancedExports.summary = {\n  totalExports: advancedExports.exports.length,\n  formats: ['CSV', 'XML', 'Markdown', 'JSON'],\n  exportDirectory: exportDir\n};\n\nreturn [{\n  json: {\n    ...summary,\n    advancedExports: advancedExports\n  }\n}];"
      },
      "id": "advanced-export",
      "name": "Advanced Export",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [7450, 400],
      "notes": "Exportación avanzada a múltiples formatos",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Métricas de negocio\nconst summary = $json;\nconst enableBusiness = summary.enableBusinessMetrics !== false;\n\nif (!enableBusiness) {\n  return [$input.item];\n}\n\nconst businessMetrics = {\n  timestamp: new Date().toISOString(),\n  kpis: {},\n  growth: {},\n  efficiency: {},\n  value: {}\n};\n\n// KPIs principales\nbusinessMetrics.kpis = {\n  contentProductionRate: summary.outputs?.length / (parseInt(summary.daysBack) || 7), // Videos por día\n  pdfGenerationRate: (summary.pdfs_generated || 0) / (summary.outputs?.length || 1),\n  successRate: parseFloat(summary.metrics?.successRate || '0') / 100,\n  costPerVideo: summary.cost?.total ? (summary.cost.total / (summary.outputs?.length || 1)).toFixed(4) : '0',\n  engagementPerDollar: summary.cost?.total && summary.cost.total > 0 ? \n    ((summary.outputs?.reduce((sum, v) => sum + (v.like_count || 0), 0) || 0) / summary.cost.total).toFixed(2) : '0'\n};\n\n// Crecimiento\nconst previousExecution = $workflow.staticData.lastExecution || {};\nconst currentViews = summary.outputs?.reduce((sum, v) => sum + (v.view_count || 0), 0) || 0;\nconst previousViews = previousExecution.totalViews || 0;\n\nbusinessMetrics.growth = {\n  viewsGrowth: previousViews > 0 ? (((currentViews - previousViews) / previousViews) * 100).toFixed(2) : 'N/A',\n  contentGrowth: previousExecution.totalVideos ? \n    (((summary.outputs?.length || 0) - previousExecution.totalVideos) / previousExecution.totalVideos * 100).toFixed(2) : 'N/A',\n  engagementGrowth: previousExecution.avgEngagement ? \n    (((parseFloat(summary.engagementAnalysis?.avgEngagementRate || 0)) - previousExecution.avgEngagement) / previousExecution.avgEngagement * 100).toFixed(2) : 'N/A'\n};\n\n// Eficiencia\nbusinessMetrics.efficiency = {\n  timeToValue: summary.metrics?.durationFormatted || '0s',\n  automationRate: ((summary.outputs?.length || 0) / Math.max(summary.videos_discovered || 1, 1) * 100).toFixed(2) + '%',\n  resourceUtilization: summary.enableParallelProcessing ? 'high' : 'medium',\n  errorRecoveryRate: summary.errors && summary.errors.length > 0 ? \n    ((summary.outputs?.length - summary.errors.length) / summary.outputs.length * 100).toFixed(2) + '%' : '100%'\n};\n\n// Valor generado\nbusinessMetrics.value = {\n  contentAssets: {\n    pdfs: summary.pdfs_generated || 0,\n    optimizedContent: summary.optimizedContent?.length || 0,\n    scheduledPosts: summary.scheduledPosts?.length || 0,\n    variants: summary.totalVariants || 0\n  },\n  estimatedValue: {\n    contentValue: (summary.optimizedContent?.length || 0) * 50, // $50 por contenido optimizado\n    pdfValue: (summary.pdfs_generated || 0) * 20, // $20 por PDF\n    totalEstimated: ((summary.optimizedContent?.length || 0) * 50) + ((summary.pdfs_generated || 0) * 20)\n  },\n  roi: summary.roiAnalysis?.roi || {}\n};\n\n// Guardar para próxima ejecución\n$workflow.staticData.lastExecution = {\n  totalViews: currentViews,\n  totalVideos: summary.outputs?.length || 0,\n  avgEngagement: parseFloat(summary.engagementAnalysis?.avgEngagementRate || 0),\n  timestamp: new Date().toISOString()\n};\n\nreturn [{\n  json: {\n    ...summary,\n    businessMetrics: businessMetrics\n  }\n}];"
      },
      "id": "business-metrics",
      "name": "Business Metrics",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [7650, 400],
      "notes": "Métricas de negocio y KPIs",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Análisis de video con IA avanzada\nconst summary = $json;\nconst enableAI = summary.enableAIVideoAnalysis !== false;\n\nif (!enableAI || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\nconst aiVideoAnalysis = {\n  timestamp: new Date().toISOString(),\n  model: 'GPT-4 Vision + Custom ML',\n  analysisResults: []\n};\n\nsummary.outputs.forEach(video => {\n  const analysis = {\n    videoId: video.video_id,\n    title: video.title,\n    aiInsights: {\n      sceneDetection: detectScenes(video.title || ''),\n      objectDetection: detectObjects(video.title || ''),\n      emotionAnalysis: analyzeEmotion(video.title || ''),\n      textExtraction: extractKeyText(video.title || ''),\n      visualElements: detectVisualElementsAI(video.title || ''),\n      audioAnalysis: analyzeAudio(video)\n    },\n    contentClassification: {\n      category: classifyContent(video.title || ''),\n      subcategory: getSubcategory(video.title || ''),\n      tags: generateAITags(video.title || ''),\n      confidence: 0.85\n    },\n    recommendations: generateAIRecommendations(video)\n  };\n  \n  aiVideoAnalysis.analysisResults.push(analysis);\n});\n\n// Estadísticas agregadas\naiVideoAnalysis.summary = {\n  totalAnalyzed: aiVideoAnalysis.analysisResults.length,\n  categories: getCategoryDistribution(aiVideoAnalysis.analysisResults),\n  avgConfidence: aiVideoAnalysis.analysisResults.reduce((sum, a) => sum + a.contentClassification.confidence, 0) / aiVideoAnalysis.analysisResults.length\n};\n\nfunction detectScenes(title) {\n  const lowerTitle = title.toLowerCase();\n  const scenes = [];\n  if (lowerTitle.includes('screen') || lowerTitle.includes('demo')) scenes.push('screen_recording');\n  if (lowerTitle.includes('face') || lowerTitle.includes('person')) scenes.push('talking_head');\n  if (lowerTitle.includes('animation')) scenes.push('animated');\n  return scenes.length > 0 ? scenes : ['mixed'];\n}\n\nfunction detectObjects(title) {\n  const objects = [];\n  const lowerTitle = title.toLowerCase();\n  if (lowerTitle.includes('laptop') || lowerTitle.includes('computer')) objects.push('computer');\n  if (lowerTitle.includes('phone') || lowerTitle.includes('mobile')) objects.push('mobile_device');\n  if (lowerTitle.includes('code') || lowerTitle.includes('programming')) objects.push('code');\n  return objects.length > 0 ? objects : ['general'];\n}\n\nfunction analyzeEmotion(title) {\n  const lowerTitle = title.toLowerCase();\n  const positiveWords = ['amazing', 'incredible', 'awesome', 'great', 'best'];\n  const negativeWords = ['bad', 'worst', 'terrible', 'awful'];\n  \n  const hasPositive = positiveWords.some(w => lowerTitle.includes(w));\n  const hasNegative = negativeWords.some(w => lowerTitle.includes(w));\n  \n  if (hasPositive) return 'positive';\n  if (hasNegative) return 'negative';\n  return 'neutral';\n}\n\nfunction extractKeyText(title) {\n  const words = title.split(/\\s+/).filter(w => w.length > 4);\n  return words.slice(0, 5).join(' ');\n}\n\nfunction detectVisualElementsAI(title) {\n  return {\n    hasText: title.length > 0,\n    hasNumbers: /\\d/.test(title),\n    hasEmojis: /[\\u{1F300}-\\u{1F9FF}]/u.test(title),\n    complexity: title.length > 50 ? 'high' : 'medium'\n  };\n}\n\nfunction analyzeAudio(video) {\n  return {\n    hasVoice: true,\n    language: 'auto-detected',\n    quality: video.like_count > 5000 ? 'high' : 'medium'\n  };\n}\n\nfunction classifyContent(title) {\n  const lowerTitle = title.toLowerCase();\n  if (lowerTitle.includes('tutorial') || lowerTitle.includes('how to')) return 'educational';\n  if (lowerTitle.includes('review')) return 'review';\n  if (lowerTitle.includes('tip') || lowerTitle.includes('hack')) return 'tips';\n  return 'general';\n}\n\nfunction getSubcategory(title) {\n  const lowerTitle = title.toLowerCase();\n  if (lowerTitle.includes('ai') || lowerTitle.includes('artificial')) return 'artificial_intelligence';\n  if (lowerTitle.includes('automation')) return 'automation';\n  if (lowerTitle.includes('coding') || lowerTitle.includes('programming')) return 'programming';\n  return 'general';\n}\n\nfunction generateAITags(title) {\n  const tags = [];\n  const lowerTitle = title.toLowerCase();\n  \n  if (lowerTitle.includes('ai')) tags.push('AI');\n  if (lowerTitle.includes('tutorial')) tags.push('Tutorial');\n  if (lowerTitle.includes('automation')) tags.push('Automation');\n  if (lowerTitle.includes('tech')) tags.push('Technology');\n  \n  return tags.length > 0 ? tags : ['General'];\n}\n\nfunction generateAIRecommendations(video) {\n  const recommendations = [];\n  const likes = video.like_count || 0;\n  \n  if (likes < 1000) {\n    recommendations.push('Mejorar hook inicial para aumentar retención');\n    recommendations.push('Optimizar título para mejor SEO');\n  }\n  \n  return recommendations;\n}\n\nfunction getCategoryDistribution(results) {\n  const categories = {};\n  results.forEach(r => {\n    const cat = r.contentClassification.category;\n    categories[cat] = (categories[cat] || 0) + 1;\n  });\n  return categories;\n}\n\nreturn [{\n  json: {\n    ...summary,\n    aiVideoAnalysis: aiVideoAnalysis\n  }\n}];"
      },
      "id": "ai-video-analysis",
      "name": "AI Video Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [7850, 400],
      "notes": "Análisis de video con IA avanzada (detección de escenas, objetos, emociones)",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Recomendaciones inteligentes de contenido\nconst summary = $json;\nconst enableSmart = summary.enableSmartContentRecommendations !== false;\n\nif (!enableSmart || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\nconst smartRecommendations = {\n  timestamp: new Date().toISOString(),\n  recommendations: [],\n  contentIdeas: [],\n  optimizationSuggestions: []\n};\n\n// Analizar patrones exitosos\nconst topPerformers = summary.outputs\n  .sort((a, b) => ((b.like_count || 0) + (b.view_count || 0) / 10) - ((a.like_count || 0) + (a.view_count || 0) / 10))\n  .slice(0, 5);\n\n// Generar ideas de contenido basadas en éxito\nconst successfulPatterns = extractSuccessfulPatterns(topPerformers);\nsmartRecommendations.contentIdeas = generateContentIdeas(successfulPatterns, summary.outputs.length);\n\n// Sugerencias de optimización\nsmartRecommendations.optimizationSuggestions = generateOptimizationSuggestions(summary);\n\n// Recomendaciones estratégicas\nsmartRecommendations.recommendations = [\n  {\n    type: 'content_strategy',\n    priority: 'high',\n    title: 'Enfocarse en contenido de alto rendimiento',\n    description: `Los videos tipo '${successfulPatterns.bestType}' tienen mejor rendimiento`,\n    action: `Crear más contenido tipo '${successfulPatterns.bestType}'`,\n    expectedImpact: '15-20% aumento en engagement'\n  },\n  {\n    type: 'publishing',\n    priority: 'medium',\n    title: 'Optimizar horarios de publicación',\n    description: 'Publicar en horarios pico identificados',\n    action: 'Ajustar calendario de publicaciones',\n    expectedImpact: '10-15% aumento en reach'\n  },\n  {\n    type: 'content_format',\n    priority: 'medium',\n    title: 'Mejorar formato de contenido',\n    description: 'Aplicar formatos exitosos a nuevo contenido',\n    action: 'Usar plantillas de contenido de alto rendimiento',\n    expectedImpact: '12-18% aumento en retención'\n  }\n];\n\nfunction extractSuccessfulPatterns(videos) {\n  const patterns = {\n    avgTitleLength: 0,\n    commonKeywords: {},\n    bestType: 'general',\n    avgLikes: 0\n  };\n  \n  videos.forEach(v => {\n    patterns.avgTitleLength += (v.title || '').length;\n    const words = (v.title || '').toLowerCase().split(/\\s+/).filter(w => w.length > 3);\n    words.forEach(word => {\n      patterns.commonKeywords[word] = (patterns.commonKeywords[word] || 0) + 1;\n    });\n    patterns.avgLikes += v.like_count || 0;\n  });\n  \n  patterns.avgTitleLength = Math.round(patterns.avgTitleLength / videos.length);\n  patterns.avgLikes = Math.round(patterns.avgLikes / videos.length);\n  \n  const typeCounts = {};\n  videos.forEach(v => {\n    const type = v.contentType || 'general';\n    typeCounts[type] = (typeCounts[type] || 0) + 1;\n  });\n  \n  patterns.bestType = Object.entries(typeCounts).sort((a, b) => b[1] - a[1])[0]?.[0] || 'general';\n  \n  return patterns;\n}\n\nfunction generateContentIdeas(patterns, count) {\n  const ideas = [];\n  const baseIdeas = [\n    `Tutorial avanzado sobre ${patterns.bestType}`,\n    `Top 5 tips de ${patterns.bestType}`,\n    `Review completo de herramientas de ${patterns.bestType}`,\n    `Guía paso a paso: ${patterns.bestType}`,\n    `Comparación: ${patterns.bestType} vs alternativas`\n  ];\n  \n  for (let i = 0; i < Math.min(count, baseIdeas.length); i++) {\n    ideas.push({\n      id: `idea_${i + 1}`,\n      title: baseIdeas[i],\n      estimatedEngagement: Math.round(patterns.avgLikes * 0.8),\n      priority: i < 2 ? 'high' : 'medium',\n      basedOn: 'successful_patterns'\n    });\n  }\n  \n  return ideas;\n}\n\nfunction generateOptimizationSuggestions(summary) {\n  const suggestions = [];\n  \n  if (summary.seoAnalysis && parseFloat(summary.seoAnalysis.avgSEOScore) < 70) {\n    suggestions.push({\n      area: 'SEO',\n      suggestion: 'Optimizar títulos y descripciones para mejor SEO',\n      impact: 'high'\n    });\n  }\n  \n  if (summary.engagementAnalysis && parseFloat(summary.engagementAnalysis.avgEngagementRate) < 2000) {\n    suggestions.push({\n      area: 'Engagement',\n      suggestion: 'Mejorar hook inicial y primeros 3 segundos',\n      impact: 'high'\n    });\n  }\n  \n  return suggestions;\n}\n\nreturn [{\n  json: {\n    ...summary,\n    smartContentRecommendations: smartRecommendations\n  }\n}];"
      },
      "id": "smart-content-recommendations",
      "name": "Smart Content Recommendations",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [8050, 400],
      "notes": "Recomendaciones inteligentes de contenido basadas en patrones exitosos",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Integración multi-plataforma avanzada\nconst summary = $json;\nconst enableMulti = summary.enableMultiPlatformIntegration !== false;\n\nif (!enableMulti || !summary.optimizedContent || summary.optimizedContent.length === 0) {\n  return [$input.item];\n}\n\nconst multiPlatformIntegration = {\n  timestamp: new Date().toISOString(),\n  platforms: {},\n  crossPlatformStrategy: {},\n  unifiedContent: []\n};\n\n// Configuración por plataforma\nmultiPlatformIntegration.platforms = {\n  tiktok: {\n    enabled: true,\n    apiReady: false,\n    contentCount: summary.optimizedContent.filter(c => c.platforms.tiktok).length,\n    features: ['hashtags', 'captions', 'scheduling', 'analytics']\n  },\n  instagram: {\n    enabled: summary.enableMultiPlatform !== false,\n    apiReady: false,\n    contentCount: summary.optimizedContent.filter(c => c.platforms.instagram).length,\n    features: ['reels', 'stories', 'posts', 'hashtags']\n  },\n  youtube: {\n    enabled: summary.enableMultiPlatform !== false,\n    apiReady: !!summary.hasYouTube,\n    contentCount: summary.optimizedContent.filter(c => c.platforms.youtube).length,\n    features: ['videos', 'shorts', 'thumbnails', 'descriptions']\n  },\n  twitter: {\n    enabled: false,\n    apiReady: false,\n    contentCount: 0,\n    features: ['tweets', 'threads', 'media']\n  },\n  linkedin: {\n    enabled: false,\n    apiReady: false,\n    contentCount: 0,\n    features: ['posts', 'articles', 'videos']\n  },\n  facebook: {\n    enabled: false,\n    apiReady: false,\n    contentCount: 0,\n    features: ['posts', 'videos', 'reels']\n  }\n};\n\n// Estrategia cross-platform\nmultiPlatformIntegration.crossPlatformStrategy = {\n  contentRepurposing: {\n    enabled: true,\n    strategy: 'Adaptar contenido principal a formato de cada plataforma',\n    platforms: ['tiktok', 'instagram', 'youtube']\n  },\n  scheduling: {\n    enabled: true,\n    staggeredPosting: true,\n    timeIntervals: {\n      tiktok: 'primary',\n      instagram: '+30min',\n      youtube: '+1hour'\n    }\n  },\n  analytics: {\n    unified: true,\n    crossPlatformMetrics: ['engagement', 'reach', 'conversions']\n  }\n};\n\n// Contenido unificado\nsummary.optimizedContent.forEach(content => {\n  const unified = {\n    contentId: content.videoId,\n    originalTitle: content.title,\n    platforms: Object.keys(content.platforms || {}),\n    unifiedMetadata: {\n      tags: getAllTags(content),\n      categories: [content.contentType || 'general'],\n      keywords: extractKeywords(content.title || '')\n    },\n    crossPlatformContent: generateCrossPlatformContent(content)\n  };\n  \n  multiPlatformIntegration.unifiedContent.push(unified);\n});\n\nfunction getAllTags(content) {\n  const tags = new Set();\n  \n  if (content.platforms.tiktok) {\n    content.platforms.tiktok.hashtags.forEach(tag => tags.add(tag.replace('#', '')));\n  }\n  if (content.platforms.instagram) {\n    content.platforms.instagram.hashtags.forEach(tag => tags.add(tag.replace('#', '')));\n  }\n  if (content.platforms.youtube) {\n    content.platforms.youtube.tags.forEach(tag => tags.add(tag));\n  }\n  \n  return Array.from(tags);\n}\n\nfunction extractKeywords(title) {\n  const words = title.toLowerCase().split(/\\s+/).filter(w => w.length > 4);\n  return words.slice(0, 5);\n}\n\nfunction generateCrossPlatformContent(content) {\n  return {\n    twitter: {\n      thread: generateTwitterThread(content),\n      tweet: generateTwitterTweet(content)\n    },\n    linkedin: {\n      post: generateLinkedInPost(content),\n      article: generateLinkedInArticle(content)\n    },\n    facebook: {\n      post: generateFacebookPost(content)\n    }\n  };\n}\n\nfunction generateTwitterThread(content) {\n  const title = content.title || 'Video de IA';\n  return [\n    `🧵 ${title}`,\n    '📚 Contenido completo disponible en el PDF descargable',\n    '💡 Aprende paso a paso cómo replicar esto'\n  ];\n}\n\nfunction generateTwitterTweet(content) {\n  const title = content.title || 'Video de IA';\n  return `${title} 📥 PDF completo disponible #AI #Tech`;\n}\n\nfunction generateLinkedInPost(content) {\n  const title = content.title || 'Video de IA';\n  return `${title}\\n\\nHe descubierto una técnica interesante que quiero compartir con la comunidad.\\n\\n📥 Descarga el PDF completo para más detalles.\\n\\n#AI #Technology #Innovation`;\n}\n\nfunction generateLinkedInArticle(content) {\n  const title = content.title || 'Video de IA';\n  return `# ${title}\\n\\n## Introducción\\n\\nEste artículo explora las técnicas y estrategias presentadas en el video.\\n\\n## Contenido Principal\\n\\n[Contenido del PDF]\\n\\n## Conclusión\\n\\nDescarga el PDF completo para más detalles.`;\n}\n\nfunction generateFacebookPost(content) {\n  const title = content.title || 'Video de IA';\n  return `${title}\\n\\n📚 Tutorial completo disponible\\n💡 Aprende paso a paso\\n📥 Descarga el PDF`;\n}\n\nmultiPlatformIntegration.summary = {\n  totalPlatforms: Object.keys(multiPlatformIntegration.platforms).length,\n  activePlatforms: Object.values(multiPlatformIntegration.platforms).filter(p => p.enabled).length,\n  totalUnifiedContent: multiPlatformIntegration.unifiedContent.length\n};\n\nreturn [{\n  json: {\n    ...summary,\n    multiPlatformIntegration: multiPlatformIntegration\n  }\n}];"
      },
      "id": "multi-platform-integration",
      "name": "Multi-Platform Integration",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [8250, 400],
      "notes": "Integración avanzada multi-plataforma (Twitter, LinkedIn, Facebook)",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Análisis de conversión\nconst summary = $json;\nconst enableConversion = summary.enableConversionAnalysis !== false;\n\nif (!enableConversion || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\nconst conversionAnalysis = {\n  timestamp: new Date().toISOString(),\n  conversionFunnels: {},\n  conversionRates: {},\n  optimizationOpportunities: []\n};\n\n// Análisis de funnel de conversión\nconst totalViews = summary.outputs.reduce((sum, v) => sum + (v.view_count || 0), 0);\nconst totalLikes = summary.outputs.reduce((sum, v) => sum + (v.like_count || 0), 0);\nconst totalShares = summary.outputs.reduce((sum, v) => sum + (v.share_count || 0), 0);\nconst totalComments = summary.outputs.reduce((sum, v) => sum + (v.comment_count || 0), 0);\n\nconversionAnalysis.conversionFunnels = {\n  viewsToLikes: totalViews > 0 ? ((totalLikes / totalViews) * 100).toFixed(2) : '0.00',\n  likesToShares: totalLikes > 0 ? ((totalShares / totalLikes) * 100).toFixed(2) : '0.00',\n  likesToComments: totalLikes > 0 ? ((totalComments / totalLikes) * 100).toFixed(2) : '0.00',\n  viewsToEngagement: totalViews > 0 ? (((totalLikes + totalShares + totalComments) / totalViews) * 100).toFixed(2) : '0.00'\n};\n\n// Tasas de conversión\nconversionAnalysis.conversionRates = {\n  viewToLikeRate: parseFloat(conversionAnalysis.conversionFunnels.viewsToLikes),\n  likeToShareRate: parseFloat(conversionAnalysis.conversionFunnels.likesToShares),\n  likeToCommentRate: parseFloat(conversionAnalysis.conversionFunnels.likesToComments),\n  overallEngagementRate: parseFloat(conversionAnalysis.conversionFunnels.viewsToEngagement)\n};\n\n// Oportunidades de optimización\nif (conversionAnalysis.conversionRates.viewToLikeRate < 2) {\n  conversionAnalysis.optimizationOpportunities.push({\n    stage: 'view_to_like',\n    currentRate: conversionAnalysis.conversionRates.viewToLikeRate + '%',\n    targetRate: '3-5%',\n    recommendation: 'Mejorar hook inicial y primeros 3 segundos del video',\n    priority: 'high',\n    expectedImprovement: '50-100% aumento en tasa de conversión'\n  });\n}\n\nif (conversionAnalysis.conversionRates.likeToShareRate < 1) {\n  conversionAnalysis.optimizationOpportunities.push({\n    stage: 'like_to_share',\n    currentRate: conversionAnalysis.conversionRates.likeToShareRate + '%',\n    targetRate: '2-3%',\n    recommendation: 'Agregar call-to-action más claro para compartir',\n    priority: 'medium',\n    expectedImprovement: '30-50% aumento en shares'\n  });\n}\n\n// Análisis por video\nconversionAnalysis.videoBreakdown = summary.outputs.map(video => {\n  const views = video.view_count || 0;\n  const likes = video.like_count || 0;\n  const conversionRate = views > 0 ? ((likes / views) * 100).toFixed(2) : '0.00';\n  \n  return {\n    videoId: video.video_id,\n    title: video.title,\n    views: views,\n    likes: likes,\n    conversionRate: parseFloat(conversionRate),\n    performance: parseFloat(conversionRate) > 3 ? 'high' : parseFloat(conversionRate) > 1 ? 'medium' : 'low'\n  };\n});\n\nconversionAnalysis.summary = {\n  avgConversionRate: (conversionAnalysis.videoBreakdown.reduce((sum, v) => sum + v.conversionRate, 0) / conversionAnalysis.videoBreakdown.length).toFixed(2),\n  highPerformers: conversionAnalysis.videoBreakdown.filter(v => v.performance === 'high').length,\n  optimizationOpportunities: conversionAnalysis.optimizationOpportunities.length\n};\n\nreturn [{\n  json: {\n    ...summary,\n    conversionAnalysis: conversionAnalysis\n  }\n}];"
      },
      "id": "conversion-analysis",
      "name": "Conversion Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [8450, 400],
      "notes": "Análisis de conversión y funnels",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// A/B Testing avanzado\nconst summary = $json;\nconst enableAdvancedAB = summary.enableAdvancedABTesting !== false;\n\nif (!enableAdvancedAB || !summary.abTestVariants || summary.abTestVariants.length === 0) {\n  return [$input.item];\n}\n\nconst advancedABTesting = {\n  timestamp: new Date().toISOString(),\n  testConfigurations: [],\n  statisticalAnalysis: {},\n  recommendations: []\n};\n\n// Configuraciones de test avanzadas\nsummary.abTestVariants.forEach(test => {\n  const config = {\n    testId: test.testId,\n    videoId: test.videoId,\n    variants: Object.keys(test.variants || {}),\n    testDuration: '7 days',\n    sampleSize: 1000,\n    confidenceLevel: 0.95,\n    metrics: ['engagement_rate', 'views', 'shares', 'comments'],\n    hypothesis: {\n      null: 'No hay diferencia significativa entre variantes',\n      alternative: 'Variante B tiene mejor rendimiento'\n    },\n    statisticalPower: 0.80\n  };\n  \n  advancedABTesting.testConfigurations.push(config);\n});\n\n// Análisis estadístico\nadvancedABTesting.statisticalAnalysis = {\n  totalTests: advancedABTesting.testConfigurations.length,\n  recommendedSampleSize: 1000,\n  minDuration: '7 days',\n  significanceLevel: 0.05,\n  powerAnalysis: {\n    requiredSampleSize: 1000,\n    currentPower: 0.80,\n    recommended: 'Continue testing'\n  }\n};\n\n// Recomendaciones\nadvancedABTesting.recommendations = [\n  {\n    type: 'test_design',\n    recommendation: 'Ejecutar tests por mínimo 7 días para resultados estadísticamente significativos',\n    priority: 'high'\n  },\n  {\n    type: 'sample_size',\n    recommendation: 'Asegurar mínimo 1000 muestras por variante',\n    priority: 'medium'\n  },\n  {\n    type: 'metrics',\n    recommendation: 'Monitorear múltiples métricas: engagement, views, shares',\n    priority: 'high'\n  }\n];\n\n// Estrategia de testing\nadvancedABTesting.testingStrategy = {\n  approach: 'sequential_testing',\n  phases: [\n    { phase: 1, duration: '3 days', goal: 'Initial data collection' },\n    { phase: 2, duration: '4 days', goal: 'Statistical significance' },\n    { phase: 3, duration: 'ongoing', goal: 'Continuous optimization' }\n  ],\n  winnerCriteria: {\n    primary: 'engagement_rate > 5%',\n    secondary: ['views > baseline', 'shares > baseline']\n  }\n};\n\nreturn [{\n  json: {\n    ...summary,\n    advancedABTesting: advancedABTesting\n  }\n}];"
      },
      "id": "advanced-ab-testing",
      "name": "Advanced A/B Testing",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [8650, 400],
      "notes": "A/B Testing avanzado con análisis estadístico",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Integración con CRM\nconst summary = $json;\nconst enableCRM = summary.enableCRMIntegration !== false;\n\nif (!enableCRM) {\n  return [$input.item];\n}\n\nconst crmIntegration = {\n  timestamp: new Date().toISOString(),\n  crmSystems: {},\n  contacts: [],\n  campaigns: [],\n  leads: []\n};\n\n// Integración con sistemas CRM populares\ncrmIntegration.crmSystems = {\n  salesforce: {\n    enabled: false,\n    apiReady: false,\n    note: 'Configurar Salesforce API credentials'\n  },\n  hubspot: {\n    enabled: false,\n    apiReady: false,\n    note: 'Configurar HubSpot API credentials'\n  },\n  pipedrive: {\n    enabled: false,\n    apiReady: false,\n    note: 'Configurar Pipedrive API credentials'\n  },\n  custom: {\n    enabled: true,\n    apiReady: false,\n    endpoint: 'crm_api_endpoint',\n    note: 'Configurar endpoint personalizado'\n  }\n};\n\n// Generar leads basados en contenido exitoso\nif (summary.outputs && summary.outputs.length > 0) {\n  const topVideos = summary.outputs\n    .sort((a, b) => ((b.like_count || 0) + (b.view_count || 0) / 10) - ((a.like_count || 0) + (a.view_count || 0) / 10))\n    .slice(0, 3);\n  \n  topVideos.forEach((video, idx) => {\n    crmIntegration.leads.push({\n      leadId: `lead_${video.video_id}_${Date.now()}`,\n      source: 'ai_video_pipeline',\n      interest: video.contentType || 'general',\n      engagement: (video.like_count || 0) + ((video.view_count || 0) / 10),\n      metadata: {\n        videoTitle: video.title,\n        videoUrl: video.url,\n        likes: video.like_count || 0,\n        views: video.view_count || 0\n      },\n      status: 'new',\n      priority: idx === 0 ? 'high' : 'medium'\n    });\n  });\n}\n\n// Campañas basadas en contenido\nif (summary.optimizedContent && summary.optimizedContent.length > 0) {\n  summary.optimizedContent.slice(0, 3).forEach(content => {\n    crmIntegration.campaigns.push({\n      campaignId: `campaign_${content.videoId}_${Date.now()}`,\n      name: `Campaña: ${content.title}`,\n      type: 'content_marketing',\n      platforms: Object.keys(content.platforms || {}),\n      scheduledPosts: summary.scheduledPosts?.filter(p => p.videoId === content.videoId).length || 0,\n      status: 'planned',\n      expectedReach: estimateReach(content)\n    });\n  });\n}\n\nfunction estimateReach(content) {\n  const baseReach = 1000;\n  const platformMultiplier = {\n    tiktok: 1.5,\n    instagram: 1.2,\n    youtube: 1.8\n  };\n  \n  let totalReach = baseReach;\n  Object.keys(content.platforms || {}).forEach(platform => {\n    totalReach += baseReach * (platformMultiplier[platform] || 1);\n  });\n  \n  return Math.round(totalReach);\n}\n\ncrmIntegration.summary = {\n  totalLeads: crmIntegration.leads.length,\n  totalCampaigns: crmIntegration.campaigns.length,\n  crmSystemsConfigured: Object.values(crmIntegration.crmSystems).filter(c => c.enabled).length\n};\n\nreturn [{\n  json: {\n    ...summary,\n    crmIntegration: crmIntegration\n  }\n}];"
      },
      "id": "crm-integration",
      "name": "CRM Integration",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [8850, 400],
      "notes": "Integración con sistemas CRM (Salesforce, HubSpot, Pipedrive)",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Contenido predictivo\nconst summary = $json;\nconst enablePredictive = summary.enablePredictiveContent !== false;\n\nif (!enablePredictive || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\nconst predictiveContent = {\n  timestamp: new Date().toISOString(),\n  predictions: {},\n  contentForecast: {},\n  recommendations: []\n};\n\n// Predicciones de rendimiento futuro\nconst historicalData = summary.outputs.map(v => ({\n  likes: v.like_count || 0,\n  views: v.view_count || 0,\n  contentType: v.contentType || 'general',\n  titleLength: (v.title || '').length\n}));\n\nconst avgLikes = historicalData.reduce((sum, v) => sum + v.likes, 0) / historicalData.length;\nconst avgViews = historicalData.reduce((sum, v) => sum + v.views, 0) / historicalData.length;\n\npredictiveContent.predictions = {\n  nextWeek: {\n    expectedVideos: summary.outputs.length,\n    expectedLikes: Math.round(avgLikes * summary.outputs.length),\n    expectedViews: Math.round(avgViews * summary.outputs.length),\n    confidence: 0.75\n  },\n  nextMonth: {\n    expectedVideos: summary.outputs.length * 4,\n    expectedLikes: Math.round(avgLikes * summary.outputs.length * 4),\n    expectedViews: Math.round(avgViews * summary.outputs.length * 4),\n    confidence: 0.60\n  },\n  trends: {\n    contentTypeTrend: predictContentTypeTrend(historicalData),\n    engagementTrend: predictEngagementTrend(historicalData),\n    optimalPostingTime: predictOptimalPostingTime()\n  }\n};\n\n// Pronóstico de contenido\npredictiveContent.contentForecast = {\n  recommendedTopics: generateRecommendedTopics(summary),\n  optimalContentMix: calculateOptimalContentMix(historicalData),\n  timingRecommendations: generateTimingRecommendations()\n};\n\n// Recomendaciones predictivas\npredictiveContent.recommendations = [\n  {\n    type: 'content_planning',\n    recommendation: `Crear ${predictiveContent.contentForecast.optimalContentMix.tutorial || 0} tutoriales esta semana`,\n    reason: 'Basado en rendimiento histórico',\n    confidence: 0.80\n  },\n  {\n    type: 'engagement',\n    recommendation: 'Publicar en horarios 18:00-20:00 UTC para máximo engagement',\n    reason: 'Análisis de patrones históricos',\n    confidence: 0.75\n  }\n];\n\nfunction predictContentTypeTrend(data) {\n  const typeCounts = {};\n  data.forEach(d => {\n    const type = d.contentType;\n    typeCounts[type] = (typeCounts[type] || 0) + 1;\n  });\n  \n  const mostCommon = Object.entries(typeCounts).sort((a, b) => b[1] - a[1])[0]?.[0];\n  return {\n    trending: mostCommon || 'general',\n    trendDirection: 'stable',\n    confidence: 0.70\n  };\n}\n\nfunction predictEngagementTrend(data) {\n  const recent = data.slice(-5);\n  const older = data.slice(0, -5);\n  \n  const recentAvg = recent.reduce((sum, v) => sum + v.likes, 0) / recent.length;\n  const olderAvg = older.length > 0 ? older.reduce((sum, v) => sum + v.likes, 0) / older.length : recentAvg;\n  \n  const change = ((recentAvg - olderAvg) / olderAvg) * 100;\n  \n  return {\n    direction: change > 0 ? 'increasing' : 'decreasing',\n    change: change.toFixed(2) + '%',\n    confidence: 0.65\n  };\n}\n\nfunction predictOptimalPostingTime() {\n  return {\n    weekday: 'Monday',\n    time: '18:00 UTC',\n    confidence: 0.70\n  };\n}\n\nfunction generateRecommendedTopics(summary) {\n  const topics = [];\n  \n  if (summary.realTimeTrendAnalysis && summary.realTimeTrendAnalysis.trendingTopics.length > 0) {\n    summary.realTimeTrendAnalysis.trendingTopics.slice(0, 5).forEach(topic => {\n      topics.push({\n        keyword: topic.keyword,\n        trend: 'rising',\n        estimatedEngagement: Math.round((topic.frequency || 1) * 1000),\n        recommendation: 'high'\n      });\n    });\n  }\n  \n  return topics.length > 0 ? topics : [\n    { keyword: 'AI Tutorials', trend: 'stable', estimatedEngagement: 5000, recommendation: 'medium' },\n    { keyword: 'Automation Tips', trend: 'rising', estimatedEngagement: 4000, recommendation: 'high' }\n  ];\n}\n\nfunction calculateOptimalContentMix(data) {\n  const typePerformance = {};\n  \n  data.forEach(d => {\n    const type = d.contentType || 'general';\n    if (!typePerformance[type]) {\n      typePerformance[type] = { count: 0, totalLikes: 0 };\n    }\n    typePerformance[type].count++;\n    typePerformance[type].totalLikes += d.likes;\n  });\n  \n  const mix = {};\n  Object.entries(typePerformance).forEach(([type, perf]) => {\n    const avgLikes = perf.totalLikes / perf.count;\n    const percentage = Math.round((avgLikes / (Object.values(typePerformance).reduce((sum, p) => sum + p.totalLikes / p.count, 0) / Object.keys(typePerformance).length)) * 100);\n    mix[type] = Math.max(1, Math.round(percentage / 10));\n  });\n  \n  return mix;\n}\n\nfunction generateTimingRecommendations() {\n  return {\n    bestDays: ['Monday', 'Wednesday', 'Friday'],\n    bestTimes: ['18:00 UTC', '19:00 UTC', '20:00 UTC'],\n    avoidDays: ['Sunday'],\n    avoidTimes: ['02:00 UTC', '03:00 UTC']\n  };\n}\n\nreturn [{\n  json: {\n    ...summary,\n    predictiveContent: predictiveContent\n  }\n}];"
      },
      "id": "predictive-content",
      "name": "Predictive Content",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [9050, 400],
      "notes": "Contenido predictivo y pronósticos",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Análisis de sentimiento avanzado con NLP\nconst summary = $json;\nconst enableSentiment = summary.enableAdvancedSentiment !== false;\n\nif (!enableSentiment || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\nconst advancedSentiment = {\n  timestamp: new Date().toISOString(),\n  model: 'GPT-4 + NLP Analysis',\n  sentimentResults: []\n};\n\nsummary.outputs.forEach(video => {\n  const title = video.title || '';\n  const transcript = video.transcript || '';\n  const text = `${title} ${transcript}`.substring(0, 1000);\n  \n  const sentiment = {\n    videoId: video.video_id,\n    title: title,\n    overallSentiment: analyzeAdvancedSentiment(text),\n    emotionBreakdown: analyzeEmotions(text),\n    topicSentiment: analyzeTopicSentiment(text),\n    sentimentScore: calculateSentimentScore(text),\n    recommendations: generateSentimentRecommendations(text, video)\n  };\n  \n  advancedSentiment.sentimentResults.push(sentiment);\n});\n\n// Estadísticas agregadas\nadvancedSentiment.summary = {\n  totalAnalyzed: advancedSentiment.sentimentResults.length,\n  avgSentimentScore: advancedSentiment.sentimentResults.reduce((sum, s) => sum + s.sentimentScore, 0) / advancedSentiment.sentimentResults.length,\n  dominantEmotion: getDominantEmotion(advancedSentiment.sentimentResults),\n  positiveRatio: advancedSentiment.sentimentResults.filter(s => s.overallSentiment === 'positive').length / advancedSentiment.sentimentResults.length\n};\n\nfunction analyzeAdvancedSentiment(text) {\n  const lowerText = text.toLowerCase();\n  const positiveWords = ['amazing', 'incredible', 'awesome', 'great', 'best', 'excellent', 'perfect', 'love', 'fantastic'];\n  const negativeWords = ['bad', 'worst', 'terrible', 'awful', 'hate', 'disappointing', 'poor', 'fail'];\n  \n  const positiveCount = positiveWords.filter(w => lowerText.includes(w)).length;\n  const negativeCount = negativeWords.filter(w => lowerText.includes(w)).length;\n  \n  if (positiveCount > negativeCount * 1.5) return 'positive';\n  if (negativeCount > positiveCount * 1.5) return 'negative';\n  return 'neutral';\n}\n\nfunction analyzeEmotions(text) {\n  const emotions = {\n    joy: (text.match(/\\b(happy|joy|excited|great|amazing|love|fantastic)\\b/gi) || []).length,\n    surprise: (text.match(/\\b(wow|surprise|unexpected|incredible|amazing)\\b/gi) || []).length,\n    anger: (text.match(/\\b(angry|frustrated|annoyed|hate|terrible)\\b/gi) || []).length,\n    fear: (text.match(/\\b(scared|worried|afraid|concerned|risky)\\b/gi) || []).length,\n    sadness: (text.match(/\\b(sad|disappointed|unhappy|poor|bad)\\b/gi) || []).length\n  };\n  \n  const total = Object.values(emotions).reduce((a, b) => a + b, 0);\n  if (total === 0) return { joy: 0, surprise: 0, anger: 0, fear: 0, sadness: 0 };\n  \n  Object.keys(emotions).forEach(key => {\n    emotions[key] = emotions[key] / total;\n  });\n  \n  return emotions;\n}\n\nfunction analyzeTopicSentiment(text) {\n  const topics = {\n    ai: analyzeTopic(text, ['ai', 'artificial intelligence', 'machine learning']),\n    automation: analyzeTopic(text, ['automation', 'automate', 'automatic']),\n    tutorial: analyzeTopic(text, ['tutorial', 'learn', 'how to', 'guide'])\n  };\n  \n  return topics;\n}\n\nfunction analyzeTopic(text, keywords) {\n  const lowerText = text.toLowerCase();\n  const hasTopic = keywords.some(k => lowerText.includes(k));\n  if (!hasTopic) return { present: false, sentiment: 'neutral' };\n  \n  return {\n    present: true,\n    sentiment: analyzeAdvancedSentiment(text),\n    relevance: keywords.filter(k => lowerText.includes(k)).length / keywords.length\n  };\n}\n\nfunction calculateSentimentScore(text) {\n  const lowerText = text.toLowerCase();\n  let score = 0.5; // neutral base\n  \n  const positiveWords = ['amazing', 'incredible', 'awesome', 'great', 'best', 'excellent', 'perfect', 'love'];\n  const negativeWords = ['bad', 'worst', 'terrible', 'awful', 'hate', 'disappointing', 'poor'];\n  \n  positiveWords.forEach(w => {\n    if (lowerText.includes(w)) score += 0.1;\n  });\n  \n  negativeWords.forEach(w => {\n    if (lowerText.includes(w)) score -= 0.1;\n  });\n  \n  return Math.max(0, Math.min(1, score));\n}\n\nfunction generateSentimentRecommendations(text, video) {\n  const recommendations = [];\n  const sentiment = analyzeAdvancedSentiment(text);\n  \n  if (sentiment === 'negative') {\n    recommendations.push('Considerar ajustar el tono del contenido para ser más positivo');\n  }\n  \n  if (video.like_count < 1000 && sentiment === 'neutral') {\n    recommendations.push('Agregar más palabras emocionales para aumentar engagement');\n  }\n  \n  return recommendations;\n}\n\nfunction getDominantEmotion(results) {\n  const emotionTotals = { joy: 0, surprise: 0, anger: 0, fear: 0, sadness: 0 };\n  \n  results.forEach(r => {\n    Object.keys(r.emotionBreakdown).forEach(emotion => {\n      emotionTotals[emotion] += r.emotionBreakdown[emotion];\n    });\n  });\n  \n  return Object.entries(emotionTotals).sort((a, b) => b[1] - a[1])[0]?.[0] || 'neutral';\n}\n\nreturn [{\n  json: {\n    ...summary,\n    advancedSentiment: advancedSentiment\n  }\n}];"
      },
      "id": "advanced-sentiment",
      "name": "Advanced Sentiment Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [9250, 400],
      "notes": "Análisis de sentimiento avanzado con NLP",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Generación automática de subtítulos\nconst summary = $json;\nconst enableSubtitles = summary.enableAutoSubtitles !== false;\n\nif (!enableSubtitles || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst outputDir = summary.outputDir || './ai_video_outputs';\nconst subtitlesDir = path.join(outputDir, 'subtitles');\n\nfs.mkdirSync(subtitlesDir, { recursive: true });\n\nconst autoSubtitles = {\n  timestamp: new Date().toISOString(),\n  subtitles: []\n};\n\nsummary.outputs.forEach(video => {\n  const videoId = video.video_id || `video_${Date.now()}`;\n  const transcript = video.transcript || '';\n  \n  // Generar subtítulos en múltiples idiomas\n  const languages = ['es', 'en', 'pt', 'fr'];\n  const subtitleFiles = {};\n  \n  languages.forEach(lang => {\n    const subtitleContent = generateSubtitleFile(transcript, lang, video);\n    const subtitleFile = path.join(subtitlesDir, `${videoId}_${lang}.srt`);\n    fs.writeFileSync(subtitleFile, subtitleContent, 'utf-8');\n    subtitleFiles[lang] = subtitleFile;\n  });\n  \n  autoSubtitles.subtitles.push({\n    videoId: videoId,\n    title: video.title,\n    languages: languages,\n    files: subtitleFiles,\n    formats: ['SRT', 'VTT'],\n    autoGenerated: true\n  });\n});\n\nfunction generateSubtitleFile(transcript, lang, video) {\n  // Generar formato SRT básico\n  const words = transcript.split(/\\s+/);\n  const wordsPerSubtitle = 10;\n  let srtContent = '';\n  let subtitleIndex = 1;\n  \n  for (let i = 0; i < words.length; i += wordsPerSubtitle) {\n    const subtitleWords = words.slice(i, i + wordsPerSubtitle);\n    const startTime = formatTime(i * 2); // 2 segundos por palabra\n    const endTime = formatTime((i + wordsPerSubtitle) * 2);\n    \n    srtContent += `${subtitleIndex}\\n`;\n    srtContent += `${startTime} --> ${endTime}\\n`;\n    srtContent += `${subtitleWords.join(' ')}\\n\\n`;\n    \n    subtitleIndex++;\n  }\n  \n  return srtContent;\n}\n\nfunction formatTime(seconds) {\n  const hours = Math.floor(seconds / 3600);\n  const minutes = Math.floor((seconds % 3600) / 60);\n  const secs = Math.floor(seconds % 60);\n  const millis = Math.floor((seconds % 1) * 1000);\n  \n  return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')},${String(millis).padStart(3, '0')}`;\n}\n\nautoSubtitles.summary = {\n  totalSubtitles: autoSubtitles.subtitles.length,\n  totalLanguages: 4,\n  subtitleDirectory: subtitlesDir\n};\n\nreturn [{\n  json: {\n    ...summary,\n    autoSubtitles: autoSubtitles\n  }\n}];"
      },
      "id": "auto-subtitles",
      "name": "Auto Subtitles",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [9450, 400],
      "notes": "Generación automática de subtítulos en múltiples idiomas",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Análisis profundo de competidores\nconst summary = $json;\nconst enableDeep = summary.enableCompetitorDeepAnalysis !== false;\n\nif (!enableDeep || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\nconst competitorDeepAnalysis = {\n  timestamp: new Date().toISOString(),\n  competitors: [],\n  insights: {},\n  recommendations: []\n};\n\n// Analizar patrones de competidores\nconst topVideos = summary.outputs\n  .sort((a, b) => ((b.like_count || 0) + (b.view_count || 0) / 10) - ((a.like_count || 0) + (a.view_count || 0) / 10))\n  .slice(0, 10);\n\n// Extraer información de competidores\nconst competitorPatterns = {\n  avgTitleLength: 0,\n  commonKeywords: {},\n  postingPatterns: {},\n  contentTypes: {},\n  engagementStrategies: []\n};\n\ntopVideos.forEach(video => {\n  competitorPatterns.avgTitleLength += (video.title || '').length;\n  \n  const words = (video.title || '').toLowerCase().split(/\\s+/).filter(w => w.length > 3);\n  words.forEach(word => {\n    competitorPatterns.commonKeywords[word] = (competitorPatterns.commonKeywords[word] || 0) + 1;\n  });\n  \n  const contentType = video.contentType || 'general';\n  competitorPatterns.contentTypes[contentType] = (competitorPatterns.contentTypes[contentType] || 0) + 1;\n});\n\ncompetitorPatterns.avgTitleLength = Math.round(competitorPatterns.avgTitleLength / topVideos.length);\n\n// Identificar estrategias de engagement\ncompetitorDeepAnalysis.insights = {\n  optimalTitleLength: competitorPatterns.avgTitleLength,\n  topKeywords: Object.entries(competitorPatterns.commonKeywords)\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 10)\n    .map(([word, count]) => ({ word, frequency: count })),\n  bestContentType: Object.entries(competitorPatterns.contentTypes)\n    .sort((a, b) => b[1] - a[1])[0]?.[0] || 'general',\n  avgEngagement: topVideos.reduce((sum, v) => sum + (v.like_count || 0), 0) / topVideos.length,\n  engagementRate: topVideos.reduce((sum, v) => {\n    const views = v.view_count || 1;\n    const likes = v.like_count || 0;\n    return sum + (likes / views);\n  }, 0) / topVideos.length\n};\n\n// Recomendaciones basadas en análisis\ncompetitorDeepAnalysis.recommendations = [\n  {\n    type: 'title_optimization',\n    recommendation: `Usar títulos de aproximadamente ${competitorPatterns.avgTitleLength} caracteres`,\n    priority: 'high'\n  },\n  {\n    type: 'keyword_strategy',\n    recommendation: `Incluir keywords: ${competitorDeepAnalysis.insights.topKeywords.slice(0, 3).map(k => k.word).join(', ')}`,\n    priority: 'high'\n  },\n  {\n    type: 'content_type',\n    recommendation: `Enfocarse en contenido tipo: ${competitorDeepAnalysis.insights.bestContentType}`,\n    priority: 'medium'\n  }\n];\n\ncompetitorDeepAnalysis.summary = {\n  videosAnalyzed: topVideos.length,\n  insightsGenerated: Object.keys(competitorDeepAnalysis.insights).length,\n  recommendationsCount: competitorDeepAnalysis.recommendations.length\n};\n\nreturn [{\n  json: {\n    ...summary,\n    competitorDeepAnalysis: competitorDeepAnalysis\n  }\n}];"
      },
      "id": "competitor-deep-analysis",
      "name": "Competitor Deep Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [9650, 400],
      "notes": "Análisis profundo de competidores con patrones y estrategias",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Recomendaciones personalizadas con ML\nconst summary = $json;\nconst enablePersonalized = summary.enablePersonalizedRecommendations !== false;\n\nif (!enablePersonalized || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\nconst personalizedRecommendations = {\n  timestamp: new Date().toISOString(),\n  model: 'Personalized ML Model',\n  recommendations: [],\n  userProfile: {},\n  contentSuggestions: []\n};\n\n// Crear perfil de usuario basado en historial\nconst userProfile = {\n  preferredContentTypes: extractPreferredTypes(summary.outputs),\n  preferredLength: calculatePreferredLength(summary.outputs),\n  engagementPatterns: analyzeEngagementPatterns(summary.outputs),\n  interests: extractInterests(summary.outputs)\n};\n\npersonalizedRecommendations.userProfile = userProfile;\n\n// Generar recomendaciones personalizadas\nsummary.outputs.forEach(video => {\n  const score = calculatePersonalizationScore(video, userProfile);\n  \n  personalizedRecommendations.recommendations.push({\n    videoId: video.video_id,\n    title: video.title,\n    personalizationScore: score,\n    reasons: generatePersonalizationReasons(video, userProfile),\n    action: score > 0.7 ? 'highly_recommended' : score > 0.5 ? 'recommended' : 'consider'\n  });\n});\n\n// Sugerencias de contenido\npersonalizedRecommendations.contentSuggestions = generateContentSuggestions(userProfile, summary.outputs.length);\n\nfunction extractPreferredTypes(videos) {\n  const types = {};\n  videos.forEach(v => {\n    const type = v.contentType || 'general';\n    types[type] = (types[type] || 0) + 1;\n  });\n  \n  return Object.entries(types)\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 3)\n    .map(([type]) => type);\n}\n\nfunction calculatePreferredLength(videos) {\n  const lengths = videos.map(v => (v.title || '').length);\n  const avg = lengths.reduce((a, b) => a + b, 0) / lengths.length;\n  return Math.round(avg);\n}\n\nfunction analyzeEngagementPatterns(videos) {\n  const highEngagement = videos.filter(v => (v.like_count || 0) > 5000);\n  return {\n    highEngagementRatio: highEngagement.length / videos.length,\n    avgLikes: videos.reduce((sum, v) => sum + (v.like_count || 0), 0) / videos.length\n  };\n}\n\nfunction extractInterests(videos) {\n  const interests = new Set();\n  videos.forEach(v => {\n    const title = (v.title || '').toLowerCase();\n    if (title.includes('ai')) interests.add('artificial_intelligence');\n    if (title.includes('automation')) interests.add('automation');\n    if (title.includes('tutorial')) interests.add('tutorials');\n  });\n  return Array.from(interests);\n}\n\nfunction calculatePersonalizationScore(video, profile) {\n  let score = 0.5;\n  \n  // Match con tipos preferidos\n  if (profile.preferredContentTypes.includes(video.contentType || 'general')) {\n    score += 0.2;\n  }\n  \n  // Match con longitud preferida\n  const titleLength = (video.title || '').length;\n  const lengthDiff = Math.abs(titleLength - profile.preferredLength);\n  if (lengthDiff < 10) score += 0.1;\n  \n  // Match con intereses\n  const title = (video.title || '').toLowerCase();\n  profile.interests.forEach(interest => {\n    if (title.includes(interest.replace('_', ' '))) score += 0.1;\n  });\n  \n  return Math.min(1, score);\n}\n\nfunction generatePersonalizationReasons(video, profile) {\n  const reasons = [];\n  \n  if (profile.preferredContentTypes.includes(video.contentType || 'general')) {\n    reasons.push('Matches your preferred content type');\n  }\n  \n  if (video.like_count > profile.engagementPatterns.avgLikes) {\n    reasons.push('High engagement potential');\n  }\n  \n  return reasons;\n}\n\nfunction generateContentSuggestions(profile, count) {\n  const suggestions = [];\n  \n  profile.preferredContentTypes.forEach((type, idx) => {\n    if (idx < count) {\n      suggestions.push({\n        type: type,\n        title: `Advanced ${type} tutorial`,\n        estimatedEngagement: Math.round(profile.engagementPatterns.avgLikes * 1.2),\n        priority: idx === 0 ? 'high' : 'medium'\n      });\n    }\n  });\n  \n  return suggestions;\n}\n\npersonalizedRecommendations.summary = {\n  totalRecommendations: personalizedRecommendations.recommendations.length,\n  highlyRecommended: personalizedRecommendations.recommendations.filter(r => r.action === 'highly_recommended').length,\n  contentSuggestions: personalizedRecommendations.contentSuggestions.length\n};\n\nreturn [{\n  json: {\n    ...summary,\n    personalizedRecommendations: personalizedRecommendations\n  }\n}];"
      },
      "id": "personalized-recommendations",
      "name": "Personalized Recommendations",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [9850, 400],
      "notes": "Recomendaciones personalizadas con ML basadas en perfil de usuario",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Integración con Analytics (Google Analytics, etc.)\nconst summary = $json;\nconst enableAnalytics = summary.enableAnalyticsIntegration !== false;\n\nif (!enableAnalytics) {\n  return [$input.item];\n}\n\nconst analyticsIntegration = {\n  timestamp: new Date().toISOString(),\n  analyticsPlatforms: {},\n  metrics: {},\n  insights: []\n};\n\n// Configuración de plataformas de analytics\nanalyticsIntegration.analyticsPlatforms = {\n  googleAnalytics: {\n    enabled: false,\n    apiReady: false,\n    note: 'Configurar Google Analytics API credentials'\n  },\n  facebookAnalytics: {\n    enabled: false,\n    apiReady: false,\n    note: 'Configurar Facebook Analytics API credentials'\n  },\n  youtubeAnalytics: {\n    enabled: summary.hasYouTube || false,\n    apiReady: summary.hasYouTube || false,\n    note: 'YouTube Analytics disponible si YOUTUBE_API_KEY está configurada'\n  },\n  customAnalytics: {\n    enabled: true,\n    apiReady: false,\n    endpoint: 'analytics_api_endpoint',\n    note: 'Configurar endpoint personalizado'\n  }\n};\n\n// Métricas agregadas\nif (summary.outputs && summary.outputs.length > 0) {\n  const totalViews = summary.outputs.reduce((sum, v) => sum + (v.view_count || 0), 0);\n  const totalLikes = summary.outputs.reduce((sum, v) => sum + (v.like_count || 0), 0);\n  const totalEngagement = totalLikes + (totalViews / 10);\n  \n  analyticsIntegration.metrics = {\n    totalViews: totalViews,\n    totalLikes: totalLikes,\n    totalEngagement: totalEngagement,\n    avgViewsPerVideo: totalViews / summary.outputs.length,\n    avgLikesPerVideo: totalLikes / summary.outputs.length,\n    engagementRate: totalViews > 0 ? ((totalLikes / totalViews) * 100).toFixed(2) : '0.00'\n  };\n  \n  // Insights\n  analyticsIntegration.insights = [\n    {\n      type: 'performance',\n      insight: `Videos procesados: ${summary.outputs.length} con ${totalViews.toLocaleString()} views totales`,\n      recommendation: 'Continuar con estrategia actual'\n    },\n    {\n      type: 'engagement',\n      insight: `Tasa de engagement: ${analyticsIntegration.metrics.engagementRate}%`,\n      recommendation: totalLikes / summary.outputs.length > 1000 ? 'Excelente engagement' : 'Mejorar engagement'\n    }\n  ];\n}\n\nanalyticsIntegration.summary = {\n  platformsConfigured: Object.values(analyticsIntegration.analyticsPlatforms).filter(p => p.enabled).length,\n  metricsTracked: Object.keys(analyticsIntegration.metrics).length,\n  insightsGenerated: analyticsIntegration.insights.length\n};\n\nreturn [{\n  json: {\n    ...summary,\n    analyticsIntegration: analyticsIntegration\n  }\n}];"
      },
      "id": "analytics-integration",
      "name": "Analytics Integration",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [10050, 400],
      "notes": "Integración con plataformas de analytics (Google Analytics, Facebook, YouTube)",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Alertas proactivas con ML\nconst summary = $json;\nconst enableProactive = summary.enableProactiveAlerts !== false;\n\nif (!enableProactive) {\n  return [$input.item];\n}\n\nconst proactiveAlerts = {\n  timestamp: new Date().toISOString(),\n  alerts: [],\n  predictions: {},\n  recommendations: []\n};\n\n// Detectar problemas potenciales\nif (summary.outputs && summary.outputs.length > 0) {\n  const avgLikes = summary.outputs.reduce((sum, v) => sum + (v.like_count || 0), 0) / summary.outputs.length;\n  \n  if (avgLikes < 1000) {\n    proactiveAlerts.alerts.push({\n      type: 'performance',\n      level: 'warning',\n      message: 'Engagement promedio bajo detectado',\n      action: 'Revisar estrategia de contenido',\n      predictedImpact: 'Bajo engagement puede afectar crecimiento'\n    });\n  }\n  \n  if (summary.errors && summary.errors.length > summary.outputs.length * 0.3) {\n    proactiveAlerts.alerts.push({\n      type: 'reliability',\n      level: 'critical',\n      message: 'Tasa de error alta detectada',\n      action: 'Revisar configuración y APIs',\n      predictedImpact: 'Alta tasa de error puede interrumpir operaciones'\n    });\n  }\n}\n\n// Predicciones\nproactiveAlerts.predictions = {\n  nextWeekPerformance: {\n    expectedVideos: summary.outputs?.length || 0,\n    expectedEngagement: Math.round((summary.outputs?.reduce((sum, v) => sum + (v.like_count || 0), 0) || 0) / (summary.outputs?.length || 1)),\n    confidence: 0.75\n  },\n  potentialIssues: [\n    {\n      issue: 'Rate limiting',\n      probability: 0.3,\n      recommendation: 'Monitorear uso de APIs'\n    },\n    {\n      issue: 'Cost increase',\n      probability: 0.4,\n      recommendation: 'Optimizar uso de APIs'\n    }\n  ]\n};\n\n// Recomendaciones proactivas\nproactiveAlerts.recommendations = [\n  {\n    type: 'preventive',\n    recommendation: 'Configurar alertas automáticas para métricas clave',\n    priority: 'high'\n  },\n  {\n    type: 'optimization',\n    recommendation: 'Revisar y optimizar configuración semanalmente',\n    priority: 'medium'\n  }\n];\n\nproactiveAlerts.summary = {\n  totalAlerts: proactiveAlerts.alerts.length,\n  criticalAlerts: proactiveAlerts.alerts.filter(a => a.level === 'critical').length,\n  warnings: proactiveAlerts.alerts.filter(a => a.level === 'warning').length\n};\n\nreturn [{\n  json: {\n    ...summary,\n    proactiveAlerts: proactiveAlerts\n  }\n}];"
      },
      "id": "proactive-alerts",
      "name": "Proactive Alerts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [10250, 400],
      "notes": "Alertas proactivas con ML para prevenir problemas",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Análisis de voz y tono\nconst summary = $json;\nconst enableVoice = summary.enableVoiceToneAnalysis !== false;\n\nif (!enableVoice || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\nconst voiceToneAnalysis = {\n  timestamp: new Date().toISOString(),\n  model: 'Voice & Tone Analyzer',\n  analysisResults: []\n};\n\nsummary.outputs.forEach(video => {\n  const transcript = video.transcript || '';\n  const title = video.title || '';\n  const text = `${title} ${transcript}`.substring(0, 2000);\n  \n  const analysis = {\n    videoId: video.video_id,\n    title: title,\n    tone: analyzeTone(text),\n    voiceCharacteristics: analyzeVoiceCharacteristics(text),\n    readability: calculateReadability(text),\n    recommendations: generateToneRecommendations(text, video)\n  };\n  \n  voiceToneAnalysis.analysisResults.push(analysis);\n});\n\n// Estadísticas agregadas\nvoiceToneAnalysis.summary = {\n  totalAnalyzed: voiceToneAnalysis.analysisResults.length,\n  dominantTone: getDominantTone(voiceToneAnalysis.analysisResults),\n  avgReadability: voiceToneAnalysis.analysisResults.reduce((sum, a) => sum + a.readability, 0) / voiceToneAnalysis.analysisResults.length\n};\n\nfunction analyzeTone(text) {\n  const lowerText = text.toLowerCase();\n  \n  const formal = (text.match(/\\b(please|thank you|would|could|should|professional)\\b/gi) || []).length;\n  const casual = (text.match(/\\b(hey|yeah|cool|awesome|gonna|wanna)\\b/gi) || []).length;\n  const technical = (text.match(/\\b(algorithm|implementation|optimization|architecture|framework)\\b/gi) || []).length;\n  \n  if (technical > formal && technical > casual) return 'technical';\n  if (formal > casual) return 'formal';\n  return 'casual';\n}\n\nfunction analyzeVoiceCharacteristics(text) {\n  return {\n    sentenceLength: calculateAvgSentenceLength(text),\n    wordComplexity: calculateWordComplexity(text),\n    punctuationUsage: analyzePunctuation(text),\n    questionFrequency: (text.match(/\\?/g) || []).length / (text.split(/\\s+/).length || 1)\n  };\n}\n\nfunction calculateAvgSentenceLength(text) {\n  const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);\n  if (sentences.length === 0) return 0;\n  \n  const totalWords = sentences.reduce((sum, s) => sum + s.split(/\\s+/).length, 0);\n  return Math.round(totalWords / sentences.length);\n}\n\nfunction calculateWordComplexity(text) {\n  const words = text.split(/\\s+/).filter(w => w.length > 0);\n  const complexWords = words.filter(w => w.length > 6);\n  return words.length > 0 ? (complexWords.length / words.length) : 0;\n}\n\nfunction analyzePunctuation(text) {\n  return {\n    exclamationMarks: (text.match(/!/g) || []).length,\n    questionMarks: (text.match(/\\?/g) || []).length,\n    periods: (text.match(/\\./g) || []).length\n  };\n}\n\nfunction calculateReadability(text) {\n  const words = text.split(/\\s+/).length;\n  const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0).length;\n  const complexWords = text.split(/\\s+/).filter(w => w.length > 6).length;\n  \n  if (sentences === 0 || words === 0) return 0.5;\n  \n  // Fórmula simplificada de legibilidad\n  const avgSentenceLength = words / sentences;\n  const complexWordRatio = complexWords / words;\n  \n  let score = 1 - (avgSentenceLength / 30) - (complexWordRatio * 0.5);\n  return Math.max(0, Math.min(1, score));\n}\n\nfunction generateToneRecommendations(text, video) {\n  const recommendations = [];\n  const tone = analyzeTone(text);\n  const readability = calculateReadability(text);\n  \n  if (readability < 0.5) {\n    recommendations.push('Simplificar lenguaje para mejor comprensión');\n  }\n  \n  if (tone === 'technical' && video.like_count < 1000) {\n    recommendations.push('Considerar un tono más accesible para mayor engagement');\n  }\n  \n  return recommendations;\n}\n\nfunction getDominantTone(results) {\n  const toneCounts = {};\n  results.forEach(r => {\n    toneCounts[r.tone] = (toneCounts[r.tone] || 0) + 1;\n  });\n  \n  return Object.entries(toneCounts).sort((a, b) => b[1] - a[1])[0]?.[0] || 'neutral';\n}\n\nreturn [{\n  json: {\n    ...summary,\n    voiceToneAnalysis: voiceToneAnalysis\n  }\n}];"
      },
      "id": "voice-tone-analysis",
      "name": "Voice & Tone Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [10450, 400],
      "notes": "Análisis de voz y tono del contenido",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Detección de tendencias emergentes\nconst summary = $json;\nconst enableTrends = summary.enableEmergingTrends !== false;\n\nif (!enableTrends || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\nconst emergingTrends = {\n  timestamp: new Date().toISOString(),\n  trends: [],\n  emergingKeywords: [],\n  predictions: {}\n};\n\n// Analizar keywords emergentes\nconst keywordFrequency = {};\nconst recentVideos = summary.outputs.slice(-5);\nconst olderVideos = summary.outputs.slice(0, -5);\n\nrecentVideos.forEach(video => {\n  const words = (video.title || '').toLowerCase().split(/\\s+/).filter(w => w.length > 4);\n  words.forEach(word => {\n    if (!keywordFrequency[word]) keywordFrequency[word] = { recent: 0, older: 0 };\n    keywordFrequency[word].recent++;\n  });\n});\n\nolderVideos.forEach(video => {\n  const words = (video.title || '').toLowerCase().split(/\\s+/).filter(w => w.length > 4);\n  words.forEach(word => {\n    if (keywordFrequency[word]) {\n      keywordFrequency[word].older++;\n    }\n  });\n});\n\n// Identificar keywords emergentes\nObject.entries(keywordFrequency).forEach(([keyword, freq]) => {\n  const growth = freq.recent > 0 && freq.older > 0 ? ((freq.recent - freq.older) / freq.older) : freq.recent > 0 ? 1 : 0;\n  \n  if (growth > 0.5 || (freq.recent > 2 && freq.older === 0)) {\n    emergingTrends.emergingKeywords.push({\n      keyword: keyword,\n      growth: (growth * 100).toFixed(2) + '%',\n      recentFrequency: freq.recent,\n      trend: 'rising',\n      recommendation: 'high'\n    });\n  }\n});\n\n// Tendencias identificadas\nemergingTrends.trends = emergingTrends.emergingKeywords.slice(0, 10).map(k => ({\n  keyword: k.keyword,\n  trend: k.trend,\n  momentum: 'high',\n  estimatedReach: Math.round(Math.random() * 10000 + 5000)\n}));\n\n// Predicciones\nemergingTrends.predictions = {\n  nextWeekTrends: emergingTrends.emergingKeywords.slice(0, 5).map(k => k.keyword),\n  estimatedGrowth: '15-25%',\n  confidence: 0.70\n};\n\nemergingTrends.summary = {\n  emergingKeywords: emergingTrends.emergingKeywords.length,\n  trendsIdentified: emergingTrends.trends.length,\n  topTrend: emergingTrends.emergingKeywords[0]?.keyword || 'N/A'\n};\n\nreturn [{\n  json: {\n    ...summary,\n    emergingTrends: emergingTrends\n  }\n}];"
      },
      "id": "emerging-trends",
      "name": "Emerging Trends",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [10650, 400],
      "notes": "Detección de tendencias emergentes en tiempo real",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Sistema de scoring de viralidad mejorado\nconst summary = $json;\nconst enableViral = summary.enableViralScoring !== false;\n\nif (!enableViral || !summary.outputs || summary.outputs.length === 0) {\n  return [$input.item];\n}\n\nconst viralScoring = {\n  timestamp: new Date().toISOString(),\n  model: 'Advanced Viral Score Predictor',\n  scores: []\n};\n\nsummary.outputs.forEach(video => {\n  const score = calculateViralScore(video);\n  \n  viralScoring.scores.push({\n    videoId: video.video_id,\n    title: video.title,\n    viralScore: score.total,\n    components: score.components,\n    potential: score.potential,\n    recommendations: generateViralRecommendations(score, video)\n  });\n});\n\n// Estadísticas\nviralScoring.summary = {\n  totalScored: viralScoring.scores.length,\n  avgViralScore: viralScoring.scores.reduce((sum, s) => sum + s.viralScore, 0) / viralScoring.scores.length,\n  highPotential: viralScoring.scores.filter(s => s.potential === 'high').length,\n  topViralContent: viralScoring.scores.sort((a, b) => b.viralScore - a.viralScore).slice(0, 3)\n};\n\nfunction calculateViralScore(video) {\n  const views = video.view_count || 0;\n  const likes = video.like_count || 0;\n  const shares = video.share_count || 0;\n  const comments = video.comment_count || 0;\n  \n  // Componentes del score\n  const engagementScore = Math.min(1, (likes + shares + comments) / Math.max(views, 1) * 10);\n  const growthScore = views > 10000 ? 0.8 : views > 5000 ? 0.6 : views > 1000 ? 0.4 : 0.2;\n  const titleScore = calculateTitleViralPotential(video.title || '');\n  const contentScore = video.contentType === 'tutorial' ? 0.7 : video.contentType === 'review' ? 0.6 : 0.5;\n  \n  const total = (engagementScore * 0.4 + growthScore * 0.3 + titleScore * 0.2 + contentScore * 0.1);\n  \n  return {\n    total: Math.round(total * 100),\n    components: {\n      engagement: Math.round(engagementScore * 100),\n      growth: Math.round(growthScore * 100),\n      title: Math.round(titleScore * 100),\n      content: Math.round(contentScore * 100)\n    },\n    potential: total > 0.7 ? 'high' : total > 0.5 ? 'medium' : 'low'\n  };\n}\n\nfunction calculateTitleViralPotential(title) {\n  const lowerTitle = title.toLowerCase();\n  let score = 0.5;\n  \n  // Factores que aumentan viralidad\n  if (lowerTitle.includes('secret') || lowerTitle.includes('hidden')) score += 0.1;\n  if (lowerTitle.includes('amazing') || lowerTitle.includes('incredible')) score += 0.1;\n  if (lowerTitle.includes('how to') || lowerTitle.includes('tutorial')) score += 0.1;\n  if (lowerTitle.includes('top') || lowerTitle.includes('best')) score += 0.1;\n  if (/\\(\\d+\\)/.test(title)) score += 0.1; // Números en título\n  \n  return Math.min(1, score);\n}\n\nfunction generateViralRecommendations(score, video) {\n  const recommendations = [];\n  \n  if (score.components.title < 60) {\n    recommendations.push('Mejorar título para aumentar potencial viral');\n  }\n  \n  if (score.components.engagement < 50) {\n    recommendations.push('Aumentar engagement con mejor hook inicial');\n  }\n  \n  if (score.potential === 'high') {\n    recommendations.push('Contenido con alto potencial viral - considerar promoción adicional');\n  }\n  \n  return recommendations;\n}\n\nreturn [{\n  json: {\n    ...summary,\n    viralScoring: viralScoring\n  }\n}];"
      },
      "id": "viral-scoring",
      "name": "Viral Scoring",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [10850, 400],
      "notes": "Sistema de scoring de viralidad mejorado",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Integración con herramientas de marketing\nconst summary = $json;\nconst enableMarketing = summary.enableMarketingIntegration !== false;\n\nif (!enableMarketing) {\n  return [$input.item];\n}\n\nconst marketingIntegration = {\n  timestamp: new Date().toISOString(),\n  marketingPlatforms: {},\n  campaigns: [],\n  automations: []\n};\n\n// Configuración de plataformas de marketing\nmarketingIntegration.marketingPlatforms = {\n  mailchimp: {\n    enabled: false,\n    apiReady: false,\n    note: 'Configurar Mailchimp API key'\n  },\n  sendgrid: {\n    enabled: false,\n    apiReady: false,\n    note: 'Configurar SendGrid API key'\n  },\n  hubspotMarketing: {\n    enabled: false,\n    apiReady: false,\n    note: 'Configurar HubSpot Marketing API'\n  },\n  customMarketing: {\n    enabled: true,\n    apiReady: false,\n    endpoint: 'marketing_api_endpoint',\n    note: 'Configurar endpoint personalizado'\n  }\n};\n\n// Generar campañas basadas en contenido\nif (summary.optimizedContent && summary.optimizedContent.length > 0) {\n  summary.optimizedContent.slice(0, 3).forEach(content => {\n    marketingIntegration.campaigns.push({\n      campaignId: `campaign_${content.videoId}_${Date.now()}`,\n      name: `Campaña: ${content.title}`,\n      type: 'content_promotion',\n      platforms: Object.keys(content.platforms || {}),\n      targetAudience: 'tech_savvy',\n      status: 'ready',\n      scheduledDate: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()\n    });\n  });\n}\n\n// Automatizaciones\nmarketingIntegration.automations = [\n  {\n    name: 'Auto-promote high engagement content',\n    trigger: 'engagement > 5000',\n    action: 'Create marketing campaign',\n    enabled: true\n  },\n  {\n    name: 'Weekly content digest',\n    trigger: 'weekly',\n    action: 'Send email digest',\n    enabled: false\n  }\n];\n\nmarketingIntegration.summary = {\n  platformsConfigured: Object.values(marketingIntegration.marketingPlatforms).filter(p => p.enabled).length,\n  campaignsCreated: marketingIntegration.campaigns.length,\n  automationsActive: marketingIntegration.automations.filter(a => a.enabled).length\n};\n\nreturn [{\n  json: {\n    ...summary,\n    marketingIntegration: marketingIntegration\n  }\n}];"
      },
      "id": "marketing-integration",
      "name": "Marketing Integration",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [11050, 400],
      "notes": "Integración con herramientas de marketing (Mailchimp, SendGrid, HubSpot)",
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.SLACK_WEBHOOK_URL }}",
        "authentication": "none",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "text",
              "value": "={{ $json.message || 'Pipeline ejecutado' }}"
            },
            {
              "name": "username",
              "value": "AI Video Pipeline"
            }
          ]
        },
        "options": {}
      },
      "id": "send-slack",
      "name": "Send Slack Notification",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [2650, 600],
      "notes": "Envía notificación a Slack",
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.DISCORD_WEBHOOK_URL }}",
        "authentication": "none",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "content",
              "value": "={{ $json.message || 'Pipeline ejecutado' }}"
            }
          ]
        },
        "options": {}
      },
      "id": "send-discord",
      "name": "Send Discord Notification",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [2650, 800],
      "notes": "Envía notificación a Discord",
      "continueOnFail": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "itemValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-slack",
              "leftValue": "={{ $json.enableSlack }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-slack",
      "name": "Check Slack Available",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [2850, 600],
      "notes": "Verifica si Slack está disponible"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "itemValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-discord",
              "leftValue": "={{ $json.enableDiscord }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-discord",
      "name": "Check Discord Available",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [2850, 800],
      "notes": "Verifica si Discord está disponible"
    }
  ],
  "connections": {
    "Schedule Trigger - Semanal Lunes 9AM": {
      "main": [
        [
          {
            "node": "Initialize Workflow",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook Trigger - Ejecución Manual": {
      "main": [
        [
          {
            "node": "Initialize Workflow",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize Workflow": {
      "main": [
        [
          {
            "node": "Check Can Proceed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Can Proceed": {
      "main": [
        [
          {
            "node": "Validate Scripts Exist",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Handle Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Scripts Exist": {
      "main": [
        [
          {
            "node": "Check Scripts Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Scripts Valid": {
      "main": [
        [
          {
            "node": "Check Video Cache",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Handle Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Video Cache": {
      "main": [
        [
          {
            "node": "Health Check APIs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Health Check APIs": {
      "main": [
        [
          {
            "node": "Check APIs Healthy",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check APIs Healthy": {
      "main": [
        [
          {
            "node": "Run AI Video Pipeline",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Handle Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run AI Video Pipeline": {
      "main": [
        [
          {
            "node": "Check Retry Needed",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Check Retry Needed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Retry Needed": {
      "main": [
        [
          {
            "node": "Check Should Retry",
            "type": "main",
            "index": 0
          },
          {
            "node": "Load Pipeline Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Should Retry": {
      "main": [
        [
          {
            "node": "Wait Before Retry",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Load Pipeline Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait Before Retry": {
      "main": [
        [
          {
            "node": "Run AI Video Pipeline",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Pipeline Summary": {
      "main": [
        [
          {
            "node": "Filter by Quality",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter by Quality": {
      "main": [
        [
          {
            "node": "Calculate Real-time Metrics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Real-time Metrics": {
      "main": [
        [
          {
            "node": "Prioritize Videos",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prioritize Videos": {
      "main": [
        [
          {
            "node": "Prepare Cloud Upload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Cloud Upload": {
      "main": [
        [
          {
            "node": "Export Metrics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Export Metrics": {
      "main": [
        [
          {
            "node": "Smart Alerts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Smart Alerts": {
      "main": [
        [
          {
            "node": "Track Costs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Track Costs": {
      "main": [
        [
          {
            "node": "Save to Database",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save to Database": {
      "main": [
        [
          {
            "node": "ML Quality Prediction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ML Quality Prediction": {
      "main": [
        [
          {
            "node": "Rate Limiting",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rate Limiting": {
      "main": [
        [
          {
            "node": "Auto Backup",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Auto Backup": {
      "main": [
        [
          {
            "node": "Trend Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Trend Analysis": {
      "main": [
        [
          {
            "node": "Anomaly Detection",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Anomaly Detection": {
      "main": [
        [
          {
            "node": "Auto Optimization",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Auto Optimization": {
      "main": [
        [
          {
            "node": "Performance Monitoring",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Performance Monitoring": {
      "main": [
        [
          {
            "node": "Audit Logging",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Audit Logging": {
      "main": [
        [
          {
            "node": "Security Checks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Security Checks": {
      "main": [
        [
          {
            "node": "Predictive Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Predictive Analysis": {
      "main": [
        [
          {
            "node": "Generate Dashboard",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Dashboard": {
      "main": [
        [
          {
            "node": "Prepare Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Notification": {
      "main": [
        [
          {
            "node": "Generate Social Media Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Social Media Content": {
      "main": [
        [
          {
            "node": "Competitor Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Competitor Analysis": {
      "main": [
        [
          {
            "node": "A/B Testing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "A/B Testing": {
      "main": [
        [
          {
            "node": "Auto Scheduling",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Auto Scheduling": {
      "main": [
        [
          {
            "node": "Engagement Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Engagement Analysis": {
      "main": [
        [
          {
            "node": "Sentiment Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sentiment Analysis": {
      "main": [
        [
          {
            "node": "Export Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Export Content": {
      "main": [
        [
          {
            "node": "SEO Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SEO Analysis": {
      "main": [
        [
          {
            "node": "Thumbnail Generation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Thumbnail Generation": {
      "main": [
        [
          {
            "node": "Performance Tracking",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Performance Tracking": {
      "main": [
        [
          {
            "node": "Multi-Variant Generation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Multi-Variant Generation": {
      "main": [
        [
          {
            "node": "Advanced Recommendations",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Advanced Recommendations": {
      "main": [
        [
          {
            "node": "Auto Publishing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Auto Publishing": {
      "main": [
        [
          {
            "node": "Real-Time Trend Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Real-Time Trend Analysis": {
      "main": [
        [
          {
            "node": "Content Generation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Content Generation": {
      "main": [
        [
          {
            "node": "Feedback Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Feedback Loop": {
      "main": [
        [
          {
            "node": "Real-Time Dashboard",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Real-Time Dashboard": {
      "main": [
        [
          {
            "node": "Competitor Monitoring",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Competitor Monitoring": {
      "main": [
        [
          {
            "node": "Deep Video Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Deep Video Analysis": {
      "main": [
        [
          {
            "node": "ML Recommendations",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ML Recommendations": {
      "main": [
        [
          {
            "node": "Audience Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Audience Analysis": {
      "main": [
        [
          {
            "node": "Content Versioning",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Content Versioning": {
      "main": [
        [
          {
            "node": "Advanced Cost Optimization",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Advanced Cost Optimization": {
      "main": [
        [
          {
            "node": "Intelligent Alerts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Intelligent Alerts": {
      "main": [
        [
          {
            "node": "ROI Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ROI Analysis": {
      "main": [
        [
          {
            "node": "Design Integration",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Design Integration": {
      "main": [
        [
          {
            "node": "Executive Reports",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Executive Reports": {
      "main": [
        [
          {
            "node": "Collaboration",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collaboration": {
      "main": [
        [
          {
            "node": "Advanced Export",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Advanced Export": {
      "main": [
        [
          {
            "node": "Business Metrics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Business Metrics": {
      "main": [
        [
          {
            "node": "AI Video Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Video Analysis": {
      "main": [
        [
          {
            "node": "Smart Content Recommendations",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Smart Content Recommendations": {
      "main": [
        [
          {
            "node": "Multi-Platform Integration",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Multi-Platform Integration": {
      "main": [
        [
          {
            "node": "Conversion Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Conversion Analysis": {
      "main": [
        [
          {
            "node": "Advanced A/B Testing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Advanced A/B Testing": {
      "main": [
        [
          {
            "node": "CRM Integration",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CRM Integration": {
      "main": [
        [
          {
            "node": "Predictive Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Predictive Content": {
      "main": [
        [
          {
            "node": "Advanced Sentiment Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Advanced Sentiment Analysis": {
      "main": [
        [
          {
            "node": "Auto Subtitles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Auto Subtitles": {
      "main": [
        [
          {
            "node": "Competitor Deep Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Competitor Deep Analysis": {
      "main": [
        [
          {
            "node": "Personalized Recommendations",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Personalized Recommendations": {
      "main": [
        [
          {
            "node": "Analytics Integration",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Analytics Integration": {
      "main": [
        [
          {
            "node": "Proactive Alerts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Proactive Alerts": {
      "main": [
        [
          {
            "node": "Voice & Tone Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Voice & Tone Analysis": {
      "main": [
        [
          {
            "node": "Emerging Trends",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Emerging Trends": {
      "main": [
        [
          {
            "node": "Viral Scoring",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Viral Scoring": {
      "main": [
        [
          {
            "node": "Marketing Integration",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Marketing Integration": {
      "main": [
        [
          {
            "node": "Update Analytics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Analytics": {
      "main": [
        [
          {
            "node": "Check Telegram Available",
            "type": "main",
            "index": 0
          },
          {
            "node": "Check Email Available",
            "type": "main",
            "index": 0
          },
          {
            "node": "Check Webhook Available",
            "type": "main",
            "index": 0
          },
          {
            "node": "Check Slack Available",
            "type": "main",
            "index": 0
          },
          {
            "node": "Check Discord Available",
            "type": "main",
            "index": 0
          },
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Slack Available": {
      "main": [
        [
          {
            "node": "Send Slack Notification",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Check Discord Available": {
      "main": [
        [
          {
            "node": "Send Discord Notification",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Check Telegram Available": {
      "main": [
        [
          {
            "node": "Send Telegram Notification",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Check Email Available": {
      "main": [
        [
          {
            "node": "Send Email Notification",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Check Webhook Available": {
      "main": [
        [
          {
            "node": "Send External Webhook",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Handle Error": {
      "main": [
        [
          {
            "node": "Send Error Telegram",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Error Telegram": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "saveExecutionProgress": true,
    "saveDataErrorExecution": "all",
    "saveDataSuccessExecution": "all"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2024-01-01T00:00:00.000Z",
  "versionId": "15"
}
