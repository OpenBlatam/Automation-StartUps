{
  "description": "Nodos enterprise para dashboard, reportes, API y automatización avanzada",
  "nodes": [
    {
      "id": "generate-dashboard-data",
      "name": "Generate Dashboard Data",
      "type": "n8n-nodes-base.code",
      "parameters": {
        "jsCode": "// Generar datos para dashboard\nconst engagementHistory = $workflow.staticData.engagementHistory || [];\nconst predictions = $workflow.staticData.predictions || {};\nconst trends = $workflow.staticData.emergingTrends || {};\n\nconst dashboardData = {\n  overview: {\n    totalVideos: engagementHistory.length,\n    totalEngagement: engagementHistory.reduce((sum, h) => \n      sum + (h.overallMetrics?.totalEngagement || 0), 0\n    ),\n    avgEngagementRate: engagementHistory.length > 0 ?\n      engagementHistory.reduce((sum, h) => \n        sum + (h.overallMetrics?.avgEngagementRate || 0), 0\n      ) / engagementHistory.length : 0,\n    viralVideos: engagementHistory.filter(h => \n      h.overallMetrics?.viralOn && h.overallMetrics.viralOn.length > 0\n    ).length,\n    successRate: engagementHistory.length > 0 ?\n      (engagementHistory.filter(h => \n        (h.overallMetrics?.avgEngagementRate || 0) > 5.0\n      ).length / engagementHistory.length) * 100 : 0,\n    lastUpdated: new Date().toISOString()\n  },\n  \n  charts: {\n    engagementOverTime: generateTimeSeries(engagementHistory),\n    platformComparison: generatePlatformComparison(engagementHistory),\n    hashtagPerformance: generateHashtagChart(engagementHistory),\n    hourPerformance: generateHourChart(engagementHistory)\n  },\n  \n  insights: {\n    topPerforming: getTopPerforming(engagementHistory, 10),\n    underperforming: getUnderperforming(engagementHistory, 10),\n    recommendations: generateRecommendations(engagementHistory),\n    opportunities: identifyOpportunities(engagementHistory, trends)\n  },\n  \n  predictions: predictions,\n  alerts: generateIntelligentAlerts(engagementHistory),\n  trends: trends\n};\n\nfunction generateTimeSeries(history) {\n  const daily = {};\n  history.forEach(h => {\n    const date = new Date(h.publishedAt).toISOString().split('T')[0];\n    if (!daily[date]) daily[date] = { date, engagement: 0, count: 0 };\n    daily[date].engagement += h.overallMetrics?.totalEngagement || 0;\n    daily[date].count++;\n  });\n  return Object.values(daily).map(d => ({\n    date: d.date,\n    avgEngagement: d.engagement / d.count\n  }));\n}\n\nfunction generatePlatformComparison(history) {\n  const platforms = {};\n  history.forEach(h => {\n    Object.keys(h.platformMetrics || {}).forEach(platform => {\n      if (!platforms[platform]) {\n        platforms[platform] = { count: 0, totalRate: 0 };\n      }\n      platforms[platform].count++;\n      platforms[platform].totalRate += \n        h.platformMetrics[platform]?.engagementRate || 0;\n    });\n  });\n  return Object.entries(platforms).map(([platform, data]) => ({\n    platform: platform,\n    avgEngagementRate: data.totalRate / data.count,\n    videoCount: data.count\n  }));\n}\n\nfunction generateHashtagChart(history) {\n  const hashtags = {};\n  history.forEach(h => {\n    const tags = typeof h.hashtags === 'string' ?\n      h.hashtags.split(/\\s+/) : (Array.isArray(h.hashtags) ? h.hashtags : []);\n    tags.forEach(tag => {\n      const cleanTag = tag.toLowerCase().trim();\n      if (!hashtags[cleanTag]) {\n        hashtags[cleanTag] = { count: 0, totalRate: 0 };\n      }\n      hashtags[cleanTag].count++;\n      hashtags[cleanTag].totalRate += h.overallMetrics?.avgEngagementRate || 0;\n    });\n  });\n  return Object.entries(hashtags)\n    .map(([tag, data]) => ({\n      tag: tag,\n      avgEngagementRate: data.totalRate / data.count,\n      usageCount: data.count\n    }))\n    .sort((a, b) => b.avgEngagementRate - a.avgEngagementRate)\n    .slice(0, 20);\n}\n\nfunction generateHourChart(history) {\n  const hours = {};\n  history.forEach(h => {\n    const hour = new Date(h.publishedAt).getHours();\n    if (!hours[hour]) hours[hour] = { count: 0, totalRate: 0 };\n    hours[hour].count++;\n    hours[hour].totalRate += h.overallMetrics?.avgEngagementRate || 0;\n  });\n  return Object.entries(hours).map(([hour, data]) => ({\n    hour: parseInt(hour),\n    avgEngagementRate: data.totalRate / data.count,\n    videoCount: data.count\n  })).sort((a, b) => a.hour - b.hour);\n}\n\nfunction getTopPerforming(history, limit) {\n  return history\n    .sort((a, b) => \n      (b.overallMetrics?.avgEngagementRate || 0) - \n      (a.overallMetrics?.avgEngagementRate || 0)\n    )\n    .slice(0, limit)\n    .map(h => ({\n      videoId: h.videoId,\n      title: h.title,\n      engagementRate: h.overallMetrics?.avgEngagementRate || 0,\n      totalEngagement: h.overallMetrics?.totalEngagement || 0\n    }));\n}\n\nfunction getUnderperforming(history, limit) {\n  return history\n    .sort((a, b) => \n      (a.overallMetrics?.avgEngagementRate || 0) - \n      (b.overallMetrics?.avgEngagementRate || 0)\n    )\n    .slice(0, limit)\n    .map(h => ({\n      videoId: h.videoId,\n      title: h.title,\n      engagementRate: h.overallMetrics?.avgEngagementRate || 0,\n      totalEngagement: h.overallMetrics?.totalEngagement || 0\n    }));\n}\n\nfunction generateRecommendations(history) {\n  const recommendations = [];\n  \n  if (history.length < 10) {\n    recommendations.push({\n      type: 'data',\n      priority: 'low',\n      message: 'Necesitas más datos para recomendaciones precisas'\n    });\n    return recommendations;\n  }\n  \n  const topHashtags = $workflow.staticData.topHashtags || [];\n  if (topHashtags.length > 0) {\n    recommendations.push({\n      type: 'hashtags',\n      priority: 'high',\n      message: `Usa estos hashtags probados: ${topHashtags.slice(0, 5).map(h => h.tag).join(', ')}`\n    });\n  }\n  \n  const bestHours = $workflow.staticData.bestHours || [];\n  if (bestHours.length > 0) {\n    recommendations.push({\n      type: 'timing',\n      priority: 'medium',\n      message: `Mejores horarios: ${bestHours.slice(0, 3).map(h => h.hour + ':00').join(', ')}`\n    });\n  }\n  \n  return recommendations;\n}\n\nfunction identifyOpportunities(history, trends) {\n  const opportunities = [];\n  \n  if (trends.hotTrends && trends.hotTrends.length > 0) {\n    opportunities.push({\n      type: 'trending',\n      priority: 'high',\n      message: `${trends.hotTrends.length} tendencias calientes detectadas`,\n      trends: trends.hotTrends.slice(0, 5)\n    });\n  }\n  \n  return opportunities;\n}\n\nreturn {\n  json: {\n    ...$input.item.json,\n    dashboardData: dashboardData\n  }\n};"
      },
      "position": [6650, 400],
      "notes": "Genera datos para dashboard web"
    },
    {
      "id": "generate-auto-report",
      "name": "Generate Auto Report",
      "type": "n8n-nodes-base.code",
      "parameters": {
        "jsCode": "// Generar reporte automático\nconst reportType = $env.REPORT_TYPE || 'weekly'; // 'daily', 'weekly', 'monthly'\nconst engagementHistory = $workflow.staticData.engagementHistory || [];\n\nconst now = new Date();\nlet periodStart;\n\nswitch(reportType) {\n  case 'daily':\n    periodStart = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n    break;\n  case 'weekly':\n    periodStart = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n    break;\n  case 'monthly':\n    periodStart = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n    break;\n  default:\n    periodStart = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n}\n\nconst periodHistory = engagementHistory.filter(h => {\n  const publishDate = new Date(h.publishedAt);\n  return publishDate >= periodStart && publishDate <= now;\n});\n\nconst report = {\n  type: reportType,\n  period: {\n    start: periodStart.toISOString(),\n    end: now.toISOString()\n  },\n  generatedAt: now.toISOString(),\n  \n  executiveSummary: {\n    totalVideos: periodHistory.length,\n    totalEngagement: periodHistory.reduce((sum, h) => \n      sum + (h.overallMetrics?.totalEngagement || 0), 0\n    ),\n    avgEngagementRate: periodHistory.length > 0 ?\n      periodHistory.reduce((sum, h) => \n        sum + (h.overallMetrics?.avgEngagementRate || 0), 0\n      ) / periodHistory.length : 0,\n    viralVideos: periodHistory.filter(h => \n      h.overallMetrics?.viralOn && h.overallMetrics.viralOn.length > 0\n    ).length,\n    bestPerformingVideo: periodHistory.length > 0 ?\n      periodHistory.sort((a, b) => \n        (b.overallMetrics?.avgEngagementRate || 0) - \n        (a.overallMetrics?.avgEngagementRate || 0)\n      )[0] : null\n  },\n  \n  performanceMetrics: {\n    byPlatform: calculatePlatformMetrics(periodHistory),\n    byTimeOfDay: calculateTimeMetrics(periodHistory),\n    trends: calculateTrends(periodHistory)\n  },\n  \n  topPerformers: {\n    videos: periodHistory\n      .sort((a, b) => \n        (b.overallMetrics?.avgEngagementRate || 0) - \n        (a.overallMetrics?.avgEngagementRate || 0)\n      )\n      .slice(0, 10)\n      .map(h => ({\n        videoId: h.videoId,\n        title: h.title,\n        engagementRate: h.overallMetrics?.avgEngagementRate || 0\n      })),\n    hashtags: getTopHashtags(periodHistory, 20),\n    hours: getTopHours(periodHistory, 5)\n  },\n  \n  recommendations: generateReportRecommendations(periodHistory)\n};\n\nfunction calculatePlatformMetrics(history) {\n  const platforms = {};\n  history.forEach(h => {\n    Object.keys(h.platformMetrics || {}).forEach(platform => {\n      if (!platforms[platform]) {\n        platforms[platform] = { count: 0, totalRate: 0 };\n      }\n      platforms[platform].count++;\n      platforms[platform].totalRate += \n        h.platformMetrics[platform]?.engagementRate || 0;\n    });\n  });\n  return Object.entries(platforms).map(([platform, data]) => ({\n    platform: platform,\n    avgEngagementRate: data.totalRate / data.count,\n    videoCount: data.count\n  }));\n}\n\nfunction calculateTimeMetrics(history) {\n  const hours = {};\n  history.forEach(h => {\n    const hour = new Date(h.publishedAt).getHours();\n    if (!hours[hour]) hours[hour] = { count: 0, totalRate: 0 };\n    hours[hour].count++;\n    hours[hour].totalRate += h.overallMetrics?.avgEngagementRate || 0;\n  });\n  return Object.entries(hours).map(([hour, data]) => ({\n    hour: parseInt(hour),\n    avgEngagementRate: data.totalRate / data.count\n  }));\n}\n\nfunction calculateTrends(history) {\n  if (history.length < 2) return { trend: 'insufficient_data' };\n  \n  const sorted = history.sort((a, b) => \n    new Date(a.publishedAt) - new Date(b.publishedAt)\n  );\n  \n  const firstHalf = sorted.slice(0, Math.floor(sorted.length / 2));\n  const secondHalf = sorted.slice(Math.floor(sorted.length / 2));\n  \n  const firstAvg = firstHalf.reduce((sum, h) => \n    sum + (h.overallMetrics?.avgEngagementRate || 0), 0\n  ) / firstHalf.length;\n  \n  const secondAvg = secondHalf.reduce((sum, h) => \n    sum + (h.overallMetrics?.avgEngagementRate || 0), 0\n  ) / secondHalf.length;\n  \n  const change = ((secondAvg - firstAvg) / firstAvg) * 100;\n  \n  return {\n    trend: change > 5 ? 'improving' : change < -5 ? 'declining' : 'stable',\n    changePercent: change.toFixed(2)\n  };\n}\n\nfunction getTopHashtags(history, limit) {\n  const hashtags = {};\n  history.forEach(h => {\n    const tags = typeof h.hashtags === 'string' ?\n      h.hashtags.split(/\\s+/) : (Array.isArray(h.hashtags) ? h.hashtags : []);\n    tags.forEach(tag => {\n      const cleanTag = tag.toLowerCase().trim();\n      if (!hashtags[cleanTag]) {\n        hashtags[cleanTag] = { count: 0, totalRate: 0 };\n      }\n      hashtags[cleanTag].count++;\n      hashtags[cleanTag].totalRate += h.overallMetrics?.avgEngagementRate || 0;\n    });\n  });\n  return Object.entries(hashtags)\n    .map(([tag, data]) => ({\n      tag: tag,\n      avgEngagementRate: data.totalRate / data.count,\n      usageCount: data.count\n    }))\n    .sort((a, b) => b.avgEngagementRate - a.avgEngagementRate)\n    .slice(0, limit);\n}\n\nfunction getTopHours(history, limit) {\n  const hours = {};\n  history.forEach(h => {\n    const hour = new Date(h.publishedAt).getHours();\n    if (!hours[hour]) hours[hour] = { count: 0, totalRate: 0 };\n    hours[hour].count++;\n    hours[hour].totalRate += h.overallMetrics?.avgEngagementRate || 0;\n  });\n  return Object.entries(hours)\n    .map(([hour, data]) => ({\n      hour: parseInt(hour),\n      avgEngagementRate: data.totalRate / data.count\n    }))\n    .sort((a, b) => b.avgEngagementRate - a.avgEngagementRate)\n    .slice(0, limit);\n}\n\nfunction generateReportRecommendations(history) {\n  const recommendations = [];\n  \n  if (history.length === 0) {\n    return [{ type: 'data', message: 'No hay datos para este período' }];\n  }\n  \n  const avgEngagement = history.reduce((sum, h) => \n    sum + (h.overallMetrics?.avgEngagementRate || 0), 0\n  ) / history.length;\n  \n  if (avgEngagement < 5.0) {\n    recommendations.push({\n      type: 'performance',\n      priority: 'high',\n      message: 'Engagement promedio bajo. Considera mejorar hashtags y timing.'\n    });\n  }\n  \n  const topHashtags = getTopHashtags(history, 5);\n  if (topHashtags.length > 0) {\n    recommendations.push({\n      type: 'hashtags',\n      priority: 'medium',\n      message: `Hashtags más exitosos: ${topHashtags.map(h => h.tag).join(', ')}`\n    });\n  }\n  \n  return recommendations;\n}\n\n// Guardar reporte\nconst reports = $workflow.staticData.reports || [];\nreports.push(report);\nif (reports.length > 100) reports.shift();\n$workflow.staticData.reports = reports;\n\nreturn {\n  json: {\n    ...$input.item.json,\n    report: report,\n    reportSaved: true\n  }\n};"
      },
      "position": [6850, 400],
      "notes": "Genera reportes automáticos"
    }
  ],
  "integration_points": {
    "generate_dashboard_data": "Agregar en workflow de tracking, al final",
    "generate_auto_report": "Agregar como trigger separado (diario/semanal/mensual)"
  },
  "usage": {
    "description": "Nodos enterprise para dashboard, reportes y analytics avanzado",
    "setup": "1. Agregar nodos según integration_points\n2. Configurar REPORT_TYPE\n3. Acceder a datos via API o dashboard"
  }
}



