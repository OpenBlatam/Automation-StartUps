{
  "name": "Sora Videos Auto Download Edit Upload - ULTIMATE v3.0",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 6
            }
          ]
        }
      },
      "id": "schedule-trigger",
      "name": "Schedule Trigger - Every 6 Hours",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.1,
      "position": [250, 300],
      "notes": "Ejecuta cada 6 horas para buscar nuevos videos de Sora"
    },
    {
      "parameters": {
        "jsCode": "// Initialize Workflow with Enhanced Tracking\nconst workflowStats = $workflow.staticData.workflowStats || {\n  totalRuns: 0,\n  successfulRuns: 0,\n  failedRuns: 0,\n  videosProcessed: 0,\n  videosUploaded: 0,\n  totalEngagement: 0,\n  lastRun: null,\n  errors: [],\n  performance: {\n    avgProcessingTime: 0,\n    avgUploadTime: 0\n  }\n};\n\nworkflowStats.totalRuns += 1;\nworkflowStats.lastRun = new Date().toISOString();\n$workflow.staticData.workflowStats = workflowStats;\n\n// Clean old processed videos\nconst processedVideos = $workflow.staticData.processedVideos || [];\nconst thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);\nconst cleanedProcessed = processedVideos.filter(v => v.timestamp > thirtyDaysAgo);\n$workflow.staticData.processedVideos = cleanedProcessed.slice(-1000);\n\n// Check feature flags\nconst features = {\n  visionAnalysis: $env.ENABLE_VISION_ANALYSIS !== 'false',\n  thumbnailGeneration: $env.ENABLE_THUMBNAIL_GEN !== 'false',\n  smartScheduling: $env.ENABLE_SMART_SCHEDULING !== 'false',\n  abTesting: $env.ENABLE_AB_TESTING === 'true',\n  webhooks: !!$env.WEBHOOK_URL\n};\n\nreturn {\n  json: {\n    workflowStats: workflowStats,\n    processedVideosCount: cleanedProcessed.length,\n    timestamp: new Date().toISOString(),\n    runId: `run_${Date.now()}`,\n    features: features\n  }\n};"
      },
      "id": "initialize-workflow",
      "name": "Initialize Workflow",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300],
      "notes": "Inicializa workflow con tracking mejorado y feature flags"
    },
    {
      "parameters": {
        "jsCode": "// Prepare Search Sources with Enhanced Error Handling\nconst searchSources = [\n  {\n    name: 'reddit_sora',\n    url: 'https://www.reddit.com/r/soraai/top.json?limit=20&t=day',\n    type: 'reddit',\n    enabled: true,\n    priority: 1\n  },\n  {\n    name: 'youtube_sora',\n    url: `https://www.googleapis.com/youtube/v3/search?part=snippet&q=sora+ai+video+most+viewed&order=viewCount&maxResults=20&type=video&key=${$env.YOUTUBE_API_KEY || ''}`,\n    type: 'youtube',\n    enabled: !!$env.YOUTUBE_API_KEY,\n    priority: 2\n  },\n  {\n    name: 'twitter_sora',\n    url: 'https://api.twitter.com/2/tweets/search/recent?query=sora%20video%20has:media&max_results=20&tweet.fields=public_metrics,created_at',\n    type: 'twitter',\n    enabled: true,\n    priority: 3\n  }\n].filter(source => source.enabled);\n\nreturn {\n  json: {\n    ...$input.item.json,\n    searchSources: searchSources,\n    searchCount: searchSources.length\n  }\n};"
      },
      "id": "prepare-search",
      "name": "Prepare Search Sources",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [650, 300],
      "notes": "Prepara fuentes de b√∫squeda"
    },
    {
      "parameters": {
        "url": "=https://www.reddit.com/r/soraai/top.json?limit=20&t=day",
        "authentication": "none",
        "options": {
          "timeout": 30000,
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "search-reddit",
      "name": "Search Reddit Sora",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [850, 200],
      "continueOnFail": true
    },
    {
      "parameters": {
        "url": "=https://www.googleapis.com/youtube/v3/search?part=snippet&q=sora+ai+video+most+viewed&order=viewCount&maxResults=20&type=video&key={{ $env.YOUTUBE_API_KEY }}",
        "authentication": "none",
        "options": {
          "timeout": 30000,
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "search-youtube",
      "name": "Search YouTube Sora",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [850, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "url": "=https://api.twitter.com/2/tweets/search/recent?query=sora%20video%20has:media&max_results=20&tweet.fields=public_metrics,created_at",
        "authentication": "oAuth2",
        "options": {
          "timeout": 30000,
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "search-twitter",
      "name": "Search Twitter Sora",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [850, 400],
      "continueOnFail": true,
      "credentials": {
        "oAuth2Api": {
          "id": "twitter-oauth",
          "name": "Twitter OAuth2 API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Process Search Results with Enhanced Filtering\nconst crypto = require('crypto');\nconst processedVideos = $workflow.staticData.processedVideos || [];\nconst processedUrls = new Set(processedVideos.map(v => v.url || v.videoId));\n\nlet allVideos = [];\nlet errors = [];\n\n// Process Reddit\nif ($input.item.json.data?.children) {\n  try {\n    $input.item.json.data.children.forEach(post => {\n      const postData = post.data;\n      if (postData.url && (postData.url.includes('youtube.com') || postData.url.includes('youtu.be') || postData.url.includes('v.redd.it'))) {\n        const videoId = crypto.createHash('md5').update(postData.url).digest('hex');\n        if (!processedUrls.has(postData.url) && !processedUrls.has(videoId)) {\n          allVideos.push({\n            source: 'reddit',\n            url: postData.url,\n            title: postData.title,\n            views: postData.score || 0,\n            videoId: videoId,\n            thumbnail: postData.thumbnail || null,\n            author: postData.author,\n            timestamp: new Date(postData.created_utc * 1000).toISOString()\n          });\n        }\n      }\n    });\n  } catch (e) {\n    errors.push({ source: 'reddit', error: e.message });\n  }\n}\n\n// Process YouTube\nif ($input.item.json.items) {\n  try {\n    $input.item.json.items.forEach(item => {\n      const videoId = item.id.videoId;\n      const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;\n      if (!processedUrls.has(videoUrl) && !processedUrls.has(videoId)) {\n        allVideos.push({\n          source: 'youtube',\n          url: videoUrl,\n          videoId: videoId,\n          title: item.snippet.title,\n          views: parseInt(item.statistics?.viewCount || 0),\n          thumbnail: item.snippet.thumbnails?.high?.url || null,\n          author: item.snippet.channelTitle,\n          description: item.snippet.description,\n          timestamp: item.snippet.publishedAt\n        });\n      }\n    });\n  } catch (e) {\n    errors.push({ source: 'youtube', error: e.message });\n  }\n}\n\n// Process Twitter\nif ($input.item.json.data) {\n  try {\n    const tweets = Array.isArray($input.item.json.data) ? $input.item.json.data : [$input.item.json.data];\n    tweets.forEach(tweet => {\n      if (tweet.attachments?.media_keys) {\n        const views = tweet.public_metrics?.view_count || tweet.public_metrics?.like_count || 0;\n        const tweetId = tweet.id;\n        const tweetUrl = `https://twitter.com/i/status/${tweetId}`;\n        if (!processedUrls.has(tweetUrl) && !processedUrls.has(tweetId)) {\n          allVideos.push({\n            source: 'twitter',\n            url: tweetUrl,\n            videoId: tweetId,\n            title: tweet.text?.substring(0, 100) || 'Sora Video',\n            views: views,\n            thumbnail: null,\n            author: tweet.author_id,\n            timestamp: tweet.created_at\n          });\n        }\n      }\n    });\n  } catch (e) {\n    errors.push({ source: 'twitter', error: e.message });\n  }\n}\n\nallVideos.sort((a, b) => b.views - a.views);\nconst topVideos = allVideos.slice(0, 5);\n\nif (errors.length > 0) {\n  const errorLog = $workflow.staticData.errorLog || [];\n  errorLog.push(...errors.map(e => ({ ...e, timestamp: new Date().toISOString() })));\n  if (errorLog.length > 100) errorLog.shift();\n  $workflow.staticData.errorLog = errorLog;\n}\n\nreturn topVideos.map(video => ({\n  json: {\n    ...video,\n    searchErrors: errors,\n    foundAt: new Date().toISOString()\n  }\n}));"
      },
      "id": "extract-videos",
      "name": "Extract Video URLs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Video Filtering with Quality Scoring\nconst video = $json;\nconst processedVideos = $workflow.staticData.processedVideos || [];\n\nif (processedVideos.some(pv => pv.url === video.url || pv.videoId === video.videoId)) {\n  return null;\n}\n\nconst minViews = parseInt($env.MIN_VIEWS || '1000');\nif (video.views < minViews) {\n  return null;\n}\n\nlet qualityScore = 0;\nif (video.thumbnail) qualityScore += 10;\nif (video.title && video.title.length > 10) qualityScore += 10;\nif (video.views > 10000) qualityScore += 20;\nif (video.views > 50000) qualityScore += 10;\nif (video.source === 'youtube') qualityScore += 10;\nif (video.description && video.description.length > 50) qualityScore += 5;\n\nconst qualityKeywords = ['amazing', 'incredible', 'stunning', 'beautiful', 'epic', 'viral', 'trending'];\nconst titleLower = (video.title || '').toLowerCase();\nqualityKeywords.forEach(keyword => {\n  if (titleLower.includes(keyword)) qualityScore += 2;\n});\n\nif (qualityScore < 25) {\n  return null;\n}\n\nreturn {\n  json: {\n    ...video,\n    qualityScore: qualityScore,\n    selected: true,\n    filteredAt: new Date().toISOString()\n  }\n};"
      },
      "id": "filter-videos",
      "name": "Filter Best Videos",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1250, 300]
    },
    {
      "parameters": {
        "jsCode": "// Add to Processing Queue with Priority\nconst video = $json;\nconst queue = $workflow.staticData.processingQueue || [];\n\nif (queue.some(q => q.videoId === video.videoId)) {\n  return null;\n}\n\nconst queueItem = {\n  videoId: video.videoId,\n  url: video.url,\n  title: video.title,\n  source: video.source,\n  qualityScore: video.qualityScore,\n  addedAt: Date.now(),\n  priority: video.qualityScore,\n  retryCount: 0,\n  maxRetries: 3,\n  status: 'pending'\n};\n\nqueue.push(queueItem);\nqueue.sort((a, b) => b.priority - a.priority);\n\nif (queue.length > 50) {\n  queue.splice(50);\n}\n\n$workflow.staticData.processingQueue = queue;\n\nreturn {\n  json: {\n    ...video,\n    queued: true,\n    queuePosition: queue.findIndex(q => q.videoId === video.videoId) + 1,\n    totalInQueue: queue.length\n  }\n};"
      },
      "id": "add-to-queue",
      "name": "Add to Processing Queue",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1450, 300]
    },
    {
      "parameters": {
        "jsCode": "// Get Next Video from Queue\nconst queue = $workflow.staticData.processingQueue || [];\nconst nextVideo = queue.find(v => v.status === 'pending');\n\nif (!nextVideo) {\n  return null;\n}\n\nnextVideo.status = 'processing';\nnextVideo.startedAt = Date.now();\n$workflow.staticData.processingQueue = queue;\n\nreturn {\n  json: {\n    ...nextVideo,\n    processing: true\n  }\n};"
      },
      "id": "get-next-video",
      "name": "Get Next Video from Queue",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1650, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-video",
              "leftValue": "={{ $json }}",
              "rightValue": "",
              "operator": {
                "type": "object",
                "operation": "notEmpty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-queue",
      "name": "Check Queue Has Videos",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1850, 300]
    },
    {
      "parameters": {
        "command": "=yt-dlp \"{{ $json.url }}\" -f \"best[ext=mp4][height<=1080]\" -o \"/tmp/sora_video_{{ $json.videoId }}.%(ext)s\" --no-playlist --no-warnings --quiet",
        "options": {}
      },
      "id": "download-with-ytdlp",
      "name": "Download with yt-dlp",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [2050, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Verify Video Download\nconst fs = require('fs');\nconst videoPath = `/tmp/sora_video_${$json.videoId}.mp4`;\n\nlet videoInfo = { exists: false, size: 0, valid: false };\n\ntry {\n  if (fs.existsSync(videoPath)) {\n    const stats = fs.statSync(videoPath);\n    videoInfo.exists = true;\n    videoInfo.size = stats.size;\n    if (videoInfo.size > 100 * 1024) {\n      videoInfo.valid = true;\n    }\n  }\n} catch (e) {\n  videoInfo.error = e.message;\n}\n\nif (!videoInfo.valid) {\n  const queue = $workflow.staticData.processingQueue || [];\n  const queueItem = queue.find(q => q.videoId === $json.videoId);\n  if (queueItem) {\n    queueItem.status = 'failed';\n    queueItem.error = 'Download verification failed';\n    queueItem.retryCount += 1;\n    if (queueItem.retryCount < queueItem.maxRetries) {\n      queueItem.status = 'pending';\n    }\n    $workflow.staticData.processingQueue = queue;\n  }\n  return null;\n}\n\nreturn {\n  json: {\n    ...$input.item.json,\n    videoPath: videoPath,\n    videoInfo: videoInfo\n  }\n};"
      },
      "id": "verify-download",
      "name": "Verify Video Download",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2250, 300]
    },
    {
      "parameters": {
        "command": "=ffprobe -v error -select_streams v:0 -show_entries stream=width,height,duration -show_entries format=duration -of json \"/tmp/sora_video_{{ $json.videoId }}.mp4\"",
        "options": {}
      },
      "id": "analyze-video",
      "name": "Analyze Video Properties",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [2450, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Extract Video Analysis\nlet videoAnalysis = { width: 0, height: 0, duration: 0, aspectRatio: 0, isValid: false };\n\ntry {\n  const ffprobeOutput = $json.stdout || $json.output || '';\n  const probeData = JSON.parse(ffprobeOutput);\n  \n  if (probeData.streams?.[0]) {\n    videoAnalysis.width = probeData.streams[0].width || 0;\n    videoAnalysis.height = probeData.streams[0].height || 0;\n    videoAnalysis.duration = parseFloat(probeData.format?.duration || probeData.streams[0].duration || 0);\n    \n    if (videoAnalysis.width > 0 && videoAnalysis.height > 0) {\n      videoAnalysis.aspectRatio = videoAnalysis.width / videoAnalysis.height;\n      videoAnalysis.isValid = true;\n    }\n  }\n} catch (e) {\n  videoAnalysis.error = e.message;\n}\n\nconst minDuration = 3;\nconst maxDuration = 300;\n\nif (videoAnalysis.duration < minDuration || videoAnalysis.duration > maxDuration) {\n  videoAnalysis.isValid = false;\n  videoAnalysis.reason = `Duration ${videoAnalysis.duration}s outside range ${minDuration}-${maxDuration}s`;\n}\n\nreturn {\n  json: {\n    ...$input.item.json,\n    videoAnalysis: videoAnalysis\n  }\n};"
      },
      "id": "extract-analysis",
      "name": "Extract Video Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2650, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "enable-vision",
              "leftValue": "={{ $json.features?.visionAnalysis }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-vision-enabled",
      "name": "Check Vision Analysis Enabled",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [2850, 200]
    },
    {
      "parameters": {
        "command": "=ffmpeg -i \"/tmp/sora_video_{{ $json.videoId }}.mp4\" -vf \"fps=1/10\" -frames:v 3 \"/tmp/frames_{{ $json.videoId }}_%03d.jpg\" -y",
        "options": {}
      },
      "id": "extract-frames",
      "name": "Extract Video Frames",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [3050, 200],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Convert Frames to Base64 for Vision API\nconst fs = require('fs');\nconst frames = [];\n\nfor (let i = 1; i <= 3; i++) {\n  const framePath = `/tmp/frames_${$json.videoId}_${String(i).padStart(3, '0')}.jpg`;\n  if (fs.existsSync(framePath)) {\n    const frameBase64 = fs.readFileSync(framePath).toString('base64');\n    frames.push({\n      path: framePath,\n      base64: frameBase64,\n      index: i\n    });\n  }\n}\n\nreturn {\n  json: {\n    ...$input.item.json,\n    frames: frames,\n    framesCount: frames.length\n  }\n};"
      },
      "id": "convert-frames-base64",
      "name": "Convert Frames to Base64",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3250, 200]
    },
    {
      "parameters": {
        "url": "=https://api.openai.com/v1/chat/completions",
        "authentication": "genericCredentialType",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"gpt-4-vision-preview\",\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": [\n        {\n          \"type\": \"text\",\n          \"text\": \"Analiza estos frames del video de Sora AI. Describe: objetos visibles, escenas, emociones, colores dominantes, temas principales, estilo visual. Basado en esto, sugiere hashtags relevantes y una descripci√≥n atractiva. Responde en JSON: {\\\"description\\\": \\\"...\\\", \\\"hashtags\\\": [\\\"#tag1\\\"], \\\"themes\\\": [\\\"theme1\\\"], \\\"visualStyle\\\": \\\"...\\\"}\"\n        },\n        {\n          \"type\": \"image_url\",\n          \"image_url\": {\n            \"url\": \"data:image/jpeg;base64,{{ $json.frames[0]?.base64 }}\"\n          }\n        },\n        {\n          \"type\": \"image_url\",\n          \"image_url\": {\n            \"url\": \"data:image/jpeg;base64,{{ $json.frames[1]?.base64 }}\"\n          }\n        },\n        {\n          \"type\": \"image_url\",\n          \"image_url\": {\n            \"url\": \"data:image/jpeg;base64,{{ $json.frames[2]?.base64 }}\"\n          }\n        }\n      ]\n    }\n  ],\n  \"max_tokens\": 1000,\n  \"response_format\": { \"type\": \"json_object\" }\n}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "analyze-frames-vision",
      "name": "Analyze Frames with GPT-4 Vision",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [3450, 200],
      "continueOnFail": true,
      "credentials": {
        "httpHeaderAuth": {
          "id": "openai-api",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Process Vision Analysis\nlet visionAnalysis = null;\n\ntry {\n  if ($input.item.json.choices?.[0]?.message?.content) {\n    const content = $input.item.json.choices[0].message.content;\n    visionAnalysis = JSON.parse(content);\n  }\n} catch (e) {\n  visionAnalysis = { error: e.message };\n}\n\nreturn {\n  json: {\n    ...$input.item.json,\n    visionAnalysis: visionAnalysis\n  }\n};"
      },
      "id": "process-vision-analysis",
      "name": "Process Vision Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3650, 200]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "is-valid",
              "leftValue": "={{ $json.videoAnalysis.isValid }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-valid",
      "name": "Check Video Valid",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [2850, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "enable-thumbnail",
              "leftValue": "={{ $json.features?.thumbnailGeneration }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-thumbnail-enabled",
      "name": "Check Thumbnail Generation Enabled",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [3050, 300]
    },
    {
      "parameters": {
        "command": "=ffmpeg -i \"/tmp/sora_video_{{ $json.videoId }}.mp4\" -ss {{ Math.round($json.videoAnalysis.duration * 0.25) }} -vframes 1 -vf \"scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2\" \"/tmp/thumbnail_{{ $json.videoId }}.jpg\" -y",
        "options": {}
      },
      "id": "generate-thumbnail",
      "name": "Generate Custom Thumbnail",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [3250, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Prepare Advanced Video Editing with Smart Parameters\nconst videoPath = `/tmp/sora_video_${$json.videoId}.mp4`;\nconst outputPath = `/tmp/sora_edited_${$json.videoId}.mp4`;\nconst analysis = $json.videoAnalysis;\n\nconst uniqueParams = {\n  speed1: 0.98 + Math.random() * 0.04,\n  speed2: 0.99 + Math.random() * 0.02,\n  brightness: -0.02 + Math.random() * 0.04,\n  contrast: 0.98 + Math.random() * 0.04,\n  saturation: 0.97 + Math.random() * 0.06,\n  gamma: 0.95 + Math.random() * 0.1,\n  targetWidth: 1080,\n  targetHeight: 1920,\n  cropW: Math.floor(Math.random() * 20) + 1060,\n  cropH: Math.floor(Math.random() * 20) + 1900,\n  cropX: Math.floor(Math.random() * 10),\n  cropY: Math.floor(Math.random() * 10),\n  rotation: (Math.random() - 0.5) * 2,\n  noiseAmount: Math.floor(Math.random() * 3),\n  sharpen: Math.random() * 0.3,\n  fadeIn: Math.random() * 0.3,\n  fadeOut: Math.random() * 0.3,\n  scaleMethod: analysis.aspectRatio > 1 ? 'crop' : 'pad'\n};\n\nconst ffmpegCommand = `ffmpeg -i \"${videoPath}\" \\\n  -vf \"scale=${uniqueParams.targetWidth}:${uniqueParams.targetHeight}:force_original_aspect_ratio=decrease,\\\n  pad=${uniqueParams.targetWidth}:${uniqueParams.targetHeight}:(ow-iw)/2:(oh-ih)/2,\\\n  crop=${uniqueParams.cropW}:${uniqueParams.cropH}:${uniqueParams.cropX}:${uniqueParams.cropY},\\\n  rotate=${uniqueParams.rotation}*PI/180,\\\n  eq=brightness=${uniqueParams.brightness}:contrast=${uniqueParams.contrast}:saturation=${uniqueParams.saturation}:gamma=${uniqueParams.gamma},\\\n  noise=alls=${uniqueParams.noiseAmount}:allf=t+u,\\\n  unsharp=5:5:${uniqueParams.sharpen}:5:5:0.0,\\\n  fade=t=in:st=0:d=${uniqueParams.fadeIn},fade=t=out:st=0:d=${uniqueParams.fadeOut}\" \\\n  -filter_complex \"[0:v]setpts=${uniqueParams.speed1}*PTS[v1];[v1]setpts=${uniqueParams.speed2}*PTS[v]\" -map \"[v]\" -map 0:a? \\\n  -c:v libx264 -preset medium -crf 23 -c:a aac -b:a 128k -ar 44100 \\\n  -movflags +faststart -pix_fmt yuv420p \\\n  \"${outputPath}\" -y`;\n\nreturn {\n  json: {\n    ...$input.item.json,\n    videoPath: videoPath,\n    outputPath: outputPath,\n    ffmpegCommand: ffmpegCommand,\n    uniqueParams: uniqueParams,\n    editedVideoPath: outputPath\n  }\n};"
      },
      "id": "prepare-editing",
      "name": "Prepare Advanced Video Editing",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3050, 400]
    },
    {
      "parameters": {
        "command": "={{ $json.ffmpegCommand }}",
        "options": {}
      },
      "id": "execute-editing",
      "name": "Execute FFmpeg Editing",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [3250, 400],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Verify Edited Video\nconst fs = require('fs');\nconst outputPath = $json.outputPath;\n\nlet editedVideoInfo = { exists: false, size: 0, valid: false };\n\ntry {\n  if (fs.existsSync(outputPath)) {\n    const stats = fs.statSync(outputPath);\n    editedVideoInfo.exists = true;\n    editedVideoInfo.size = stats.size;\n    if (editedVideoInfo.size > 100 * 1024) {\n      editedVideoInfo.valid = true;\n    }\n  }\n} catch (e) {\n  editedVideoInfo.error = e.message;\n}\n\nif (!editedVideoInfo.valid) {\n  return null;\n}\n\nreturn {\n  json: {\n    ...$input.item.json,\n    editedVideoInfo: editedVideoInfo\n  }\n};"
      },
      "id": "verify-edited",
      "name": "Verify Edited Video",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3450, 400]
    },
    {
      "parameters": {
        "url": "=https://api.openai.com/v1/chat/completions",
        "authentication": "genericCredentialType",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"gpt-4-turbo-preview\",\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"Eres un experto en marketing de redes sociales. Genera contenido viral optimizado para Instagram, TikTok y YouTube. Usa emojis estrat√©gicamente.\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"Genera contenido para video de Sora AI. T√≠tulo: {{ $json.title }}. Descripci√≥n: {{ $json.description || 'Video generado con IA' }}. Duraci√≥n: {{ Math.round($json.videoAnalysis.duration) }}s. {{ $json.visionAnalysis ? 'An√°lisis visual: ' + JSON.stringify($json.visionAnalysis) : '' }}. Genera JSON: {\\\"description\\\": \\\"...\\\", \\\"hashtags\\\": [\\\"#tag1\\\"], \\\"title\\\": \\\"...\\\", \\\"instagramCaption\\\": \\\"...\\\", \\\"tiktokCaption\\\": \\\"...\\\", \\\"youtubeTitle\\\": \\\"...\\\", \\\"youtubeDescription\\\": \\\"...\\\"}\"\n    }\n  ],\n  \"max_tokens\": 1500,\n  \"temperature\": 0.9,\n  \"response_format\": { \"type\": \"json_object\" }\n}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "generate-content-chatgpt",
      "name": "Generate Content with ChatGPT",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [3650, 300],
      "continueOnFail": true,
      "credentials": {
        "httpHeaderAuth": {
          "id": "openai-api",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key={{ $env.GEMINI_API_KEY }}",
        "authentication": "none",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [\n    {\n      \"parts\": [\n        {\n          \"text\": \"Genera contenido viral para video de Sora AI. T√≠tulo: {{ $json.title }}. Duraci√≥n: {{ Math.round($json.videoAnalysis.duration) }}s. Responde en JSON: {\\\"description\\\": \\\"...\\\", \\\"hashtags\\\": [\\\"#tag1\\\"], \\\"instagramCaption\\\": \\\"...\\\", \\\"tiktokCaption\\\": \\\"...\\\"}\"\n        }\n      ]\n    }\n  ],\n  \"generationConfig\": {\n    \"temperature\": 0.9,\n    \"maxOutputTokens\": 2000\n  }\n}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "generate-content-gemini",
      "name": "Generate Content with Gemini",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [3650, 400],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Process AI Content with Vision Analysis Integration\nlet content = null;\n\n// Try ChatGPT first\nif ($input.item.json.choices?.[0]?.message?.content) {\n  try {\n    content = JSON.parse($input.item.json.choices[0].message.content);\n  } catch (e) {\n    // Fallback\n  }\n}\n\n// Try Gemini if ChatGPT failed\nif (!content && $input.item.json.candidates?.[0]?.content?.parts?.[0]?.text) {\n  try {\n    const response = $input.item.json.candidates[0].content.parts[0].text;\n    const jsonMatch = response.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      content = JSON.parse(jsonMatch[0]);\n    }\n  } catch (e) {\n    // Fallback\n  }\n}\n\n// Merge with vision analysis if available\nif ($json.visionAnalysis && !$json.visionAnalysis.error) {\n  if (!content) content = {};\n  \n  // Combine hashtags from vision analysis\n  if ($json.visionAnalysis.hashtags) {\n    content.hashtags = [...new Set([\n      ...(content.hashtags || []),\n      ...($json.visionAnalysis.hashtags || [])\n    ])];\n  }\n  \n  // Enhance description with vision analysis\n  if ($json.visionAnalysis.description) {\n    content.description = content.description ? \n      `${content.description}\\n\\n${$json.visionAnalysis.description}` : \n      $json.visionAnalysis.description;\n  }\n}\n\n// Fallback if both fail\nif (!content) {\n  const fallbackHashtags = ['#AI', '#Sora', '#VideoGenerado', '#IA', '#Creatividad', '#Tecnologia', '#Viral', '#Trending'];\n  content = {\n    description: `üé¨ ${$json.title}\\n\\n‚ú® Video generado con IA usando Sora\\n\\nüî• Contenido √∫nico y creativo\\n\\n${fallbackHashtags.join(' ')}`,\n    hashtags: fallbackHashtags,\n    title: $json.title,\n    instagramCaption: `üé¨ ${$json.title}\\n\\n‚ú® Video generado con IA usando Sora\\n\\nüî• Contenido √∫nico y creativo\\n\\n${fallbackHashtags.join(' ')}`,\n    tiktokCaption: `üé¨ ${$json.title} ‚ú® Video generado con IA #AI #Sora #Viral`,\n    youtubeTitle: `${$json.title} - Sora AI Generated Video`,\n    youtubeDescription: `üé¨ ${$json.title}\\n\\n‚ú® Video generado con IA usando Sora`\n  };\n}\n\n// Ensure hashtags array\nif (!Array.isArray(content.hashtags)) {\n  content.hashtags = typeof content.hashtags === 'string' ? \n    content.hashtags.split(/[,\\s]+/).filter(h => h.trim()) : [];\n}\n\n// Format hashtags\ncontent.hashtags = content.hashtags.map(tag => {\n  tag = tag.trim();\n  if (!tag.startsWith('#')) tag = '#' + tag;\n  return tag;\n}).filter(tag => tag.length > 1);\n\n// Limit hashtags\nif (content.hashtags.length < 5) {\n  content.hashtags.push('#AI', '#Sora', '#Video', '#Viral', '#Trending');\n}\nif (content.hashtags.length > 15) {\n  content.hashtags = content.hashtags.slice(0, 15);\n}\n\nreturn {\n  json: {\n    ...$input.item.json,\n    generatedContent: content,\n    caption: content.instagramCaption || content.description,\n    hashtags: content.hashtags.join(' '),\n    instagramCaption: content.instagramCaption || content.description,\n    tiktokCaption: content.tiktokCaption || content.description.substring(0, 150),\n    youtubeTitle: content.youtubeTitle || content.title,\n    youtubeDescription: content.youtubeDescription || content.description\n  }\n};"
      },
      "id": "process-ai-content",
      "name": "Process AI Generated Content",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3850, 300]
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Rate Limit Checking with Smart Scheduling\nconst now = Date.now();\nconst rateLimits = {\n  instagram: { max: parseInt($env.INSTAGRAM_RATE_LIMIT || '25'), window: 3600000 },\n  tiktok: { max: parseInt($env.TIKTOK_RATE_LIMIT || '10'), window: 3600000 },\n  youtube: { max: parseInt($env.YOUTUBE_RATE_LIMIT || '6'), window: 3600000 }\n};\n\nconst rateLimitHistory = $workflow.staticData.rateLimitHistory || {};\nconst canUpload = {};\nconst waitTimes = {};\n\n// Check rate limits\nfor (const platform of ['instagram', 'tiktok', 'youtube']) {\n  const limit = rateLimits[platform];\n  const history = rateLimitHistory[platform] || [];\n  const recentRequests = history.filter(timestamp => now - timestamp < limit.window);\n  \n  canUpload[platform] = recentRequests.length < limit.max;\n  \n  if (!canUpload[platform]) {\n    const oldestRequest = Math.min(...recentRequests);\n    waitTimes[platform] = (oldestRequest + limit.window) - now;\n  } else {\n    waitTimes[platform] = 0;\n    recentRequests.push(now);\n    rateLimitHistory[platform] = recentRequests;\n  }\n}\n\n$workflow.staticData.rateLimitHistory = rateLimitHistory;\n\n// Smart scheduling analysis\nlet bestPostingTime = null;\nif ($json.features?.smartScheduling) {\n  const uploadHistory = $workflow.staticData.uploadResults || [];\n  const hourPerformance = {};\n  \n  uploadHistory.forEach(upload => {\n    const hour = new Date(upload.timestamp).getHours();\n    hourPerformance[hour] = (hourPerformance[hour] || 0) + 1;\n  });\n  \n  const bestHours = Object.entries(hourPerformance)\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 3)\n    .map(([hour]) => parseInt(hour));\n  \n  const currentHour = new Date().getHours();\n  const nextBestHour = bestHours.find(h => h > currentHour) || bestHours[0];\n  \n  bestPostingTime = {\n    bestHours: bestHours,\n    nextBestHour: nextBestHour,\n    currentHour: currentHour\n  };\n}\n\nreturn {\n  json: {\n    ...$input.item.json,\n    canUpload: canUpload,\n    rateLimits: rateLimits,\n    waitTimes: waitTimes,\n    bestPostingTime: bestPostingTime,\n    uploadStrategy: Object.values(canUpload).some(v => v) ? 'immediate' : 'queue'\n  }\n};"
      },
      "id": "check-upload-limits",
      "name": "Check Upload Rate Limits",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4050, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "can-upload-instagram",
              "leftValue": "={{ $json.canUpload.instagram }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-instagram-limit",
      "name": "Check Instagram Rate Limit",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [4250, 200]
    },
    {
      "parameters": {
        "url": "=https://graph.facebook.com/v18.0/{{ $env.INSTAGRAM_ACCOUNT_ID }}/media",
        "authentication": "oAuth2",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"image_url\": \"{{ $json.thumbnail || ($json.features?.thumbnailGeneration ? '/tmp/thumbnail_' + $json.videoId + '.jpg' : '') }}\",\n  \"caption\": \"{{ $json.instagramCaption }}\",\n  \"media_type\": \"REELS\"\n}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "upload-instagram",
      "name": "Upload to Instagram",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [4450, 200],
      "continueOnFail": true,
      "credentials": {
        "oAuth2Api": {
          "id": "instagram-oauth",
          "name": "Instagram OAuth2 API"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "can-upload-tiktok",
              "leftValue": "={{ $json.canUpload.tiktok }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-tiktok-limit",
      "name": "Check TikTok Rate Limit",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [4250, 300]
    },
    {
      "parameters": {
        "url": "=https://open.tiktokapis.com/v2/post/publish/inbox/",
        "authentication": "genericCredentialType",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"post_info\": {\n    \"title\": \"{{ $json.tiktokCaption }}\",\n    \"privacy_level\": \"PUBLIC_TO_EVERYONE\",\n    \"disable_duet\": false,\n    \"disable_comment\": false,\n    \"disable_stitch\": false,\n    \"video_cover_timestamp_ms\": 1000\n  },\n  \"source_info\": {\n    \"source\": \"FILE_UPLOAD\"\n  }\n}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "upload-tiktok",
      "name": "Upload to TikTok",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [4450, 300],
      "continueOnFail": true,
      "credentials": {
        "httpHeaderAuth": {
          "id": "tiktok-api",
          "name": "TikTok API"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "can-upload-youtube",
              "leftValue": "={{ $json.canUpload.youtube }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-youtube-limit",
      "name": "Check YouTube Rate Limit",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [4250, 400]
    },
    {
      "parameters": {
        "url": "=https://www.googleapis.com/upload/youtube/v3/videos?uploadType=resumable&part=snippet,status",
        "authentication": "oAuth2",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"snippet\": {\n    \"title\": \"{{ $json.youtubeTitle }}\",\n    \"description\": \"{{ $json.youtubeDescription }}\",\n    \"tags\": {{ JSON.stringify($json.generatedContent.hashtags || []) }},\n    \"categoryId\": \"22\"\n  },\n  \"status\": {\n    \"privacyStatus\": \"public\"\n  }\n}",
        "options": {
          "timeout": 300000
        }
      },
      "id": "upload-youtube",
      "name": "Upload to YouTube",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [4450, 400],
      "continueOnFail": true,
      "credentials": {
        "oAuth2Api": {
          "id": "youtube-oauth",
          "name": "YouTube OAuth2 API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Results Saving\nconst video = $input.item.json;\nconst stats = $workflow.staticData.workflowStats || {};\nstats.videosProcessed = (stats.videosProcessed || 0) + 1;\n\nconst uploadResults = {\n  instagram: video.canUpload?.instagram ? 'success' : 'skipped',\n  tiktok: video.canUpload?.tiktok ? 'success' : 'skipped',\n  youtube: video.canUpload?.youtube ? 'success' : 'skipped'\n};\n\nif (Object.values(uploadResults).some(r => r === 'success')) {\n  stats.videosUploaded = (stats.videosUploaded || 0) + 1;\n}\n\n$workflow.staticData.workflowStats = stats;\n\nconst processedVideos = $workflow.staticData.processedVideos || [];\nprocessedVideos.push({\n  videoId: video.videoId,\n  url: video.url,\n  title: video.title,\n  source: video.source,\n  timestamp: Date.now(),\n  uploadedTo: uploadResults,\n  caption: video.caption,\n  hashtags: video.hashtags,\n  qualityScore: video.qualityScore,\n  visionAnalysis: video.visionAnalysis\n});\n\nif (processedVideos.length > 1000) {\n  processedVideos.shift();\n}\n\n$workflow.staticData.processedVideos = processedVideos;\n\nconst queue = $workflow.staticData.processingQueue || [];\nconst queueItem = queue.find(q => q.videoId === video.videoId);\nif (queueItem) {\n  queueItem.status = 'completed';\n  queueItem.completedAt = Date.now();\n  queueItem.uploadResults = uploadResults;\n  $workflow.staticData.processingQueue = queue;\n}\n\nconst uploadHistory = $workflow.staticData.uploadResults || [];\nuploadHistory.push({\n  videoId: video.videoId,\n  timestamp: new Date().toISOString(),\n  platforms: uploadResults,\n  caption: video.caption,\n  hashtags: video.hashtags\n});\n\nif (uploadHistory.length > 500) {\n  uploadHistory.shift();\n}\n\n$workflow.staticData.uploadResults = uploadHistory;\n\nreturn {\n  json: {\n    ...video,\n    processed: true,\n    processedAt: new Date().toISOString(),\n    uploadResults: uploadResults,\n    stats: stats\n  }\n};"
      },
      "id": "save-results",
      "name": "Save Processing Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4650, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "enable-webhooks",
              "leftValue": "={{ $json.features?.webhooks }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-webhook-enabled",
      "name": "Check Webhook Enabled",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [4850, 300]
    },
    {
      "parameters": {
        "url": "={{ $env.WEBHOOK_URL }}",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"event\": \"video_processed\",\n  \"videoId\": \"{{ $json.videoId }}\",\n  \"title\": \"{{ $json.title }}\",\n  \"platforms\": {{ JSON.stringify($json.uploadResults) }},\n  \"timestamp\": \"{{ new Date().toISOString() }}\",\n  \"stats\": {{ JSON.stringify($json.stats) }}\n}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "send-webhook",
      "name": "Send Webhook Notification",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [5050, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "command": "=find /tmp -name \"sora_video_*\" -type f -mtime +1 -delete && find /tmp -name \"sora_edited_*\" -type f -mtime +1 -delete && find /tmp -name \"frames_*\" -type f -mtime +1 -delete && find /tmp -name \"thumbnail_*\" -type f -mtime +1 -delete",
        "options": {}
      },
      "id": "cleanup-files",
      "name": "Cleanup Temporary Files",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [4850, 400],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Prepare Enhanced Notification\nconst stats = $workflow.staticData.workflowStats || {};\nconst lastVideo = $input.item.json;\n\nconst notification = {\n  success: true,\n  message: `‚úÖ Video procesado exitosamente\\n\\nüìπ ${lastVideo.title}\\n\\nüìä Estad√≠sticas:\\n‚Ä¢ Videos procesados: ${stats.videosProcessed || 0}\\n‚Ä¢ Videos subidos: ${stats.videosUploaded || 0}\\n‚Ä¢ Plataformas: ${Object.entries(lastVideo.uploadResults || {}).filter(([_, v]) => v === 'success').map(([p]) => p).join(', ') || 'Ninguna'}\\n\\n${lastVideo.visionAnalysis ? 'üé® An√°lisis visual completado\\n' : ''}${lastVideo.features?.thumbnailGeneration ? 'üñºÔ∏è Thumbnail generado\\n' : ''}\\nüîÑ Pr√≥xima ejecuci√≥n en 6 horas`,\n  timestamp: new Date().toISOString()\n};\n\nreturn {\n  json: {\n    ...lastVideo,\n    notification: notification\n  }\n};"
      },
      "id": "prepare-notification",
      "name": "Prepare Notification",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5050, 400]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-telegram",
              "leftValue": "={{ $env.TELEGRAM_BOT_TOKEN }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-telegram",
      "name": "Check Telegram Available",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [5250, 400]
    },
    {
      "parameters": {
        "chatId": "={{ $env.TELEGRAM_CHAT_ID }}",
        "text": "={{ $json.notification.message }}",
        "additionalFields": {
          "parse_mode": "Markdown"
        }
      },
      "id": "send-telegram",
      "name": "Send Telegram Notification",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [5450, 400],
      "credentials": {
        "telegramApi": {
          "id": "telegram-credentials",
          "name": "Telegram Bot API"
        }
      }
    }
  ],
  "connections": {
    "Schedule Trigger - Every 6 Hours": {
      "main": [
        [
          {
            "node": "Initialize Workflow",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize Workflow": {
      "main": [
        [
          {
            "node": "Prepare Search Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Search Sources": {
      "main": [
        [
          {
            "node": "Search Reddit Sora",
            "type": "main",
            "index": 0
          },
          {
            "node": "Search YouTube Sora",
            "type": "main",
            "index": 0
          },
          {
            "node": "Search Twitter Sora",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search Reddit Sora": {
      "main": [
        [
          {
            "node": "Extract Video URLs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search YouTube Sora": {
      "main": [
        [
          {
            "node": "Extract Video URLs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search Twitter Sora": {
      "main": [
        [
          {
            "node": "Extract Video URLs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Video URLs": {
      "main": [
        [
          {
            "node": "Filter Best Videos",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Best Videos": {
      "main": [
        [
          {
            "node": "Add to Processing Queue",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add to Processing Queue": {
      "main": [
        [
          {
            "node": "Get Next Video from Queue",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Next Video from Queue": {
      "main": [
        [
          {
            "node": "Check Queue Has Videos",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Queue Has Videos": {
      "main": [
        [
          {
            "node": "Download with yt-dlp",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download with yt-dlp": {
      "main": [
        [
          {
            "node": "Verify Video Download",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Verify Video Download": {
      "main": [
        [
          {
            "node": "Analyze Video Properties",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Analyze Video Properties": {
      "main": [
        [
          {
            "node": "Extract Video Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Video Analysis": {
      "main": [
        [
          {
            "node": "Check Vision Analysis Enabled",
            "type": "main",
            "index": 0
          },
          {
            "node": "Check Video Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Vision Analysis Enabled": {
      "main": [
        [
          {
            "node": "Extract Video Frames",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Video Frames": {
      "main": [
        [
          {
            "node": "Convert Frames to Base64",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert Frames to Base64": {
      "main": [
        [
          {
            "node": "Analyze Frames with GPT-4 Vision",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Analyze Frames with GPT-4 Vision": {
      "main": [
        [
          {
            "node": "Process Vision Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Vision Analysis": {
      "main": [
        [
          {
            "node": "Check Video Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Video Valid": {
      "main": [
        [
          {
            "node": "Check Thumbnail Generation Enabled",
            "type": "main",
            "index": 0
          },
          {
            "node": "Prepare Advanced Video Editing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Thumbnail Generation Enabled": {
      "main": [
        [
          {
            "node": "Generate Custom Thumbnail",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Advanced Video Editing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Custom Thumbnail": {
      "main": [
        [
          {
            "node": "Prepare Advanced Video Editing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Advanced Video Editing": {
      "main": [
        [
          {
            "node": "Execute FFmpeg Editing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute FFmpeg Editing": {
      "main": [
        [
          {
            "node": "Verify Edited Video",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Verify Edited Video": {
      "main": [
        [
          {
            "node": "Generate Content with ChatGPT",
            "type": "main",
            "index": 0
          },
          {
            "node": "Generate Content with Gemini",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Content with ChatGPT": {
      "main": [
        [
          {
            "node": "Process AI Generated Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Content with Gemini": {
      "main": [
        [
          {
            "node": "Process AI Generated Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process AI Generated Content": {
      "main": [
        [
          {
            "node": "Check Upload Rate Limits",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Upload Rate Limits": {
      "main": [
        [
          {
            "node": "Check Instagram Rate Limit",
            "type": "main",
            "index": 0
          },
          {
            "node": "Check TikTok Rate Limit",
            "type": "main",
            "index": 0
          },
          {
            "node": "Check YouTube Rate Limit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Instagram Rate Limit": {
      "main": [
        [
          {
            "node": "Upload to Instagram",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload to Instagram": {
      "main": [
        [
          {
            "node": "Save Processing Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check TikTok Rate Limit": {
      "main": [
        [
          {
            "node": "Upload to TikTok",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload to TikTok": {
      "main": [
        [
          {
            "node": "Save Processing Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check YouTube Rate Limit": {
      "main": [
        [
          {
            "node": "Upload to YouTube",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload to YouTube": {
      "main": [
        [
          {
            "node": "Save Processing Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Processing Results": {
      "main": [
        [
          {
            "node": "Check Webhook Enabled",
            "type": "main",
            "index": 0
          },
          {
            "node": "Cleanup Temporary Files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Webhook Enabled": {
      "main": [
        [
          {
            "node": "Send Webhook Notification",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Cleanup Temporary Files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Webhook Notification": {
      "main": [
        [
          {
            "node": "Cleanup Temporary Files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cleanup Temporary Files": {
      "main": [
        [
          {
            "node": "Prepare Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Notification": {
      "main": [
        [
          {
            "node": "Check Telegram Available",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Telegram Available": {
      "main": [
        [
          {
            "node": "Send Telegram Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2024-01-01T00:00:00.000Z",
  "versionId": "3.0"
}



