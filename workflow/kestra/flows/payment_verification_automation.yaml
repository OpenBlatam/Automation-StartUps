id: payment_verification_automation
namespace: support.automation

labels:
  app: support
  process: payment-verification
  category: billing
  automation: true

description: |
  ü§ñ Automatizaci√≥n Completa de Verificaci√≥n de Pagos
  
  Este workflow procesa autom√°ticamente tickets de facturaci√≥n donde el cliente
  afirma haber pagado pero la factura aparece como pendiente.
  
  CARACTER√çSTICAS:
  - ‚úÖ Detecci√≥n autom√°tica de escenarios (pago reciente, antiguo, m√∫ltiples facturas)
  - ‚úÖ Personalizaci√≥n seg√∫n nivel de cliente (Standard, Premium, VIP, Enterprise)
  - ‚úÖ Aplicaci√≥n autom√°tica de cr√©ditos temporales
  - ‚úÖ Generaci√≥n de respuestas emp√°ticas y resolutivas
  - ‚úÖ Integraci√≥n con sistemas de facturaci√≥n
  - ‚úÖ Tracking de m√©tricas y analytics
  - ‚úÖ Soporte multi-idioma
  
  FLUJO:
  1. Recibe ticket v√≠a webhook/API
  2. Analiza el ticket y detecta escenario
  3. Obtiene informaci√≥n del cliente y historial
  4. Calcula cr√©dito temporal apropiado
  5. Genera respuesta personalizada
  6. Aplica cr√©dito a la cuenta
  7. Env√≠a email al cliente
  8. Crea tarea de seguimiento
  9. Registra m√©tricas

inputs:
  ticket_id:
    type: STRING
    description: ID del ticket de soporte
    required: true
  
  customer_email:
    type: STRING
    description: Email del cliente
    required: true
  
  invoice_number:
    type: STRING
    description: N√∫mero de factura (opcional)
    required: false
  
  invoice_amount:
    type: FLOAT
    description: Monto de la factura (opcional)
    required: false
  
  payment_date:
    type: STRING
    description: Fecha del pago reportado (opcional)
    required: false

tasks:
  - id: get_ticket_info
    type: io.kestra.plugin.jdbc.postgresql.Query
    url: "{{ envs.POSTGRES_URL }}"
    username: "{{ envs.POSTGRES_USER }}"
    password: "{{ envs.POSTGRES_PASSWORD }}"
    sql: |
      SELECT 
        ticket_id,
        customer_name,
        customer_email,
        customer_id,
        subject,
        description,
        category,
        subcategory,
        priority,
        status,
        created_at
      FROM support_tickets
      WHERE ticket_id = '{{ inputs.ticket_id }}'
    store: true

  - id: get_customer_info
    type: io.kestra.plugin.scripts.python.Script
    needs: get_ticket_info
    script: |
      from workflow.kestra.flows.lib.support_billing_payment_verification_advanced import (
          CustomerTier, PaymentScenario
      )
      import json
      
      ticket_data = {{ outputs.get_ticket_info.rows[0] | json }}
      
      # Obtener informaci√≥n del cliente desde BD
      customer_email = ticket_data.get("customer_email") or "{{ inputs.customer_email }}"
      
      # Simular obtenci√≥n de informaci√≥n del cliente
      # En producci√≥n, esto vendr√≠a de la BD o CRM
      customer_info = {
          "customer_id": ticket_data.get("customer_id"),
          "customer_email": customer_email,
          "customer_name": ticket_data.get("customer_name", "Cliente"),
          "tier": "standard",  # standard, premium, vip, enterprise
          "payment_reliability_score": 0.95,
          "similar_tickets_count": 0,
          "pending_invoices_count": 1
      }
      
      # Detectar escenario
      payment_date = "{{ inputs.payment_date }}" if "{{ inputs.payment_date }}" else None
      
      print(json.dumps({
          "customer_info": customer_info,
          "ticket_data": ticket_data,
          "payment_date": payment_date
      }))
    store: true

  - id: detect_scenario
    type: io.kestra.plugin.scripts.python.Script
    needs: get_customer_info
    script: |
      from workflow.kestra.flows.lib.support_billing_payment_verification_advanced import (
          PaymentScenario, CustomerTier, _detect_scenario
      )
      import json
      
      customer_info = {{ outputs.get_customer_info.output | json }}
      
      scenario = _detect_scenario(
          customer_info.get("payment_date"),
          customer_info.get("customer_info", {})
      )
      
      customer_tier = CustomerTier(customer_info["customer_info"].get("tier", "standard"))
      
      print(json.dumps({
          "scenario": scenario.value,
          "customer_tier": customer_tier.value,
          "customer_info": customer_info["customer_info"]
      }))
    store: true

  - id: calculate_credit
    type: io.kestra.plugin.scripts.python.Script
    needs: [get_customer_info, detect_scenario]
    script: |
      from workflow.kestra.flows.lib.support_billing_payment_verification_advanced import (
          PaymentScenario, CustomerTier, _calculate_credit_amount
      )
      import json
      
      customer_info = {{ outputs.get_customer_info.output | json }}
      scenario_data = {{ outputs.detect_scenario.output | json }}
      
      invoice_amount = float("{{ inputs.invoice_amount }}") if "{{ inputs.invoice_amount }}" else None
      
      if not invoice_amount:
          # Intentar obtener de la descripci√≥n del ticket
          description = customer_info["ticket_data"].get("description", "")
          # Extraer monto de la descripci√≥n (simplificado)
          import re
          amount_match = re.search(r'\$?(\d+\.?\d*)', description)
          if amount_match:
              invoice_amount = float(amount_match.group(1))
          else:
              invoice_amount = 0.0
      
      scenario = PaymentScenario(scenario_data["scenario"])
      customer_tier = CustomerTier(scenario_data["customer_tier"])
      
      credit_amount = _calculate_credit_amount(
          invoice_amount,
          customer_tier,
          scenario,
          customer_info["customer_info"]
      )
      
      print(json.dumps({
          "invoice_amount": invoice_amount,
          "credit_amount": credit_amount,
          "scenario": scenario.value,
          "customer_tier": customer_tier.value
      }))
    store: true

  - id: generate_response
    type: io.kestra.plugin.scripts.python.Script
    needs: [get_customer_info, detect_scenario, calculate_credit]
    script: |
      from workflow.kestra.flows.lib.support_billing_payment_verification_advanced import (
          get_advanced_payment_verification_template,
          PaymentScenario, CustomerTier
      )
      import json
      
      customer_info = {{ outputs.get_customer_info.output | json }}
      scenario_data = {{ outputs.detect_scenario.output | json }}
      credit_data = {{ outputs.calculate_credit.output | json }}
      
      ticket_data = customer_info["ticket_data"]
      scenario = PaymentScenario(scenario_data["scenario"])
      customer_tier = CustomerTier(scenario_data["customer_tier"])
      
      response = get_advanced_payment_verification_template(
          ticket_data=ticket_data,
          invoice_number="{{ inputs.invoice_number }}" if "{{ inputs.invoice_number }}" else None,
          invoice_amount=credit_data["invoice_amount"],
          credit_amount=credit_data["credit_amount"],
          payment_date="{{ inputs.payment_date }}" if "{{ inputs.payment_date }}" else None,
          transaction_id=None,
          payment_method=None,
          scenario=scenario,
          customer_tier=customer_tier,
          customer_history=customer_info["customer_info"],
          language="es",  # Detectar desde ticket
          urgency_level=ticket_data.get("priority", "normal")
      )
      
      print(json.dumps(response))
    store: true

  - id: apply_credit
    type: io.kestra.plugin.jdbc.postgresql.Query
    needs: [get_customer_info, calculate_credit]
    url: "{{ envs.POSTGRES_URL }}"
    username: "{{ envs.POSTGRES_USER }}"
    password: "{{ envs.POSTGRES_PASSWORD }}"
    sql: |
      -- Aplicar cr√©dito temporal a la cuenta del cliente
      INSERT INTO customer_credits (
        customer_id,
        amount,
        reason,
        invoice_id,
        ticket_id,
        created_at
      ) VALUES (
        '{{ outputs.get_customer_info.output.customer_info.customer_id }}',
        {{ outputs.calculate_credit.output.credit_amount }},
        'Cr√©dito temporal - Verificaci√≥n de pago pendiente',
        '{{ inputs.invoice_number }}',
        '{{ inputs.ticket_id }}',
        NOW()
      )
      ON CONFLICT DO NOTHING
      RETURNING id, amount, created_at
    store: true
    allowFailure: true

  - id: send_email
    type: io.kestra.plugin.notifications.email.Email
    needs: generate_response
    to: "{{ outputs.get_customer_info.output.customer_info.customer_email }}"
    subject: "{{ outputs.generate_response.output.subject }}"
    html: "{{ outputs.generate_response.output.html_body }}"
    from: "{{ envs.SUPPORT_EMAIL_FROM }}"
    allowFailure: true

  - id: update_ticket
    type: io.kestra.plugin.jdbc.postgresql.Query
    needs: [generate_response, apply_credit]
    url: "{{ envs.POSTGRES_URL }}"
    username: "{{ envs.POSTGRES_USER }}"
    password: "{{ envs.POSTGRES_PASSWORD }}"
    sql: |
      UPDATE support_tickets
      SET 
        status = 'waiting_customer',
        chatbot_resolved = true,
        chatbot_response = 'Respuesta autom√°tica de verificaci√≥n de pago enviada',
        updated_at = NOW()
      WHERE ticket_id = '{{ inputs.ticket_id }}'
    store: true

  - id: create_followup_task
    type: io.kestra.plugin.jdbc.postgresql.Query
    needs: update_ticket
    url: "{{ envs.POSTGRES_URL }}"
    username: "{{ envs.POSTGRES_USER }}"
    password: "{{ envs.POSTGRES_PASSWORD }}"
    sql: |
      -- Crear tarea de seguimiento para verificar pago en 24-48 horas
      INSERT INTO support_followup_tasks (
        ticket_id,
        task_type,
        description,
        due_date,
        priority,
        created_at
      ) VALUES (
        '{{ inputs.ticket_id }}',
        'payment_verification',
        'Verificar pago de factura {{ inputs.invoice_number }} en 24-48 horas',
        NOW() + INTERVAL '36 hours',
        'high',
        NOW()
      )
      ON CONFLICT DO NOTHING
    store: true
    allowFailure: true

  - id: track_metrics
    type: io.kestra.plugin.scripts.python.Script
    needs: [detect_scenario, calculate_credit, generate_response]
    script: |
      from workflow.kestra.flows.lib.support_billing_payment_verification_advanced import (
          track_payment_verification_metrics,
          PaymentScenario, CustomerTier
      )
      import json
      
      scenario_data = {{ outputs.detect_scenario.output | json }}
      credit_data = {{ outputs.calculate_credit.output | json }}
      
      track_payment_verification_metrics(
          ticket_id="{{ inputs.ticket_id }}",
          scenario=PaymentScenario(scenario_data["scenario"]),
          customer_tier=CustomerTier(scenario_data["customer_tier"]),
          resolution_time=None,
          customer_satisfaction=None
      )
      
      print(json.dumps({
          "status": "metrics_tracked",
          "ticket_id": "{{ inputs.ticket_id }}",
          "scenario": scenario_data["scenario"],
          "credit_amount": credit_data["credit_amount"]
      }))
    store: true
    allowFailure: true

  - id: summary
    type: io.kestra.plugin.core.log.Log
    message: |
      ‚úÖ Automatizaci√≥n de verificaci√≥n de pago completada
      
      Ticket: {{ inputs.ticket_id }}
      Cliente: {{ outputs.get_customer_info.output.customer_info.customer_name }}
      Escenario: {{ outputs.detect_scenario.output.scenario }}
      Cr√©dito aplicado: ${{ outputs.calculate_credit.output.credit_amount }}
      Email enviado: {{ outputs.send_email.success }}
      
      Pr√≥ximos pasos:
      - Seguimiento programado para verificar pago en 24-48 horas
      - Cliente recibi√≥ respuesta autom√°tica con cr√©dito temporal
      - Ticket actualizado a "waiting_customer"

errors:
  - id: handle_error
    type: io.kestra.plugin.core.log.Log
    message: |
      ‚ùå Error en automatizaci√≥n de verificaci√≥n de pago
      
      Ticket: {{ inputs.ticket_id }}
      Error: {{ error.message }}
      
      Acci√≥n requerida: Revisar manualmente el ticket



